From: Jon Ander Hernandez <jonan.h@gmail.com>
Date: Sat, 3 Sep 2016 20:03:13 +0300
Subject: Add SOURCE_DIR pointing to MNMLSTC Core

---
 src/bsoncxx/third_party/core/.gitattributes        |    4 +
 src/bsoncxx/third_party/core/.gitignore            |    6 +
 src/bsoncxx/third_party/core/CMakeLists.txt        |  212 +++
 src/bsoncxx/third_party/core/License.rst           |   13 +
 src/bsoncxx/third_party/core/Readme.rst            |   47 +
 .../third_party/core/configure/WIX.template.in     |   58 +
 .../core/configure/core-config.cmake.in            |    8 +
 src/bsoncxx/third_party/core/docs/CMakeLists.txt   |   19 +
 src/bsoncxx/third_party/core/docs/algorithm.rst    |  843 +++++++++
 src/bsoncxx/third_party/core/docs/any.rst          |  142 ++
 src/bsoncxx/third_party/core/docs/conf.py          |   23 +
 src/bsoncxx/third_party/core/docs/functional.rst   |   98 +
 src/bsoncxx/third_party/core/docs/index.rst        |   28 +
 src/bsoncxx/third_party/core/docs/iterator.rst     |   77 +
 src/bsoncxx/third_party/core/docs/memory.rst       |  635 +++++++
 src/bsoncxx/third_party/core/docs/numeric.rst      |   90 +
 src/bsoncxx/third_party/core/docs/optional.rst     |  955 ++++++++++
 src/bsoncxx/third_party/core/docs/range.rst        |  278 +++
 src/bsoncxx/third_party/core/docs/string.rst       |  313 ++++
 src/bsoncxx/third_party/core/docs/type-traits.rst  |  101 +
 src/bsoncxx/third_party/core/docs/usage.rst        |   24 +
 src/bsoncxx/third_party/core/docs/utility.rst      |   77 +
 src/bsoncxx/third_party/core/docs/variant.rst      |  156 ++
 .../third_party/core/include/core/algorithm.hpp    | 1933 ++++++++++++++++++++
 src/bsoncxx/third_party/core/include/core/any.hpp  |  293 +++
 .../third_party/core/include/core/functional.hpp   |  201 ++
 .../third_party/core/include/core/iterator.hpp     |  164 ++
 .../third_party/core/include/core/memory.hpp       |  804 ++++++++
 .../third_party/core/include/core/numeric.hpp      |  156 ++
 .../third_party/core/include/core/optional.hpp     | 1705 +++++++++++++++++
 .../third_party/core/include/core/range.hpp        |  313 ++++
 .../third_party/core/include/core/string.hpp       |  369 ++++
 .../third_party/core/include/core/type_traits.hpp  |  267 +++
 .../third_party/core/include/core/utility.hpp      |  142 ++
 .../third_party/core/include/core/variant.hpp      |  400 ++++
 .../third_party/core/package/CMakeLists.txt        |   59 +
 src/bsoncxx/third_party/core/package/License.rtf   |  Bin 0 -> 887 bytes
 src/bsoncxx/third_party/core/package/banner.bmp    |  Bin 0 -> 29846 bytes
 src/bsoncxx/third_party/core/package/dialog.bmp    |  Bin 0 -> 461814 bytes
 src/bsoncxx/third_party/core/package/mnmlstc.ico   |  Bin 0 -> 104325 bytes
 src/bsoncxx/third_party/core/tests/CMakeLists.txt  |   53 +
 src/bsoncxx/third_party/core/tests/algorithm.cpp   |  691 +++++++
 src/bsoncxx/third_party/core/tests/any.cpp         |  168 ++
 src/bsoncxx/third_party/core/tests/functional.cpp  |  167 ++
 src/bsoncxx/third_party/core/tests/iterator.cpp    |   70 +
 src/bsoncxx/third_party/core/tests/memory.cpp      |  641 +++++++
 src/bsoncxx/third_party/core/tests/numeric.cpp     |   95 +
 src/bsoncxx/third_party/core/tests/optional.cpp    | 1175 ++++++++++++
 src/bsoncxx/third_party/core/tests/range.cpp       |  453 +++++
 src/bsoncxx/third_party/core/tests/string.cpp      |  389 ++++
 src/bsoncxx/third_party/core/tests/type-traits.cpp |   57 +
 src/bsoncxx/third_party/core/tests/utility.cpp     |   40 +
 src/bsoncxx/third_party/core/tests/variant.cpp     |  274 +++
 53 files changed, 15286 insertions(+)
 create mode 100644 src/bsoncxx/third_party/core/.gitattributes
 create mode 100644 src/bsoncxx/third_party/core/.gitignore
 create mode 100644 src/bsoncxx/third_party/core/CMakeLists.txt
 create mode 100644 src/bsoncxx/third_party/core/License.rst
 create mode 100644 src/bsoncxx/third_party/core/Readme.rst
 create mode 100644 src/bsoncxx/third_party/core/configure/WIX.template.in
 create mode 100644 src/bsoncxx/third_party/core/configure/core-config.cmake.in
 create mode 100644 src/bsoncxx/third_party/core/docs/CMakeLists.txt
 create mode 100644 src/bsoncxx/third_party/core/docs/algorithm.rst
 create mode 100644 src/bsoncxx/third_party/core/docs/any.rst
 create mode 100644 src/bsoncxx/third_party/core/docs/conf.py
 create mode 100644 src/bsoncxx/third_party/core/docs/functional.rst
 create mode 100644 src/bsoncxx/third_party/core/docs/index.rst
 create mode 100644 src/bsoncxx/third_party/core/docs/iterator.rst
 create mode 100644 src/bsoncxx/third_party/core/docs/memory.rst
 create mode 100644 src/bsoncxx/third_party/core/docs/numeric.rst
 create mode 100644 src/bsoncxx/third_party/core/docs/optional.rst
 create mode 100644 src/bsoncxx/third_party/core/docs/range.rst
 create mode 100644 src/bsoncxx/third_party/core/docs/string.rst
 create mode 100644 src/bsoncxx/third_party/core/docs/type-traits.rst
 create mode 100644 src/bsoncxx/third_party/core/docs/usage.rst
 create mode 100644 src/bsoncxx/third_party/core/docs/utility.rst
 create mode 100644 src/bsoncxx/third_party/core/docs/variant.rst
 create mode 100644 src/bsoncxx/third_party/core/include/core/algorithm.hpp
 create mode 100644 src/bsoncxx/third_party/core/include/core/any.hpp
 create mode 100644 src/bsoncxx/third_party/core/include/core/functional.hpp
 create mode 100644 src/bsoncxx/third_party/core/include/core/iterator.hpp
 create mode 100644 src/bsoncxx/third_party/core/include/core/memory.hpp
 create mode 100644 src/bsoncxx/third_party/core/include/core/numeric.hpp
 create mode 100644 src/bsoncxx/third_party/core/include/core/optional.hpp
 create mode 100644 src/bsoncxx/third_party/core/include/core/range.hpp
 create mode 100644 src/bsoncxx/third_party/core/include/core/string.hpp
 create mode 100644 src/bsoncxx/third_party/core/include/core/type_traits.hpp
 create mode 100644 src/bsoncxx/third_party/core/include/core/utility.hpp
 create mode 100644 src/bsoncxx/third_party/core/include/core/variant.hpp
 create mode 100644 src/bsoncxx/third_party/core/package/CMakeLists.txt
 create mode 100644 src/bsoncxx/third_party/core/package/License.rtf
 create mode 100644 src/bsoncxx/third_party/core/package/banner.bmp
 create mode 100644 src/bsoncxx/third_party/core/package/dialog.bmp
 create mode 100644 src/bsoncxx/third_party/core/package/mnmlstc.ico
 create mode 100644 src/bsoncxx/third_party/core/tests/CMakeLists.txt
 create mode 100644 src/bsoncxx/third_party/core/tests/algorithm.cpp
 create mode 100644 src/bsoncxx/third_party/core/tests/any.cpp
 create mode 100644 src/bsoncxx/third_party/core/tests/functional.cpp
 create mode 100644 src/bsoncxx/third_party/core/tests/iterator.cpp
 create mode 100644 src/bsoncxx/third_party/core/tests/memory.cpp
 create mode 100644 src/bsoncxx/third_party/core/tests/numeric.cpp
 create mode 100644 src/bsoncxx/third_party/core/tests/optional.cpp
 create mode 100644 src/bsoncxx/third_party/core/tests/range.cpp
 create mode 100644 src/bsoncxx/third_party/core/tests/string.cpp
 create mode 100644 src/bsoncxx/third_party/core/tests/type-traits.cpp
 create mode 100644 src/bsoncxx/third_party/core/tests/utility.cpp
 create mode 100644 src/bsoncxx/third_party/core/tests/variant.cpp

diff --git a/src/bsoncxx/third_party/core/.gitattributes b/src/bsoncxx/third_party/core/.gitattributes
new file mode 100644
index 0000000..300ca3f
--- /dev/null
+++ b/src/bsoncxx/third_party/core/.gitattributes
@@ -0,0 +1,4 @@
+*.png binary
+*.ico binary
+*.bmp binary
+*.rtf binary
diff --git a/src/bsoncxx/third_party/core/.gitignore b/src/bsoncxx/third_party/core/.gitignore
new file mode 100644
index 0000000..d6db28a
--- /dev/null
+++ b/src/bsoncxx/third_party/core/.gitignore
@@ -0,0 +1,6 @@
+.DS_Store
+*.pyc
+*.swp
+*~
+
+build/
diff --git a/src/bsoncxx/third_party/core/CMakeLists.txt b/src/bsoncxx/third_party/core/CMakeLists.txt
new file mode 100644
index 0000000..8d205ec
--- /dev/null
+++ b/src/bsoncxx/third_party/core/CMakeLists.txt
@@ -0,0 +1,212 @@
+cmake_minimum_required(VERSION 2.8.11)
+project(core CXX)
+
+#------------------------------------------------------------------------------
+# Modules, Variables, and Options
+#------------------------------------------------------------------------------
+include(CMakePackageConfigHelpers)
+include(CMakeDependentOption)
+include(CheckCXXCompilerFlag)
+include(CheckIncludeFileCXX)
+include(CTest)
+
+set(INCLUDE_INSTALL_DIR "include" CACHE INTERNAL "Header Files")
+set(CMAKE_INSTALL_DIR "share/cmake/core" CACHE INTERNAL "CMake Files")
+set(DOCS_INSTALL_DIR "share/doc/mnmlstc/core" CACHE INTERNAL "Documentation")
+
+set(CORE_VERSION_MAJOR 1)
+set(CORE_VERSION_MINOR 1)
+set(CORE_VERSION_PATCH 0)
+set(CORE_VERSION
+  ${CORE_VERSION_MAJOR}.${CORE_VERSION_MINOR}.${CORE_VERSION_PATCH}
+)
+
+set(TEST_SOURCE_DIR "${PROJECT_SOURCE_DIR}/tests")
+set(TEST_BINARY_DIR "${PROJECT_BINARY_DIR}/tests")
+
+set(DOCS_SOURCE_DIR "${PROJECT_SOURCE_DIR}/docs")
+set(DOCS_BINARY_DIR "${PROJECT_BINARY_DIR}/docs")
+
+set(PACK_SOURCE_DIR "${PROJECT_SOURCE_DIR}/package")
+set(PACK_BINARY_DIR "${PROJECT_BINARY_DIR}/package")
+
+list(APPEND CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/configure")
+
+# Used by cmake-dependent-option
+list(APPEND RPM_DEP "UNIX" "NOT APPLE" "BUILD_PACKAGE")
+list(APPEND PKG_DEP "APPLE" "BUILD_PACKAGE")
+list(APPEND MSI_DEP "WIN32" "BUILD_PACKAGE")
+
+option(BUILD_WITH_LIBCXX "Use libc++ as stdlib" OFF)
+option(BUILD_PACKAGE "Build package with CPack" OFF)
+option(BUILD_DOCS "Build documentation with Sphinx Documentation Generator")
+
+cmake_dependent_option(BUILD_PACKAGE_MSI "Create an MSI" ON "${MSI_DEP}" OFF)
+cmake_dependent_option(BUILD_PACKAGE_RPM "Create an RPM" ON "${RPM_DEP}" OFF)
+cmake_dependent_option(BUILD_PACKAGE_PKG "Create a PKG" ON "${PKG_DEP}" OFF)
+
+if (APPLE AND ${CMAKE_CXX_COMPILER_ID} STREQUAL "Clang")
+  set(BUILD_WITH_LIBCXX ON CACHE BOOL "Use libc++ as stdlib" ON)
+endif ()
+
+#------------------------------------------------------------------------------
+# Compiler Environment Check
+#------------------------------------------------------------------------------
+set(USE_STDLIB_LIBCXX "-stdlib=libc++")
+set(USE_STD_CXX11 "-std=c++11")
+
+set(USE_EXCEPTIONS "-fexceptions")
+set(USE_RTTI "-frtti")
+
+set(USE_PEDANTIC "-pedantic")
+
+set(WARN_EVERYTHING "-Weverything")
+set(WARN_NOEXCEPT "-Wnoexcept")
+set(WARN_ONE_LINE "-WL")
+set(WARN_ERROR "-Werror")
+set(WARN_EXTRA "-Wextra")
+set(WARN_ALL "-Wall")
+
+# MSVC is currently unsupported, but this is here for when they get their
+# act together.
+if (MSVC)
+  set(USE_EXCEPTIONS "/Ehsc")
+
+  set(WARN_EVERYTHING "-Wall") # Yes, I am aware of the irony.
+  set(WARN_ERROR "-Werror")
+  set(WARN_ALL "-W4")
+endif ()
+
+check_cxx_compiler_flag(${USE_STDLIB_LIBCXX} CAN_USE_STDLIB_LIBCXX)
+check_cxx_compiler_flag(${USE_STD_CXX11} CAN_USE_STD_CXX11)
+
+check_cxx_compiler_flag(${USE_EXCEPTIONS} CAN_USE_EXCEPTIONS)
+check_cxx_compiler_flag(${USE_RTTI} CAN_USE_RTTI)
+
+check_cxx_compiler_flag(${USE_PEDANTIC} CAN_USE_PEDANTIC)
+
+check_cxx_compiler_flag(${WARN_EVERYTHING} CAN_WARN_EVERYTHING)
+check_cxx_compiler_flag(${WARN_NOEXCEPT} CAN_WARN_NOEXCEPT)
+check_cxx_compiler_flag(${WARN_ONE_LINE} CAN_WARN_ONE_LINE)
+check_cxx_compiler_flag(${WARN_ERROR} CAN_WARN_ERROR)
+check_cxx_compiler_flag(${WARN_EXTRA} CAN_WARN_EXTRA)
+check_cxx_compiler_flag(${WARN_ALL} CAN_WARN_ALL)
+
+if (CAN_USE_STDLIB_LIBCXX AND BUILD_WITH_LIBCXX)
+  set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} ${USE_STDLIB_LIBCXX}")
+endif ()
+
+if (CAN_USE_STD_CXX11)
+  set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} ${USE_STD_CXX11}")
+endif ()
+
+# These headers are required
+check_include_file_cxx(initializer_list HAVE_INITIALIZER_LIST)
+check_include_file_cxx(type_traits HAVE_TYPE_TRAITS)
+check_include_file_cxx(tuple HAVE_TUPLE)
+
+check_include_file_cxx(cstdint HAVE_CSTDINT)
+check_include_file_cxx(cstddef HAVE_CSTDDEF)
+
+# Handle Insane Environment
+if (NOT HAVE_INITIALIZER_LIST)
+  message(FATAL_ERROR "standard header <initializer_list> could not be found")
+endif ()
+
+if (NOT HAVE_TYPE_TRAITS)
+  message(FATAL_ERROR "standard header <type_traits> could not be found")
+endif ()
+
+if (NOT HAVE_TUPLE)
+  message(FATAL_ERROR "standard header <tuple> could not be found")
+endif ()
+
+if (NOT HAVE_CSTDINT)
+  message(FATAL_ERROR "standard header <cstdint> could not be found")
+endif ()
+
+if (NOT HAVE_CSTDDEF)
+  message(FATAL_ERROR "standard header <cstddef> could not be found")
+endif ()
+
+#------------------------------------------------------------------------------
+# Configuration
+#------------------------------------------------------------------------------
+write_basic_package_version_file(
+  "${PROJECT_BINARY_DIR}/${PROJECT_NAME}-config-version.cmake"
+  VERSION ${CORE_VERSION}
+  COMPATIBILITY SameMajorVersion
+)
+
+configure_package_config_file(
+  "${PROJECT_SOURCE_DIR}/configure/${PROJECT_NAME}-config.cmake.in"
+  "${PROJECT_BINARY_DIR}/${PROJECT_NAME}-config.cmake"
+  INSTALL_DESTINATION "${CMAKE_INSTALL_DIR}"
+  PATH_VARS INCLUDE_INSTALL_DIR CMAKE_INSTALL_DIR
+)
+
+include_directories(${PROJECT_SOURCE_DIR}/include)
+
+if (CAN_USE_STDLIB_LIBCXX AND BUILD_WITH_LIBCXX)
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${USE_STDLIB_LIBCXX}")
+endif ()
+
+if (CAN_USE_STD_CXX11)
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${USE_STD_CXX11}")
+endif ()
+
+if (CAN_USE_PEDANTIC)
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${USE_PEDANTIC}")
+endif ()
+
+if (CAN_WARN_ALL)
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${WARN_ALL}")
+endif ()
+
+if (CAN_WARN_NOEXCEPT)
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${WARN_NOEXCEPT}")
+endif ()
+
+if (CAN_WARN_EXTRA)
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${WARN_EXTRA}")
+endif ()
+
+if (BUILD_TESTING)
+  set(CMAKE_TEST_COMMAND ctest)
+  add_subdirectory("${TEST_SOURCE_DIR}" "${TEST_BINARY_DIR}" EXCLUDE_FROM_ALL)
+endif ()
+
+if (BUILD_DOCS)
+  add_subdirectory("${DOCS_SOURCE_DIR}" "${DOCS_BINARY_DIR}" EXCLUDE_FROM_ALL)
+endif ()
+
+if (BUILD_PACKAGE)
+  add_subdirectory("${PACK_SOURCE_DIR}" "${PACK_BINARY_DIR}" EXCLUDE_FROM_ALL)
+endif ()
+
+#------------------------------------------------------------------------------
+# Install
+#------------------------------------------------------------------------------
+install(FILES
+  ${PROJECT_BINARY_DIR}/core-config-version.cmake
+  ${PROJECT_BINARY_DIR}/core-config.cmake
+  DESTINATION ${CMAKE_INSTALL_DIR}
+)
+
+install(DIRECTORY "${PROJECT_SOURCE_DIR}/include/core"
+  DESTINATION ${INCLUDE_INSTALL_DIR}
+  FILES_MATCHING PATTERN "*.hpp"
+)
+
+if (BUILD_DOCS)
+  install(DIRECTORY "${DOCS_BINARY_DIR}/"
+    DESTINATION ${DOCS_INSTALL_DIR}
+    FILES_MATCHING
+    PATTERN ".buildinfo" EXCLUDE
+    PATTERN "CMakeFiles" EXCLUDE
+    PATTERN ".doctrees" EXCLUDE
+    PATTERN "Makefile" EXCLUDE
+    PATTERN "*.cmake" EXCLUDE
+    PATTERN "*"
+  )
+endif ()
diff --git a/src/bsoncxx/third_party/core/License.rst b/src/bsoncxx/third_party/core/License.rst
new file mode 100644
index 0000000..ab6dbfc
--- /dev/null
+++ b/src/bsoncxx/third_party/core/License.rst
@@ -0,0 +1,13 @@
+.. |copy| unicode:: U+000A9
+.. _License: http://www.apache.org/licenses/LICENSE-2.0
+
+Copyright |copy| 2013 - 2014 MNMLSTC
+
+Licensed under the Apache License_, Version 2.0 (the "License"); you may not
+use this software except in compliance with the License_. You may obtain a
+copy of the License_ at http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software distributed
+under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+CONDITIONS OF ANY KIND, either express or implied. See the License for the
+specific language governing permissions and limitations under the License.
diff --git a/src/bsoncxx/third_party/core/Readme.rst b/src/bsoncxx/third_party/core/Readme.rst
new file mode 100644
index 0000000..40f3da3
--- /dev/null
+++ b/src/bsoncxx/third_party/core/Readme.rst
@@ -0,0 +1,47 @@
+Overview
+========
+
+MNMLSTC Core is a small and easy to use C++11 library that adds a functionality
+set that will be available in C++14 and later, as well as some useful
+additions, or some proposals that have not been completely approved yet.
+
+Information on installing and using MNMLSTC Core can be found in its
+`documentation <http://mnmlstc.github.io/core/>`_.
+
+MNMLSTC Core is released under the Apache 2.0 License.
+
+Components
+----------
+
+Some components provided by MNMLSTC Core are:
+
+ * ``variant<Ts...>``
+ * ``optional<T>``
+ * ``expected<T>``
+ * ``deep_ptr<T>``
+ * ``poly_ptr<T>``
+ * ``string_view``
+ * ``range<T>``
+ * ``any``
+
+Details on each component can be found in MNMLSTC Core's documentation. All of
+the MNMLSTC Core components reside in the ``core`` namespace. The library is
+organized equivalent to the standard library e.g., components related to memory
+are in the memory header, functional components in the functional header, etc.
+
+Requirements
+------------
+
+There are several requirements to fully use MNMLSTC Core:
+
+ * A C++11 compliant compiler (GCC 4.8.2 or Clang 3.3 meet the minimum feature
+   set required to build and use MNMLSTC Core)
+ * `CMake 2.8.11 <http://cmake.org>`_
+ * `MNMLSTC Unittest <https://github.com/mnmlstc/unittest>`_
+ * `Sphinx Documentation Generator <http://sphinx-doc.org>`_
+ * `Sphinx RTD Theme <https://pypi.python.org/pypi/sphinx_rtd_theme>`_
+
+MNMLSTC Unittest is only necessary if building and running the unit tests.
+
+Sphinx and the Sphinx RTD Theme are only necessary if generating
+documentation manually.
diff --git a/src/bsoncxx/third_party/core/configure/WIX.template.in b/src/bsoncxx/third_party/core/configure/WIX.template.in
new file mode 100644
index 0000000..3a4c61a
--- /dev/null
+++ b/src/bsoncxx/third_party/core/configure/WIX.template.in
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<?include "cpack_variables.wxi"?>
+
+<Wix xmlns="http://schemas.microsoft.com/wix/2006/wi"
+    RequiredVersion="3.6.3303.0">
+    <Product Id="$(var.CPACK_WIX_PRODUCT_GUID)"
+        Name="$(var.CPACK_PACKAGE_NAME)"
+        Language="1033"
+        Version="$(var.CPACK_PACKAGE_VERSION)"
+        Manufacturer="$(var.CPACK_PACKAGE_VENDOR)"
+        UpgradeCode="$(var.CPACK_WIX_UPGRADE_GUID)">
+
+        <Package InstallerVersion="301" Compressed="yes"/>
+
+        <Media Id="1" Cabinet="media1.cab" EmbedCab="yes"/>
+
+        <MajorUpgrade
+            Schedule="afterInstallInitialize"
+            AllowSameVersionUpgrades="yes"
+            DowngradeErrorMessage="A later version of [ProductName] is already installed. Setup will now exit."/>
+
+        <WixVariable Id="WixUILicenseRtf" Value="$(var.CPACK_WIX_LICENSE_RTF)"/>
+        <Property Id="WIXUI_INSTALLDIR" Value="INSTALL_ROOT"/>
+
+        <?ifdef CPACK_WIX_PRODUCT_ICON?>
+        <Property Id="ARPPRODUCTICON">ProductIcon.ico</Property>
+        <Icon Id="ProductIcon.ico" SourceFile="$(var.CPACK_WIX_PRODUCT_ICON)"/>
+        <?endif?>
+
+        <?ifdef CPACK_WIX_UI_BANNER?>
+        <WixVariable Id="WixUIBannerBmp" Value="$(var.CPACK_WIX_UI_BANNER)"/>
+        <?endif?>
+
+        <?ifdef CPACK_WIX_UI_DIALOG?>
+        <WixVariable Id="WixUIDialogBmp" Value="$(var.CPACK_WIX_UI_DIALOG)"/>
+        <?endif?>
+
+        <DirectoryRef Id="TARGETDIR">
+          <Component Id="RegistryEntries" Guid="*">
+            <RegistryKey Root="HKLM"
+              Key="Software\Kitware\CMake\Packages\[ProductName]">
+              <RegistryValue Type="string"
+                Name="$(var.CPACK_PACKAGE_VERSION)"
+                Value="[INSTALL_ROOT]"
+                KeyPath="yes" />
+            </RegistryKey>
+          </Component>
+        </DirectoryRef>
+
+        <FeatureRef Id="ProductFeature"/>
+        <Feature Id="RegistryEntries" Level="1">
+          <ComponentRef Id="RegistryEntries" />
+        </Feature>
+
+        <UIRef Id="WixUI_InstallDir" />
+    </Product>
+</Wix>
diff --git a/src/bsoncxx/third_party/core/configure/core-config.cmake.in b/src/bsoncxx/third_party/core/configure/core-config.cmake.in
new file mode 100644
index 0000000..bee1b76
--- /dev/null
+++ b/src/bsoncxx/third_party/core/configure/core-config.cmake.in
@@ -0,0 +1,8 @@
+set(CORE_VERSION 1.1.0)
+
+@PACKAGE_INIT@
+
+set_and_check(CORE_INCLUDE_DIR "@PACKAGE_INCLUDE_INSTALL_DIR@")
+set_and_check(CORE_CMAKE_DIR "@PACKAGE_CMAKE_INSTALL_DIR@")
+
+check_required_components(core)
diff --git a/src/bsoncxx/third_party/core/docs/CMakeLists.txt b/src/bsoncxx/third_party/core/docs/CMakeLists.txt
new file mode 100644
index 0000000..1ec1612
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/CMakeLists.txt
@@ -0,0 +1,19 @@
+find_program(SPHINX_EXECUTABLE
+  NAMES sphinx-build
+  DOC "Sphinx Documentation Generator"
+)
+
+if (NOT SPHINX_EXECUTABLE)
+  message(FATAL_ERROR "Cannot build documentation without Sphinx!")
+endif ()
+mark_as_advanced(SPHINX_EXECUTABLE)
+
+add_custom_target(docs
+  COMMAND ${SPHINX_EXECUTABLE} ${DOCS_SOURCE_DIR} ${DOCS_BINARY_DIR}
+  COMMENT "Generating Sphinx Documentation" VERBATIM
+)
+
+set_property(
+  DIRECTORY APPEND PROPERTY
+  ADDITIONAL_MAKE_CLEAN_FILES ${DOCS_BINARY_DIR}
+)
diff --git a/src/bsoncxx/third_party/core/docs/algorithm.rst b/src/bsoncxx/third_party/core/docs/algorithm.rst
new file mode 100644
index 0000000..0267033
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/algorithm.rst
@@ -0,0 +1,843 @@
+.. _core-algorithm-component:
+
+Algorithm Component
+===================
+
+.. default-domain:: cpp
+.. highlight:: cpp
+
+The algorithm component can be seen as a competitor to the Boost.Range
+algorithm headers. There are a few small differences (namely that this
+component relies on the :ref:`core-range-component`), however these differences
+are discussed below.
+
+The algorithm component can be found in the ``<core/algorithm.hpp>`` header.
+
+.. note:: All of the functions in this component that take a range take
+   universal references in most cases. The reasons for this are:
+
+    * there should be a minimal amount of overhead
+    * we shouldn't add to this overhead
+    * we have perfect forwarding
+
+   In the author's opinion, causing additional parameters to be passed to the
+   underlying functions by value is an unnecessary cost. The only cost that
+   should be incurred is the one to :func:`make_range`.
+
+.. _core-algorithm-component-non-modifying-sequence-operations:
+
+Non-Modifying Sequence Operations
+---------------------------------
+
+.. function:: bool all_of (Range&& range, UnaryPredicate&& up)
+
+   :returns: ``true`` if *up* returns ``true`` for **all** elements in *range*.
+   :requires: *range* must provide InputIterators.
+
+.. function:: bool any_of (Range&& range, UnaryPredicate&& up)
+
+   :returns: ``true`` if *up* returns ``true`` for **any** elements in *range*.
+   :requires: *range* must provide InputIterators.
+
+.. function:: bool none_of (Range&& range, UnaryPredicate&& up)
+
+   :returns: ``true`` if *up* returns ``false`` for **all** elements in *range*.
+   :requires: *range* must provide InputIterators.
+
+.. function:: decay_t<UnaryFunction> for_each (Range&& range, UnaryFunction&& f)
+
+   :returns: *f* by value.
+   :requires: *range* must provide InputIterators.
+
+.. function:: difference_type count (Range&& range, T const& value)
+              difference_type count_if (Range&& range, UnaryPredicate&& up)
+
+   :returns: Number of elements equal to *value* or times *up* returned true.
+   :requires: *range* must provide InputIterators
+
+.. function:: pair<InputIt1, InputIt2> mismatch (Range&& range, InputIt2&& it)
+              pair<InputIt1, InputIt2> mismatch (\
+                Range&& range,\
+                InputIt2&& it,\
+                BinaryPredicate&& bp\
+              )
+
+   The first overload uses ``operator ==``, while the second uses *bp*.
+
+   :returns: The first mismatching pair of elements from *range* and the
+             range starting at *it*.
+   :requires: *range* must provide InputIterators
+
+.. function:: bool equal (Range&& range, InputIt&& it)
+              bool equal (Range&& range, InputIt&& it, BinaryPredicate&& bp)
+
+   :returns: ``true`` if *range* and the elements in *it* are equal. The
+             first version uses ``operator ==``. The second uses *bp*.
+   :requires: *range* must provide InputIterators
+
+.. function:: InputIt find (Range&& range, T const& value)
+              InputIt find_if (Range&& range, UnaryPredicate&& p)
+
+   :returns: iterator to the item found in *range*. If no item is found or if
+             *p* never returns true, the iterator is equal to the end of the
+             range.
+   :requires: *range* must provide InputIterators
+
+.. function:: ForwardIt find_end (Range1&& range1, Range2&& range2)
+              ForwardIt find_end (\
+                Range1&& range1,\
+                Range2&& range2,\
+                BinaryPredicate&& bp\
+              )
+
+   Searches for the last subsequence of elements in *range2* within *range1*.
+   The first version uses ``operator ==``. The second uses the provided
+   binary predicate *bp*.
+
+   :returns: Iterator to the beginning of the last subsequence in *range1*.
+   :requires: Both *range1* and *range2* must provide ForwardIterators
+
+.. function:: InputIt find_first_of (IRange&& irange, FRange&& frange)
+              InputIt find_first_of (\
+                IRange&& irange,\
+                FRange&& frange,\
+                BinaryPredicate&& bp\
+              )
+
+   :returns: Iterator to the first element in *irange* that is also in *frange*.
+             If no such element is found, the end of *irange* is returned.
+   :requires: *irange* must provide InputIterators, *frange* must provide
+              ForwardIterators.
+
+.. function:: ForwardIt adjacent_find (Range&& range)
+              ForwardIt adjacent_find (Range&& range, BinaryPredicate&& bp)
+
+   Searches *range* for two consecutive identical elements. The first version
+   uses ``operator ==`` to compare the elements, the second version uses the
+   given binary predicate *bp*.
+
+   :returns: ForwardIterator to the first of the identical elements. If no
+             such elements are found, the end of *range* is returned.
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: ForwardIt search (Range1&& range1, Range2&& range2)
+              ForwardIt search (\
+                Range1&& range1,\
+                Range2&& range2,\
+                BinaryPredicate&& bp\
+              )
+
+   Searches for the first occurrence of the subsequence of elements in *range2*
+   in *range1*. ``operator ==`` is used for the first version, while *bp* is
+   utilized for the second.
+
+   :returns: Forward iterator to the subsequence, if found. Otherwise the end
+             of *range1*.
+   :requires: *range1* and *range2* must provide ForwardIterators
+
+.. function:: ForwardIt search_n (Range&& range, Size&& count, T const& value)
+              ForwardIt search_n (\
+                Range&& range,\
+                Size&& count,\
+                T const& value,\
+                BinaryPredicate&& bp\
+              )
+
+   Searches *range* for the first sequence of *count* identical elements equal
+   to *value*. The first version uses ``operator ==``. The second uses the
+   provided binary predicate *bp*.
+
+   :returns: ForwardIterator to the start of the discovered sequence of the
+             end of *range* if no such sequence was found.
+   :requires: *range* must provide ForwardIterators
+
+.. _core-alglorithm-component-modifying-sequence-operations:
+
+Modifying Sequence Operations
+-----------------------------
+
+.. function:: decay_t<OutputIt> copy (Range&& range, OutputIt&& it)
+              decay_t<OutputIt> copy_if (\
+                Range&& range,\
+                OutputIt&& it,\
+                UnaryPredicate&& up\
+              )
+
+   Copies the elements in *range* to *it*.
+
+   :returns: Iterator to one past the last element written.
+   :requires: *range* must provide InputIterators.
+
+.. function:: decay_t<BidirIt> copy_backward(Range&& range, BidirIt&& it)
+
+   Copies the elements from *range* to the range starting at *it*.
+   The elements are copied in reverse order (the last element is copied first),
+   but their relative order is preserved.
+
+   :returns: Iterator to the last element copied.
+   :requires: *range* must provide BidirectionalIterators.
+
+
+.. function:: decay_t<OutputIt> move (Range&& range, OutputIt&& it)
+
+   Moves the elements in *range* to another range starting at *it*. The
+   elements in *range* are in a valid but null state after moving.
+
+   :returns: Iterator to one past the last element written.
+   :requires: *range* must provide InputIterators.
+
+.. function:: decay_t<BidirIt> move_backward (Range&& range, BidirIt&& it)
+
+   Moves the elements from *range* to another range starting at *it*.
+   The elements are moved in reverse order (the last element is moved first),
+   but their relative order is preserved.
+
+   :returns: Iterator to the last element moved.
+   :requires: *range* must provide BidirectionalIterators.
+
+.. function:: void fill (Range&& range, T const& value)
+
+   Fills *range* with a copy of *value*.
+
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: decay_t<OutputIt> transform (\
+                Range&& range,\
+                OutputIt&& it,\
+                UnaryOperation&& op\
+              )
+              decay_t<OutputIt> transform (\
+                Range1&& range1,\
+                Range2&& range2,\
+                OutputIt&& it,\
+                BinaryOperation&& op\
+              )
+              OutputIt transform_if (\
+                Range&& range,\
+                OutputIt it,\
+                UnaryOperation op,\
+                UnaryPredicate up\
+              )
+              OutputIt transform_if (\
+                Range1&& range1,\
+                Range2&& range2,\
+                OutputIt it,\
+                BinaryOperation op,\
+                BinaryPredicate bp\
+              )
+
+   Applies the given function to *range* and stores the result in another
+   range, beginning at *it*. The first version applies the unary operation *op*
+   to the elements in *range*. The second version applies the binary operation
+   *op* to pairs of elements from *range1* and *range2*. The conditional
+   versions do not perfectly forward their arguments as the algorithm is
+   performed in situ. :func:`transform_if` can be considered a merging of
+   :func:`copy_if` and :func:`transform`.
+
+   :returns: Iterator to one past the last element transformed.
+   :requires: :func:`transform` uses InputIterators. :func:`transform_if` uses
+              ForwardIterators.
+
+.. function:: ForwardIt remove (Range&& range, T const& value)
+              ForwardIt remove_if (Range&& range, UnaryPredicate&& up)
+
+   Removes all elements satisfying specific criteris from *range* and returns
+   a past-the-end iterator for the new end of the range. The first version
+   removes all elements that are equal to *value*, while the second version
+   removes all eleents for which *up* returns ``true``.
+
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: decay_t<OutputIt> remove_copy (\
+                Range&& range,\
+                OutputIt&& it,\
+                T const& value\
+              )
+              decay_t<OutputIt> remove_copy_if (\
+                Range&& range,\
+                OutputIt&& it,\
+                UnaryPredicate&& up\
+              )
+
+   Copies elements from *range* to another range beignning at *it*, omitting
+   the elements which satisfy specific criteria. The first version ignores the
+   elements equal to *value*. The second version ignores the elements for which
+   *up* returns ``true``.
+
+   :returns: Iterator to the element past the last element copied.
+   :requires: *range* must provide InputIterators.
+
+.. function:: void remove_erase (Range&& range, T const& val)
+              void remove_erase_if (Range&& range, UnaryPredicate&& up)
+
+   Calls :func:`remove_erase` (or :func:`remove_erase_if`), and then calls
+   ``::std::forward<Range>(range).erase()`` on the result. These two functions
+   are provided because the remove -> erase idiom is extremely common when
+   working with containers.
+
+   :requires: The same requirements as :func:`remove` and :func:`remove_if`
+              respectively.
+
+.. function:: void replace (Range&& range, T const& old, T const& value)
+              void replace_if (Range&& range, UnaryPred&& up, T const& value)
+ 
+   Replaces all elements satisfying specific criteria with *value* in *range*.
+   The first version replaces elements equal to *old*. The second version
+   replaces elements for which *up* returns ``true``.
+
+   :requires: *range* must provide ForwardIterators
+
+.. function:: decay_t<OutputIt> replace_copy (\
+                Range&& range,\
+                OutputIt&& it,\
+                T const& old,\
+                T const& value\
+              )
+              decay_t<OutputIt> replace_copy_if (\
+                Range&& range,\
+                OutputIt&& it,\
+                UnaryPred&& up,\
+                T const& value\
+              )
+
+   Copies the elements from *range* to another range beginning at *it*.
+   Elements satisfying specific criteria are replaced with *value*. The first
+   version replaces elements equal to *old*. The second version replaces
+   elements for which *up* returns ``true``. The source and destination
+   ranges *cannot* overlap.
+
+   :requires: *range* must provide InputIterators.
+
+.. function:: decay_t<ForwardIt> swap_ranges (Range&& range, ForwardIt&& it)
+
+   Exchanges elements between *range* and another range starting at *it*.
+
+   :returns: Iterator to the element past the last element exchanged with range
+             starting at *it*.
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: void reverse (Range&& range)
+
+   Reverses the order of the elements in *range*.
+
+   :requires: *range* must provide BidirectionalIterators.
+
+.. function:: decay_t<OutputIt> reverse_copy (Range&& range, OutputIt&& it)
+
+   Copies the elements from *range* to another range starting at *it* where the
+   elements in the new range are in reverse order.
+
+   :returns: Output iterator to the element past the last element copied.
+   :requires: *range* must provide BidirectionalIterators.
+
+.. function:: void rotate (Range&& range, ForwardIt&& it)
+
+   Performs a left rotation on a range of elements. Specifically, it swaps
+   the elements in *range* in such a way that the element at *it* becomes the
+   first element of the range.
+
+   .. note:: Due to an incorrect interface in libstdc++, this form of rotate
+             returns ``void``. Technically it is required to return a
+             ForwardIterator, however this is ignored to take the path of least
+             resistance.
+
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: decay_t<OutputIt> rotate_copy (\
+                Range&& range,\
+                ForwardIt&& it,\
+                OutputIt&& ot\
+              )
+
+   Copies the elements from *range* to another range starting at *ot* where
+   *it* will be the first element of the new range, and *it* - 1 becomes the
+   last.
+
+   :returns: Output iterator to the element past the last element copied.
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: void shuffle (Range&& range, URNG&& g)
+
+   Reorders elements in *range* so that each possible permutation of those
+   elements has equal probablity of appearance. The random number generator 
+   is the function object *g*.
+
+   .. note:: As you may have noticed, ``random_shuffle`` does not make an
+             appearance. This is due to the C++14 standard deprecating
+             ``random_shuffle``.
+
+   :requires: *range* must provide RandomAccessIterators.
+
+.. function:: ForwardIt unique (Range&& range)
+              ForwardIt unique (Range&& range, BinaryPredicate&& bp)
+
+   Removes all consecutive duplicate elements from *range* and returns a
+   past-the-end iterator for the new logical end of the range. The first
+   version uses ``operator ==``. The second version uses the predicate *bp*.
+
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: decay_t<OutputIt> unique_copy (Range&& range, OutputIt&& it)
+              decay_t<OutputIt> unique_copy (\
+                Range&& range,\
+                OutputIt&& it,\
+                BinaryPred&& bp\
+              )
+
+   Copies the elements from *range* to another range beginning at *it* so
+   that no consecutive equal elements exist. The first version uses
+   ``operator ==`` to compare elements. The second version uses the predicate
+   *bp*.
+
+   :requires: *range* must provide InputIterators.
+
+.. _core-algorithm-component-partitioning-operations:
+
+Partitioning Operations
+-----------------------
+
+.. function:: bool is_partitioned (Range&& range, UnaryPredicate&& up)
+
+   :returns: ``true`` if all the elements in *range* that satisfy predicate
+             *up* appear before all the elements that don't or if *range* is
+             empty.
+   :requires: *range* must provide InputIterators.
+
+.. function:: ForwardIt partition (Range&& range, UnaryPredicate&& up)
+
+   Reorders elements in *range* such that all elements for which *up* return
+   ``true`` come before the elements where *up* returns ``false``. Relative
+   order is *not* preserved.
+
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: partition_copy (\
+                Range&& range,\
+                OutputTrue&& ot,\
+                OutputFalse&& of,\
+                UnaryPredicate&& up\
+              )
+
+   Copies the elements from *range* to different ranges depending on the result
+   of *up*. The elements that cause *up* to return ``true`` are copied to the
+   range starting at *ot*, and those that return ``false`` are copied to the
+   range starting at *of*.
+
+   It is undefined behavior to have the input range overlap *ot* or *of*.
+
+   :returns: ``std::pair<decay_t<OutputTrue>, decay_t<OutputFalse>>``
+   :requires: *range* must provide InputIterators.
+
+.. function:: BidirIt stable_partition (Range&& range, UnaryPredicate&& up)
+
+   Reorders the elements in *range* in the same way as :func:`partition`.
+   Unlike :func:`partition`, the order of elements is preserved.
+
+   :requires: *range* must provide BidirectionalIterators.
+
+.. function:: ForwardIt partition_point (Range&& range, UnaryPredicate&& up)
+
+   Examines *range* and locates the end of the first partition (i.e., the first
+   element in *range* that does not satisfy *up*. If all elements satisfy
+   *up*, the end of *range* is returned.
+
+   :requires: *range* must provide ForwardIterators.
+
+.. _core-algorithm-component-sorting-operations:
+
+Sorting Operations
+------------------
+
+.. function:: bool is_sorted (Range&& range)
+              bool is_sorted (Range&& range, Compare&& comp)
+
+   Checks if the elements in *range* are sorted in ascending order. The first
+   version uses ``operator <`` to compare elements. The second uses the
+   comparison function *comp*.
+
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: ForwardIt is_sorted_until (Range&& range)
+              ForwardIt is_sorted_until (Range&& range, Compare&& comp)
+
+   Inspects *range* and finds the largest sub range in which elements
+   are sorted in ascending order. The first version uses ``operator <``. The
+   second version uses the given comparison function *comp*.
+
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: void sort (Range&& range)
+              void sort (Range&& range, Compare&& comp)
+
+   Sorts the elements in *range* in ascending order. The order of elements
+   equal to each other is no guaranteed to be preserved. The first version
+   uses ``operator <``. The second version uses the given comparison function
+   *comp*.
+
+   :requires: *range* must provide RandomAccessIterators.
+
+.. function:: void partial_sort (Range&& range, RandomIt&& it)
+              void partial_sort (Range&& range, RandomIt&& it, Compare&& cmp)
+
+   Rearranges elements in *range* so that the range contains the sorted
+   ``it - range.begin()`` smallest elements.
+
+   The order of elements equal to each other is not guaranteed to be preserved.
+   The order of the remaining elements in *range* is unspecified. The first
+   version uses ``operator <``. The second version uses the provided comparison
+   function *comp*.
+
+   :requires: *range* must provide RandomAccessIterators.
+
+.. function:: RandomIt partial_sort_copy (IRange&& irange, RRange&& rrange)
+              RandomIt partial_sort_copy (\
+                IRange&& irange,\
+                RRange&& rrange,\
+                Compare&& cmp\
+              )
+
+   Sorts the elements in *irange* in ascending order, storing the result in
+   *rrange*. The order of elements which are equal is not guaranteed to be
+   preserved. The first version uses ``operator <``. The second uses the
+   comparison function *comp*.
+
+   :requires: *irange* must provide InputIterators, *rrange* must provide
+              RandomAccessIterators.
+
+.. function:: void stable_sort (Range&& range)
+              void stable_sort (Range&& range, Compare&& cmp)
+
+   Sorts elements in *range* in the same way as :func:`sort`, with the exception
+   that the order of equal elements is guaranteed to be preserved.
+
+   :requires: *range* must provide RandomAccessIterators.
+
+.. function:: void nth_element (Range&& range, RandomIt&& it)
+              void nth_element (Range&& range, RandomIt&& it, Compare&& cmp)
+
+   Partial sorting algorithm that rearranges elements in *range* such that
+   the element pointed at by *it* is changed to whatever element would occur in
+   that position if *range* was sorted and al of the elements before this new
+   element at *it* are less than or equal to the elements after *it*.
+
+   If *it* is the end iterator of *range*, this function has no effect.
+
+   :requires: *range* must provide RandomAccessIterators.
+
+.. _core-algorithm-component-binary-search-operations:
+
+Binary Search Operations
+------------------------
+
+.. note:: These operations are intended for sorted/partitioned ranges *only*.
+
+.. function:: ForwardIt lower_bound (Range&& range, T const& value)
+              ForwardIt lower_bound (\
+                Range&& range,\
+                T const& value,\
+                Compare&& cmp\
+              )
+
+   Returns an iterator pointing to the first element in *range* that is **not
+   less than** *value*. The range must be partially ordered. A fully sorted
+   range or a range resulting from :func:`partition` meets this criteria. The
+   first version uses ``operator <`` to compare elements, while the second uses
+   the given function *cmp*.
+
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: ForwardIt upper_bound (Range&& range, T const& value)
+              ForwardIt upper_bound (\
+                Range&& range,\
+                T const& value,\
+                Compare&& cmp\
+              )
+
+   Returns an iterator pointing to the first element in *range* that is
+   *greater* than value. The same ordering restructions in :func:`lower_bound`
+   apply. The first version uses ``operator <``. The second uses the
+   comparison function *cmp*.
+
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: bool binary_search (Range&& range, T const& value)
+              bool binary_search (Range&& range, T const& value, Compare&& cmp)
+
+   Checks if an element equal to *value* resides within *range*. Requires that
+   *range* be partitioned. The first version uses ``operator <``. The second
+   uses the given function *cmp*.
+
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: range<ForwardIt> equal_range (Range&& range, T const& value)
+              range<ForwardIt> equal_range (\
+                Range&& range,\
+                T const& value,\
+                Compare&& cmp\
+              )
+
+   Returns a range containing all elements equivalent to *value* in *range*.
+   The first version uses ``operator <``. The second uses the given comparison
+   function *cmp*.
+
+   :requires: *range* must provide ForwardIterators and must be correctly
+              partitioned.
+
+.. _core-algorithm-component-set-operations:
+
+Set Operations
+--------------
+
+.. function:: decay_t<OutputIt> merge (\
+                Range1&& range1,\
+                Range2&& range2,\
+                OutputIt&& it\
+              )
+              decay_t<OutputIt> merge (\
+                Range1&& range1,\
+                Range2&& range2,\
+                OutputIt&& it,\
+                Compare&& cmp\
+              )
+
+   Merges sorted *range1* and sorted *range2* into one sorted range beginning
+   at *it*. The first version uses ``operator <`` to compare elements. The
+   second uses the comparison function *cmp*. The relative order of elements
+   is preserved. If the destination range overlaps either *range1* or *range2*,
+   the resulting behavior is undefined. (It is ok if *range1* and *range2*
+   are overlapping)
+
+   :requires: *range1* and *range2* must provide InputIterators.
+
+.. function:: void inplace_merge (Range&& range, Bidir&& it)
+              void inplace_merge (Range&& range, Bidir&& it, Compare&& cmp)
+
+   Merges two consecutive sorted ranges (``[range.begin(), it)`` and
+   ``[it, range.end())``) into one sorted range. The order of equal elements
+   is preserved. The first version uses ``operator <``. The second version uses
+   the comparison function *cmp*.
+
+   :requires: *range* must provide BidirectionalIterators
+
+.. function:: bool includes (Range1&& range1, Range2&& range2)
+              bool includes (Range1&& range1, Range2&& range2, Compare&& cmp)
+
+   Returns ``true`` if every element from *range2* is found within the bounds
+   of *range1* or if *range2* is empty. The first version uses ``operator <``.
+   The second uses *cmp* as a comparison function.
+
+   :requires: *range1* and *range2* must provide InputIterators.
+
+.. function:: decay_t<OutputIt> set_difference (\
+                Range1&& range1,\
+                Range2&& range2,\
+                OutputIt&& it\
+              )
+              decay_t<OutputIt> set_difference (\
+                Range1&& range1,\
+                Range2&& range2,\
+                OutputIt&& it,\
+                Compare&& cmp\
+              )
+
+   Copies the elements from *range1* which are not found in *range2* to the
+   range beginning at *it*. The first version uses ``operator <``. The second
+   uses *cmp* as a comparison function.
+
+   :requires: *range1* and *range2* must provide InputIterators.
+
+.. function:: decay_t<OutputIt> set_intersection (\
+                Range1&& range1,\
+                Range2&& range2,\
+                OutputIt&& it\
+              )
+              decay_t<OutputIt> set_intersection (\
+                Range1&& range1,\
+                Range2&& range2,\
+                OutputIt&& it,\
+                Compare&& cmp\
+              )
+
+   Constructs a sorted range beginning at *it* consisting of elements that are
+   found in both *range1* and *range2*. The first version expects *range1*
+   and *range2* to be sorted with ``operator <``. The second version expects
+   them to be sorted by *cmp*.
+
+   :requires: *range1* and *range2* must provide InputIterators.
+
+.. function:: decay_t<OutputIt> set_symmetric_difference (\
+                Range1&& range1,\
+                Range2&& range2,\
+                OutputIt&& it\
+              )
+              decay_t<OutputIt> set_symmetric_difference (\
+                Range1&& range1,\
+                Range2&& range2,\
+                OutputIt&& it,\
+                Compare&& cmp\
+              )
+
+   Copies the symmetric difference of *range1* and *range2* (i.e., the elements
+   found in either of the ranges but not both) to a range starting at *it*. The
+   result is also sorted. The first version expects *range1* and *range2* to be
+   sorted with ``operator <``. The second version expects them to be sorted
+   with *cmp*.
+
+   :requires: *range1* and *range2* must provide InputIterators.
+
+.. function:: decay_t<OutputIt> set_union (\
+                Range1&& range1,\
+                Range2&& range2,\
+                OutputIt&& it\
+              )
+              decay_t<OutputIt> set_union (\
+                Range1&& range1,\
+                Range2&& range2,\
+                OutputIt&& it,\
+                Compare&& cmp\
+              )
+
+   Constructs a sorted range starting at *it* consisting of all elements
+   present in one or both *range1* and *range2*. The resulting range cannot
+   overlap with either *range1* or *range2*. The first version expects both
+   ranges to be sorted with ``operator <``. The second version expects them
+   to be sorted via *cmp*.
+
+   :requires: *range1* and *range2* must provide InputIterators.
+
+.. _core-algorithm-component-heap-operations:
+
+Heap Operations
+---------------
+
+.. function:: bool is_heap (Range&& range)
+              bool is_heap (Range&& range, Compare&& compare)
+
+   Checks if the elements in *range* are a max heap. Uses ``operator <`` or
+   *cmp* as a comparison function.
+
+   :require: *range* must provide RandomAccessIterators.
+
+.. function:: RandomIt is_heap_until (Range&& range)
+              RandomIt is_heap_until (Range&& range, Compare&& compare)
+
+   Find the largest subrange within *range* which is a max heap. Uses
+   ``operator <`` or *compare* as the comparison function.
+
+   :require: *range* must provide RandomAccessIterators.
+
+.. function:: void make_heap (Range&& range)
+              void make_heap (Range&& range, Compare&& compare)
+
+   Constructs a max heap in *range*. Uses ``operator <`` or *compare*
+   as the comparison function.
+
+   :requires: *range* must provide RandomAccessIterators.
+
+.. function:: void push_heap (Range&& range)
+              void push_heap (Range&& range, Compare&& compare)
+
+   Inserts the element at ``range.end() - 1`` into the max heap defined by
+   ``[range.begin(), range.end() - 1)``. Uses ``operator <`` or *compare*
+   as the comparison function.
+
+   :requires: *range* must provide RandomAccessIterators.
+
+.. function:: void pop_heap (Range&& range)
+              void pop_heap (Range&& range, Compare&& compare)
+
+   Swaps the value at ``range.begin()`` and the value in ``range.end() - 1``
+   and turns this subrange into a max heap. Uses ``operator <`` or *compare*
+   as the comparison function.
+
+   :requires: *range* must provide RandomAccessIterators.
+
+.. function:: void sort_heap (Range&& range)
+              void sort_heap (Range&& range, Compare&& compare)
+
+   Converts a max heap (*range*) into a sorted range in ascending order.
+   The resulting range is no longer a heap. Uses ``operator <`` or *compare*
+   as the comparison function.
+
+   :requires: *range* must provide RandomAccessIterators.
+
+.. _core-algorithm-component-min-max-operations:
+
+Min/Max Operations
+------------------
+
+.. function:: ForwardIt max_element (Range&& range)
+              ForwardIt max_element (Range&& range, Compare&& compare)
+
+   Finds the greatest element in *range*. Uses ``operator <`` or *compare* as
+   the comparison function.
+
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: ForwardIt min_element (Range&& range)
+              ForwardIt min_element (Range&& range, Compare&& compare)
+
+   Finds the smallest element in *range*. Uses ``operator <`` or *compare* as
+   the comparison function.
+
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: std::pair<ForwardIt, ForwardIt> minmax_element (Range&& range)
+              std::pair<ForwardIt, ForwardIt> minmax_element (\
+                Range&& range,\
+                Compare&& compare\
+              )
+
+   Finds the greatest and smallest element in *range*. Uses ``operator <`` or
+   *compare* as the comparison function.
+
+   :requires: *range* must provide ForwardIterators.
+
+.. function:: bool lexicographical_compare (Range1&& range1, Range2&& range2)
+              bool lexicographical_compare (\
+                Range1&& range1,\
+                Range2&& range2,\
+                Compare&& compare\
+              )
+
+   Checks if *range1* is lexicographically less than *range2*. Uses
+   ``operator <`` or *compare* as the comparison function.
+
+   :requires: *range1* and *range2* must provide InputIterators.
+
+.. function:: is_permutation (Range1&& range1, Range2&& range2)
+              is_permutation (\
+                Range1&& range1,\
+                Range2&& range2,\
+                BinaryPredicate&& bp\
+              )
+
+   Returns ``true`` if there exists a permutation of the elements in *range*
+   that makes it equal to *range2*. The first version uses ``operator ==``.
+   The second version uses the given binary predicate *bp*.
+
+
+   :requires: *range1* and *range2* must provide ForwardIterators.
+
+.. function:: bool next_permutation (Range&& range)
+              bool next_permutation (Range&& range, Compare&& compare)
+
+   Transforms *range* into the next permutation from the set of all
+   permutations that are lexicographically ordered. The first version
+   uses ``operator <``. The second version uses *compare*.
+
+   :returns: ``true`` if such permutation exists otherwise transforms *range*
+             into the first permutation and returns ``false``.
+   :requires: *range* must provide BidirectionalIterators.
+
+.. function:: bool prev_permutation (Range&& range)
+              bool prev_permutation (Range&& range, Compare&& compare)
+
+   Transforms *range* into the previous permutation from the set of all
+   permutations that are lexicographically ordered. The first version
+   uses ``operator <``. The second version uses *compare*.
+
+   :returns: ``true`` if such permutation exists otherwise transforms *range*
+             into the first permutation and returns ``false``.
+
+   :requires: *range* must provide BidirectionalIterators.
diff --git a/src/bsoncxx/third_party/core/docs/any.rst b/src/bsoncxx/third_party/core/docs/any.rst
new file mode 100644
index 0000000..c07b532
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/any.rst
@@ -0,0 +1,142 @@
+.. _core-any-component:
+
+Any Component
+=============
+
+.. default-domain:: cpp
+.. highlight:: cpp
+
+.. |any| replace:: :class:`any`
+
+The |any| component is currently available in Boost (and has been for
+quite some time). There is, at the time of this writing, a `draft proposal
+<http://beman.github.io/dot16/any-proposal.html>`_ for a standard any type,
+which has several API distinctions from the Boost.Any implementation, from which
+it is inspired. Instance, the proposal recommends that an any implementation
+make a small object optimization to avoid allocations for small and integral
+types. The MNMLSTC Core any implements this optimization, and attempts to
+follow the proposal as closely as possible.
+
+The any component resides in ``<core/any.hpp>``.
+
+.. note:: The |any| component does *not* implement the
+   *allocator.uses.construction* constructors defined in the any proposal. The
+   reason for this is due to:
+
+    * Several libraries do not include the constructors necessary for types
+      that define them
+    * In most cases the compiler cannot properly disambiguate which constructor
+      to use, even with the use of type traits. This was mentioned on the LLVM
+      blog, and is mentioned as part of
+      `LWG Defect 2255 <http://cplusplus.github.io/LWG/lwg-active.html#2255>`_.
+
+   Because this component was written for C++11, it was decided to omit these
+   additional allocator aware constructors.
+
+.. namespace:: core
+
+.. class:: bad_any_cast
+
+   :inherits: std::bad_cast
+
+   This is the exception thrown when :func:`any_cast` fails.
+   It inherits from ``std::bad_cast``.
+
+   .. function:: char const* what () const noexcept
+
+      Returns the string "bad any cast". At some point in the future a more
+      descriptive error may be given.
+
+.. class:: any
+
+   .. function:: any (any const&)
+                 any (any&&) noexcept
+                 any () noexcept
+
+      The default set of constructors work as one might imagine. The copy
+      constructor is not marked as noexcept as the underlying type *may*
+      throw an exception, and due to the type erasure performed, the |any| has
+      no way of enforcing this at compile time.
+
+   .. function:: any (ValueType&& value)
+
+      When constructing an |any| with a given ``ValueType``, it will perform a
+      series of compile time checks to see whether it should perform the small
+      object optimization. If the object is deemed small enough, it will not
+      allocate memory. Otherwise, a new ValueType will be allocated via
+      operator new, and constructed with the given *value*.
+
+      :type value: ValueType&&
+      :raises: Any exceptions thrown by the copy or move constructor
+               of the given ValueType.
+
+   .. function:: any& operator = (any const&)
+                 any& operator = (any&&) noexcept
+
+      Assigns the contents of the incoming |any| to ``*this``.
+
+   .. function:: any& operator = (ValueType&& value)
+
+      Assigns *value* to ``*this``. If ``*this`` already manages a contained
+      object, it will be destroyed after *value* is assigned.
+
+      .. versionadded:: 1.1
+
+         This function was unfortunately omitted from the 1.0 release.
+
+   .. function:: void any::swap (any&) noexcept
+
+      Swaps the object contained within the given |any| with the one contained
+      within ``*this``.
+
+   .. function:: std::type_info const& type () const noexcept
+
+      Returns the ``std::type_info`` for the type contained within. If the
+      |any| is empty, it will return ``typeid(void)``.
+
+   .. function:: bool empty () const noexcept
+
+      If the |any| does not contain any data (i.e. :func:`any::type` returns
+      ``typeid(void)``), it will return true.
+
+   .. function:: void clear () noexcept
+
+      :postcondition: :func:`any::empty` == true
+
+      Destroys the object contained within the |any|.
+
+
+
+.. function:: ValueType any_cast (any const& operand)
+              ValueType any_cast (any&& operand)
+              ValueType any_cast (any& operand)
+
+   :returns: ``*any_cast<add_const_t<remove_reference_t<ValueType>>(&operand)``
+             for the first :func:`any_cast` signature. For the other overloads,
+             the return type is
+             ``*any_cast<remove_reference_t<ValueType>>(&operand)``.
+
+   :raises: :class:`bad_any_cast`
+
+   Given a type *ValueType*, it will attempt to extract the value stored within
+   the given |any|. *ValueType* may be either concrete or a reference type.
+   If ``typeid(remove_reference_t<ValueType>)`` is not equal to the value
+   returned by :func:`any::type`, :class:`bad_any_cast` is thrown. Some
+   usage examples::
+
+      any x(5) // x holds an int
+      auto y = any_cast<int>(x); // cast to a value
+      any_cast<int&>(x) = 10; // cast to a reference for mutation.
+
+      x = std::string { "Woof" }; // x now holds a string.
+      auto woof = std::move(any_cast<std::string&>(x)); // move value in x
+      assert(any_cast<std::string const&>(x) == "");
+
+
+.. function:: ValueType const* any_cast (any const* operand)
+              ValueType* any_cast (any* operand)
+
+   :returns: *ValueType* if operand is not equal to ``nullptr`` and
+             ``typeid(ValueType)`` is the same as the value returned by 
+             :func:`any::type`, a pointer to the object managed by *operand*
+             is returned. Otherwise, ``nullptr``.
diff --git a/src/bsoncxx/third_party/core/docs/conf.py b/src/bsoncxx/third_party/core/docs/conf.py
new file mode 100644
index 0000000..8be97f9
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/conf.py
@@ -0,0 +1,23 @@
+import sphinx_rtd_theme as theme
+import os
+
+project = 'MNMLSTC Core'
+copyright = '2013 - 2014, MNMLSTC'
+
+version = '1.1'
+release = '1.1'
+
+highlight_language = 'cpp'
+
+html_static_path = ['static']
+html_theme_path = [theme.get_html_theme_path()]
+html_theme = 'sphinx_rtd_theme'
+
+exclude_patterns = ['_build']
+templates_path = ['_templates']
+source_suffix = '.rst'
+master_doc = 'index'
+
+extensions = ['sphinx.ext.todo']
+
+todo_include_todos = True
diff --git a/src/bsoncxx/third_party/core/docs/functional.rst b/src/bsoncxx/third_party/core/docs/functional.rst
new file mode 100644
index 0000000..3555f96
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/functional.rst
@@ -0,0 +1,98 @@
+.. _core-functional-component:
+
+Functional Component
+====================
+
+.. default-domain:: cpp
+
+The functional component contains several utilities to assist with functions.
+Among these are the implementation of the *INVOKE* pseudo-expression in code
+form, as well as an extension of this pseudo-expression with *unpack* semantics
+at both compile time and runtime.
+
+Additionally, the functional component provides a :class:`function_traits\<T>`
+object to discern at compile time the return type and arity of a function. The
+ability to discover the types of a given function's argument is also possible.
+
+The functional component can be found in the ``<core/functional.hpp>`` header.
+
+.. namespace:: core
+
+.. class:: unpack_t
+
+   A sentinel class to represent that one wishes to call :func:`invoke` with
+   unpack semantics. An instance is available under the name ``unpack``.
+
+.. class:: runpack_t
+
+   A sentinel class to represent that one wishes to call :func:`invoke` with
+   runtime unpack semantics. An instance is available under the name
+   ``runpack``.
+
+.. class:: function_traits<T>
+
+   Function traits to discern various amounts of details for a given callable
+   type *T*. The traits allow one to get the :member:`arity` of a callable,
+   as well as explore the types of various argument indices.
+
+   .. type:: return_type
+
+      The return type of a given function *T*.
+
+   .. type:: pointer
+
+      A type alias that represents the callable as a function pointer.
+
+   .. member:: static constexpr arity
+
+      :type: ``std::size_t``
+
+      Represents the number of arguments the callable *T* takes.
+
+   .. type:: argument<N>
+
+      Given a ``std::size_t`` *N*, argument will be a type alias for the type
+      located at the index in its parameter list.
+
+.. function:: auto invoke (...)
+
+   There are 5 overloads available for this function. They are the
+   implementation of the *INVOKE* pseudo-expression discussed in the C++11
+   standard. These overloads *are not* constexpr however due to C++11 not
+   marking ``std::forward`` as constexpr.
+
+.. function:: auto invoke (unpack_t, Functor&&, Unpackable&&)
+              auto invoke (unpack_t, Unpackable&&)
+
+   :requires: *Unpackable* be capable of having ``std::get<N>`` called on it,
+              and an overload for ``std::tuple_size``.
+
+   This version of :func:`invoke` uses compile time unpacking semantics. It
+   will take every member of *Unpackable* and call ``std::get<N>``.
+   ``std::tuple_size`` is used to get the number of elements in *Unpackable*.
+
+.. function:: auto invoke (runpack_t, Functor&&, Runpackable&&)
+
+   :requires: *Runpackable* be have a member function named *at*, which returns
+              ``Runpackable::value_type``, and takes a ``std::size_t`` as its
+              parameters.
+   :throws: ``std::out_of_range``
+   :noexcept: false
+
+   This version of :func:`invoke` uses runtime unpacking semantics. It will
+   take the arity of *Functor*, and then unpack *Runpackable* via its ``at``
+   member function. As an example a *Functor* with 4 arguments, and a
+   *Runpackable* of type ``std::vector<int>`` would expand to::
+
+      core::invoke(
+        std::forward<Functor>(functor),
+        std::forward<Runpackable>(runpackable).at(N)...
+      );
+
+   As the standard containers all throw ``std::out_of_range``, this function
+   should be expected to as well.
+
+   .. note:: *ALL* standard containers with an ``at`` member function can be
+      used with this, including the associative containers, such as
+      ``std::map``, and ``std::unordered_map``. *However*, the requirement that
+      the ``at`` member function take a ``std::size_t`` remains.
diff --git a/src/bsoncxx/third_party/core/docs/index.rst b/src/bsoncxx/third_party/core/docs/index.rst
new file mode 100644
index 0000000..f04ded5
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/index.rst
@@ -0,0 +1,28 @@
+Overview
+========
+
+MNMLSTC Core is a C++11 library that adds several library features that are to
+be included in C++14 and beyond. A majority of the components of MNMLSTC Core
+can also be found in Boost. However, there are distinct behaviorial differences
+that are outlined and discussed in this documentation.
+
+It is recommended that new users read the section on :ref:`using-mnmlstc-core`.
+The documentation is ordered according to the augmented library components,
+rather than by feature.
+
+.. toctree::
+   :maxdepth: 1
+
+   Using MNMLSTC Core <usage>
+   Type Traits <type-traits>
+   Functional Utilities <functional>
+   Algorithms <algorithm>
+   Iterator Utilities <iterator>
+   Optional Types <optional>
+   Numeric Algorithms <numeric>
+   Variant Type <variant>
+   Uncategorized Utilities <utility>
+   Memory <memory>
+   String Utilities <string>
+   Range Type <range>
+   Any Type <any>
diff --git a/src/bsoncxx/third_party/core/docs/iterator.rst b/src/bsoncxx/third_party/core/docs/iterator.rst
new file mode 100644
index 0000000..2fb042d
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/iterator.rst
@@ -0,0 +1,77 @@
+.. _core-iterator-component:
+
+Iterator Component
+==================
+
+.. default-domain:: cpp
+
+The iterator component provides the additional functions provided in C++14 with
+respect to iterators. Specifically the free form functions that work like
+``std::begin`` and ``std::end``.
+
+The iterator component can be found in ``<core/iterator.hpp>``.
+
+.. namespace:: core
+
+.. function:: constexpr auto size (Container const& container) noexcept
+
+   :returns: ``container.size()`` or ``N`` if *container* is an array.
+
+.. function:: constexpr auto empty (Container const& container) noexcept
+
+   :returns: ``container.empty()`` or ``false`` if *container* is an array.
+
+.. function:: constexpr auto front (Container const& container)
+              constexpr auto front (Container& container)
+
+   :returns: ``container.front()`` or ``container[0]`` if *container* is an
+             array.
+
+.. function:: constexpr auto back (Container const& container)
+              constexpr auto back (Container&)
+
+   :returns: ``container.back()`` or ``container[N - 1]`` if *container* is
+             an array.
+
+.. function:: constexpr auto data (Container const& container) noexcept
+              constexpr auto data (Container& container) noexcept
+
+   :returns: ``container.data()`` or ``container`` if *container* is an array.
+
+.. function:: cbegin (Container const& container)
+
+   :returns: ``std::begin(container)``
+
+.. function:: cend (Container const& container)
+
+   :returns: ``std::end(container)``
+
+.. function:: rbegin (Container const& container)
+              rbegin (Container& container)
+
+   Requires that the given *container* have a member function named ``rbegin``.
+   If no such member function exists, the function will fail to compile.
+
+   :returns: ``container.rbegin()``
+
+.. function:: crbegin (Container const& container)
+
+   :returns: ``rbegin(container)``
+
+.. function:: rend (Container const& container)
+              rend (Container& container)
+
+   Requires that the given *container* have a member function named ``rend``.
+   If no such member function exists, the function will fail to compile.
+
+   :returns: ``container.rend()``
+
+.. function:: crend (Container const& container)
+
+   :returns: ``rend(container)``
+
+.. class:: infix_ostream_iterator<T>
+
+   The :class:`infix_ostream_iterator\<T>` is used as a replacement for
+   ``std::ostream_iterator``, where the delimiter is not desired for the last
+   element. This iterator comes in use when one might wish to print a list.
diff --git a/src/bsoncxx/third_party/core/docs/memory.rst b/src/bsoncxx/third_party/core/docs/memory.rst
new file mode 100644
index 0000000..4172d71
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/memory.rst
@@ -0,0 +1,635 @@
+.. _core-memory-component:
+
+Memory Component
+================
+
+.. default-domain:: cpp
+
+This section discusses the memory component of MNMLSTC Core. Contained in this
+component are three new smart pointers (two with deep copy semantics) and a
+C++11 equivalent to C++14's :func:`make_unique\<T>`.
+
+.. |observer_ptr| replace:: :class:`observer_ptr <observer_ptr\<T>>`
+.. |poly_ptr| replace:: :class:`poly_ptr <poly_ptr\<T, Deleter>>`
+.. |deep_ptr| replace:: :class:`deep_ptr <deep_ptr\<T, Deleter, Copier>>`
+
+.. namespace:: core
+
+Polymorphic Smart Pointer
+-------------------------
+
+.. class:: poly_ptr<T, Deleter>
+
+   The |poly_ptr| is a smart pointer for polymorphic types that
+   retains sole ownership of the *polymorphic* type ``T`` and performs *deep
+   copies* on assignment or copy construction.  This use is extremely close to
+   the :class:`any`, however it affords the user the ability to ascertain what
+   possible types the |poly_ptr| has while also allowing custom allocation,
+   copying, and deallocation.  In this way, a |poly_ptr| can be seen as a
+   ``std::unique_ptr`` with deep-copy semantics, and type erasure. |poly_ptr|
+   has an interface equivalent to ``std::unique_ptr``. Due to the type erasure
+   that is used, the size of a |poly_ptr| is
+   ``sizeof(std::unique_ptr<T, Deleter> + sizeof(function-ptr)``.
+
+   .. note:: Due to the lack of polymorphic allocators in C++, custom memory
+      allocation is currently relegated to performing allocation within a
+      user-supplied copier function. Because the copier function is a function
+      pointer this means that |poly_ptr| is restricted to stateless lambdas
+      or function pointers.
+
+   The |poly_ptr| requires that RTTI and exceptions be enabled. Because of
+   the type-erasure used, RTTI is absolutely required to for the polymorphic
+   deep-copy to take place.
+
+   .. warning:: *Only* a polymorphic type (that is, any type where the
+      ``std::is_polymorphic`` type trait is true) may be used with |poly_ptr|.
+      If deep-copy semantics with a ``std::unique_ptr`` are desired for a
+      non-polymorphic type, use |deep_ptr| instead.
+
+   The |poly_ptr| is *not* polymorphic itself and is marked ``final`` to
+   prevent user inheritance.
+
+   .. type:: unique_type
+
+      Represents the ``std::unique_ptr`` used internally to hold the managed
+      object.
+
+   .. type:: element_type
+
+      A type equivalent to the expression
+      ``typename unique_type::element_type``
+
+   .. type:: deleter_type
+
+      A type equivalent to the expression
+      ``typename unique_type::deleter_type``
+
+   .. type:: copier_type
+
+      A type used to represent the copy function used to perform deep copies.
+      It has the type signature of: ``unique_type (*)(unique_type const&)``.
+
+   .. type:: pointer
+
+      A type equivalent to the expression ``typename unique_type::pointer``.
+
+   .. function:: explicit poly_ptr(U* ptr)
+
+      Takes a derived pointer to a given type *U*. *U* must be a non-abstract
+      type and have :type:`element_type` as a base class within its inheritance
+      tree.
+
+   .. function:: poly_ptr (U*, E&&, copier_type=default_poly_copy)
+
+      Takes some derived type *U*, a universal reference *E*, and an optional
+      copier function pointer. The universal reference *E* is forwarded to the
+      internal std::unique_ptr, where it will handle the proper rules required
+      to initialize the deleter_type.
+
+   .. function:: explicit poly_ptr (std::unique_ptr<U, E>&&, copier_type)
+
+      A unique_ptr of type *U* and deleter *E*, with an optional copier_type
+      parameter that is by default :func:`default_poly_copy\<T, D, U>`. As
+      normal, *U* must have :type:`element_type` in its hierarchy.
+
+   .. function:: poly_ptr (poly_ptr const& that)
+
+      Performs a deep copy with the object managed by ``that``, if any such
+      object exists.
+
+   .. function:: poly_ptr (polymorphic&& that)
+
+      Moves ``that``'s pointer and copier into ``*this``, and then sets
+      ``that``'s copier to :func:`null_poly_copy\<T, D>`.
+
+   .. function:: poly_ptr () noexcept
+
+      The default constructor for a |poly_ptr| will place it into such a state
+      that bool(|poly_ptr|) will return false;
+
+   .. function:: operator = (std::unique_ptr<U, D>&& ptr)
+
+      Calls ``poly_ptr<T, Deleter> { std::move(ptr) }.swap(*this)``
+
+      :returns: ``*this``
+
+   .. function:: operator = (poly_ptr<T, Deleter>&& that) noexcept
+
+      Calls ``poly_ptr<T, Deleter> { std::move(that) }.swap(*this)``
+
+      :returns: ``*this``
+
+   .. function:: operator = (poly_ptr<T, Deleter> const& that)
+
+      Performs a deep copy with the object managed by ``that``, if such
+      an object exists.
+
+      :returns: ``*this``
+
+   .. function:: operator bool () const noexcept
+
+      .. note:: This cast operator is marked as explicit.
+
+      :returns: Whether ``*this`` owns an object
+
+   .. function:: element_type& operator * () const
+
+      :returns: an lvalue reference to the object owned by ``*this``.
+
+   .. function:: pointer operator -> () const noexcept
+
+      :returns: a pointer to the object owned by ``*this``
+
+   .. function:: pointer get () const noexcept
+
+      :returns: A pointer to the managed object, or ``nullptr`` if no such
+                object exists.
+
+   .. function:: deleter_type const& get_deleter () const noexcept
+                 deleter_type& get_deleter () noexcept
+
+      :returns: The deleter object used for destruction of the managed object.
+
+   .. function:: copier_type const& get_copier () const noexcept
+                 copier_type& get_copier () noexcept
+
+      :returns: The function pointer used for copying the managed object.
+
+   .. function:: pointer release () noexcept
+
+      Releases the ownership of the managed object, if any such object exists.
+      Any calls to :func:`poly_ptr\<T, Deleter>::get` will return ``nullptr``
+      after this call.
+
+      :returns: pointer to the managed object or ``nullptr`` if the |poly_ptr|
+                did not manage an object.
+
+   .. function:: void reset (pointer ptr = pointer { })
+
+      Replaces the managed object. Performs the following actions (these
+      differ from the order of operations followed by ``std::unique_ptr``).
+
+      * If the incoming pointer is ``nullptr``, the order of operations
+        follows those performed by ``std::unique_ptr``, along with the value
+        returned by :func:`poly_ptr\<T, Deleter>::get_copier` being set to a
+        null copier.
+      * If the incoming pointer is *not* ``nullptr``, and there is no
+        managed object, a :class:`bad_polymorphic_reset` exception is thrown.
+      * If the incoming pointer is *not* ``nullptr``, a ``typeid`` comparison
+        between the managed object and the incoming pointer is performed.
+        If the ``std::type_info`` returned from both is not identical,
+        a :class:`bad_polymorphic_reset` is thrown.
+        If the ``std::type_info`` is identical, the order of operations
+        follows those performed by ``std::unique_ptr``.
+
+   .. function:: void swap(poly_ptr&) noexcept
+
+      Swaps the managed object and copier function
+
+Deep Copying Smart Pointer
+--------------------------
+
+.. class:: deep_ptr<T, Deleter, Copier>
+
+   |deep_ptr| is a smart pointer for a type that retains sole ownership of the
+   pointer it manages and performs a *deep copy* on assignment or copy
+   construction. |deep_ptr| is much like ``std::unique_ptr`` with deep-copy
+   semantics. Unlike |poly_ptr|, |deep_ptr| is for concrete types where
+   polymorphism is not desired. |poly_ptr| has *some* storage overhead for
+   copying a polymorphic type, however |deep_ptr| performs the same
+   optimization as ``std::unique_ptr`` in that it is only ``sizeof(T*)``,
+   unless the given Deleter and Copier types hold state.
+
+   With the exception of the copy assignment and copy constructor, |deep_ptr|
+   has an interface identical to that of ``std::unique_ptr``, and exhibits the
+   same behavior as ``std::unique_ptr``
+
+   If the result of the :type:`copier_type` differs from :type:`pointer`, the
+   program will be malformed, and a static assertion will cause a compiler
+   error.
+
+   .. type:: element_type
+
+      The type of object managed by the |deep_ptr|.
+
+   .. type:: deleter_type
+
+      The deleter object used to destroy and deallocate the object managed by
+      the |deep_ptr|.
+
+   .. type:: copier_type
+
+      The copier object used to perform an allocation and deep copy the object
+      managed by |deep_ptr|.
+
+   .. type:: pointer
+
+      ``remove_reference_t<deleter_type>::pointer`` if the type exists,
+      otherwise, ``element_type*``.
+
+   .. function:: deep_ptr (pointer ptr, E&& deleter, C&& copier) noexcept
+
+      Actually two separate constructors, these follow the behavior of the
+      ``std::unique_ptr`` constructors that take a pointer, and deleter object.
+      The behavior extends to the type desired for the copier object as well.
+
+   .. function:: deep_ptr (std::unique_ptr<U, E>&&) noexcept
+
+      Constructs a |deep_ptr| with the contents of the unique_ptr. The given
+      type *U* must be a pointer convertible to :type:`pointer`, and *E* must
+      be a type that can construct a :type:`deleter_type`.
+
+   .. function:: explicit deep_ptr (pointer ptr) noexcept
+
+      Constructs a |deep_ptr| with the default deleter, default copier, and the
+      given pointer. The |deep_ptr| assumes ownership of *ptr*.
+
+   .. function:: deep_ptr (std::nullptr_t) noexcept
+
+      Delegates construction of the |deep_ptr| to the 
+      :ref:`default constructor <deep-ptr-default-constructor>`.
+
+   .. function:: deep_ptr (deep_ptr const& that)
+
+      Constructs a new object to be managed via *that*'s object.
+
+   .. function:: deep_ptr (deep_ptr&& that) noexcept
+
+      Constructs a |deep_ptr| with the managed object, deleter, and copier of
+      *that* via move construction.
+
+      :postcondition: *that* is empty
+
+   .. _deep-ptr-default-constructor:
+
+   .. function:: constexpr deep_ptr () noexcept
+
+      Default constructs a |deep_ptr| into an empty state.
+
+   .. function:: deep_ptr& operator = (std::unique_ptr<U, D>&& ptr) noexcept
+
+      Assigns the contents of *ptr* to ``*this``
+ 
+   .. function:: deep_ptr& operator = (deep_ptr const&) noexcept
+                 deep_ptr& operator = (deep_ptr&&) noexcept
+
+      Assigns the contents of the incoming |deep_ptr| to ``*this``
+
+   .. function:: deep_ptr& operator = (std::nullptr_t) noexcept
+
+      Resets the |deep_ptr| and the object it manages.
+
+   .. function:: operator bool () const noexcept
+
+      .. note:: This cast operator is marked as explicit
+
+      :returns: Whether the |deep_ptr| manages an object
+
+   .. function:: element_type& operator * () const
+
+      Attempting to dereference a |deep_ptr| that does not manage an object
+      will result in undefined behavior
+
+      :returns: an lvalue reference to the managed object
+
+   .. function:: pointer operator -> () const noexcept
+
+      :returns: a pointer to the managed object or ``nullptr`` if no such
+                object exists.
+
+   .. function:: pointer get () const noexcept
+
+      :returns: A pointer to the managed object, or ``nullptr`` if no such
+                object exists.
+
+   .. function:: deleter_type const& get_deleter () const noexcept
+                 deleter_type& get_deleter () noexcept
+
+      :returns: The deleter object used for destruction of the managed object.
+
+   .. function:: copier_type const& get_copier () const noexcept
+                 copier_type& get_copier () noexcept
+
+      :returns: The copier object used for copying the managed object.
+
+   .. function:: pointer release () noexcept
+
+      :postcondition: :func:`deep_ptr\<T, Deleter, Copier>::get` returns \
+                      ``nullptr``
+
+      Releases the ownership of the managed object, if any such object exists.
+
+   .. function:: void reset (pointer ptr = pointer { })
+
+      Replaces the currently managed object with *ptr*.
+
+   .. function:: void swap(deep_ptr&) noexcept
+
+      Swaps the managed object, copier object, and deleter object.
+
+
+Dumbest Smart Pointer
+---------------------
+
+.. class:: observer_ptr<T>
+
+   |observer_ptr| is "the dumbest smart pointer", in that it is only ever used
+   in the place of a raw pointer. The idea is to inform the user that the
+   |observer_ptr| does not *own* the pointer it *watches*. It can be treated
+   like a raw pointer, except that there is no need to read the documentation
+   to see if the user needs to manage a raw pointer or not. Because the
+   |observer_ptr| is a non-owning smart pointer, the need for a move
+   constructor and assignment operator is superfluous as copying a pointer
+   is just as cheap as moving one.
+
+   .. type:: element_type
+
+      The type of the object managed by |observer_ptr|.
+
+   .. type:: const_pointer
+             pointer
+
+      ``add_pointer_t<add_const_t<element_type>`` and
+      ``add_pointer_t<element_type>`` respectively.
+
+   .. type:: const_reference
+             reference
+
+      ``add_lvalue_reference<add_const_t<element_type>`` and
+      ``add_lvalue_reference<element_type>`` respectively.
+
+   .. function:: observer_ptr (std::nullptr_t ptr)
+                 observer_ptr (pointer ptr)
+                 observer_ptr (add_pointer_t<T> ptr)
+
+      Constructs the |observer_ptr| with the given pointer. If *ptr* is
+      convertible to :type:`observer_ptr\<T>::pointer`, it will construct it
+      that way (via a dynamic_cast).
+
+   .. function:: void swap (observer_ptr<T>&)
+
+      Swaps the contents of the |observer_ptr| with the other.
+
+   .. function:: operator const_pointer () const
+                 operator pointer ()
+
+      :noexcept: true
+      :explicit: Yes
+
+      Allows an |observer_ptr| to be explicitly converted to
+      :type:`observer_ptr\<T>::const_pointer` or
+      :type:`observer_ptr\<T>::pointer` respectively.
+
+   .. function:: operator bool () const
+
+      :noexcept: true
+      :explicit: Yes
+
+      Allows the |observer_ptr| to be explicitly converted to a boolean.
+
+   .. function:: reference operator * () const
+
+      :noexcept: true
+      :returns: reference to the object watched by the |observer_ptr|.
+
+   .. function:: pointer operator -> () const
+
+      :noexcept: true
+      :returns: the object watched by the |observer_ptr|
+
+   .. function:: pointer get () const
+
+      :noexcept: true
+      :returns: The object watched by the |observer_ptr|
+
+   .. function:: pointer release () noexcept
+
+      :noexcept: true
+      :returns: the object watched by the |observer_ptr|. The |observer_ptr| is
+                then set to ``nullptr``.
+
+   .. function:: void reset (pointer ptr=nullptr)
+
+      :noexcept: true
+
+      Resets the object watched by the |observer_ptr| with *ptr*.
+
+Utilities
+---------
+
+.. class:: bad_polymorphic_reset
+
+   :inherits: std::logic_error
+
+   Thrown when a :func:`poly_ptr<T, Deleter>::reset` is passed a
+   non-null pointer and the |poly_ptr| does not manage an object, or if the
+   passed in pointer differs in type from the currently managed object.
+
+.. class:: default_copy<T>
+
+   The default copy policy used by |deep_ptr| during a copy operation. There
+   are no partial specializations available. The default operation to perform
+   is to allocate a new *T* pointer with ``operator new``, and to initialize
+   this *T* with a ``T const&``.
+
+   .. type:: pointer
+
+      Represents ``T*``
+
+   .. function:: constexpr default_copy ()
+
+      Constructs the :class:`default_copy\<T>` object.
+
+   .. function:: default_copy (default_copy<U> const&) noexcept
+
+      Constructs a :class:`default_copy\<T>` from another
+      :class:`default_copy\<T>`.
+
+   .. function:: pointer operator () (pointer const ptr)
+
+      Allocates a new :type:`pointer` and initializes it with the dereferenced
+      *ptr*, to invoke the copy constructor.
+
+.. function:: std::unique_ptr<T, D> default_poly_copy<T, D, U> (\
+              std::unique_ptr<T, D> const&)
+
+   This function is used as the default copier when assigning a raw pointer or
+   unique_ptr to a |poly_ptr|. It will perform a deep copy with a call to
+   :func:`make_unique<T>`, with type *U* and dynamic_cast the stored pointer
+   of *T* into *U* as it performs the assignment. The :type:`deleter_type` of
+   the given unique_ptr will *also* be copied.
+
+   :returns: ``std::unique_ptr<T, D>`` with a managed object.
+
+.. function:: std::unique_ptr<T, D> null_poly_copy<T, D> (\
+              std::unique_ptr<T, D> const&)
+
+   This function is used within a |poly_ptr| for when it does not manage an
+   object. Given any unique_ptr, it will return an empty unique_ptr.
+
+   :returns: An empty ``std::unique_ptr<T, D>``
+
+Comparison Operators
+--------------------
+
+.. function:: bool operator == (poly_ptr const&, poly_ptr const&) noexcept
+              bool operator != (poly_ptr const&, poly_ptr const&) noexcept
+              bool operator >= (poly_ptr const&, poly_ptr const&) noexcept
+              bool operator <= (poly_ptr const&, poly_ptr const&) noexcept
+              bool operator > (poly_ptr const&, poly_ptr const&) noexcept
+              bool operator < (poly_ptr const&, poly_ptr const&) noexcept
+
+   Compares two |poly_ptr|'s via :func:`poly_ptr\<T, Deleter>::get` with
+   the given operator.
+
+.. function:: bool operator == (deep_ptr const&, deep_ptr const&) noexcept
+              bool operator != (deep_ptr const&, deep_ptr const&) noexcept
+              bool operator >= (deep_ptr const&, deep_ptr const&) noexcept
+              bool operator <= (deep_ptr const&, deep_ptr const&) noexcept
+              bool operator > (deep_ptr const&, deep_ptr const&) noexcept
+              bool operator < (deep_ptr const&, deep_ptr const&) noexcept
+
+   Compares two |deep_ptr|'s via :func:`deep_ptr\<T, Deleter>::get` with
+   the given operator.
+
+.. function:: bool operator == (poly_ptr<T, D> const&, nullptr_t) noexcept
+              bool operator != (poly_ptr<T, D> const&, nullptr_t) noexcept
+              bool operator >= (poly_ptr<T, D> const&, nullptr_t) noexcept
+              bool operator <= (poly_ptr<T, D> const&, nullptr_t) noexcept
+              bool operator >(poly_ptr<T, D> const&, nullptr_t) noexcept
+              bool operator <(poly_ptr<T, D> const&, nullptr_t) noexcept
+              bool operator == (nullptr_t, poly_ptr<T, D> const&) noexcept
+              bool operator != (nullptr_t, poly_ptr<T, D> const&) noexcept
+              bool operator >= (nullptr_t, poly_ptr<T, D> const&) noexcept
+              bool operator <= (nullptr_t, poly_ptr<T, D> const&) noexcept
+              bool operator >(nullptr_t, poly_ptr<T, D> const&) noexcept
+              bool operator <(nullptr_t, poly_ptr<T, D> const&) noexcept
+
+   :returns: the result of comparing :func:`poly_ptr\<T, Deleter>::get` and
+             ``nullptr`` with the given operator.
+
+.. function:: bool operator == (deep_ptr<T, D, C> const&, nullptr_t) noexcept
+              bool operator != (deep_ptr<T, D, C> const&, nullptr_t) noexcept
+              bool operator >= (deep_ptr<T, D, C> const&, nullptr_t) noexcept
+              bool operator <= (deep_ptr<T, D, C> const&, nullptr_t) noexcept
+              bool operator > (deep_ptr<T, D, C> const&, nullptr_t) noexcept
+              bool operator < (deep_ptr<T, D, C> const&, nullptr_t) noexcept
+              bool operator == (nullptr_t, deep_ptr<T, D, C> const&) noexcept
+              bool operator != (nullptr_t, deep_ptr<T, D, C> const&) noexcept
+              bool operator >= (nullptr_t, deep_ptr<T, D, C> const&) noexcept
+              bool operator <= (nullptr_t, deep_ptr<T, D, C> const&) noexcept
+              bool operator > (nullptr_t, deep_ptr<T, D, C> const&) noexcept
+              bool operator < (nullptr_t, deep_ptr<T, D, C> const&) noexcept
+
+   :returns: The result of comparing :func:`deep_ptr\<T, Deleter, Copier>::get`
+             and ``nullptr`` with the given operator.
+
+.. function:: bool operator == (observer_ptr const&, observer_ptr const&)
+              bool operator != (observer_ptr const&, observer_ptr const&)
+              bool operator >= (observer_ptr const&, observer_ptr const&)
+              bool operator <= (observer_ptr const&, observer_ptr const&)
+              bool operator  > (observer_ptr const&, observer_ptr const&)
+              bool operator  < (observer_ptr const&, observer_ptr const&)
+
+   :returns: The result of comparing the objects watched by |observer_ptr| via
+             the given operator.
+
+.. function:: bool operator == (observer_ptr const&, std::nullptr_t)
+              bool operator != (observer_ptr const&, std::nullptr_t)
+              bool operator == (std::nullptr_t, observer_const&)
+              bool operator != (std::nullptr_t, observer_const&)
+
+   :returns: The result of comparing the objects watched by |observer_ptr| with
+             ``nullptr`` via the given operator
+
+Make Functions
+--------------
+
+.. function:: observer_ptr<T> make_observer(W* ptr)
+              observer_ptr<T> make_observer(std::unique_ptr<W, D> const& ptr)
+              observer_ptr<T> make_observer(std::shared_ptr<W> const& ptr)
+              observer_ptr<T> make_observer(std::weak_ptr<W> const& ptr)
+              observer_ptr<T> make_observer(deep_ptr<W, C, D> const& ptr)
+              observer_ptr<T> make_observer(poly_ptr<W, D> const& ptr)
+
+   Provided to supplement the other ``make_*`` functions for smart pointers,
+   the make_observer function will create an observer from any C++11 standard
+   smart pointer, a raw pointer, or the smart pointers provided by MNMLSTC Core
+
+.. function:: poly_ptr<T, Deleter> make_poly<T>(U&& args)
+
+   Provided to supplement the ``std::make_shared<T>`` and
+   :func:`make_unique\<T>` functions. Constructs a |poly_ptr| with an
+   ``element_type`` of *T*, taking derived universal reference *U*. This
+   function internally calls :func:`make_unique\<T>` to create the
+   |poly_ptr|.
+
+.. function:: deep_ptr<T> make_deep<T>(args)
+
+   Used to supplement the :func:`make_unique\<T>`, :func:`make_poly\<T>`,
+   and `make_shared<T>` functions. Takes a variadic number of arguments to
+   construct a *T* with. This *T* is allocated via operator new (the default
+   allocation scheme) and passed to a |deep_ptr| for construction. This
+   |deep_ptr| is then returned by the function.
+
+.. function:: std::unique_ptr<T> make_unique<T>(args)
+              std::unique_ptr<T> make_unique<T>(size)
+
+   ``make_unique`` is provided to help supplement the ``std::make_shared<T>``
+   function for the ``std::unique_ptr<T>`` type. The first overload will be
+   used if the given type T is not an array. If the given type T is an array of
+   an unknown bound (that is, ``std::extent<T>::value == 0``) the second
+   overload is used. A third overload is provided to insure that the compiler
+
+   will error. This third overload is available when the given type
+   T is an array of a known bound (that is,
+   ``std::extent<T>::value != 0``).
+
+   :param args: Variadic template arguments with which to construct
+                a T
+   :type args: Args&&...
+   :returns: ``std::unique_ptr<T>``
+
+   :param size: Extent of ``std::unique_ptr<T[]>`` desired.
+   :type size: std::size_t
+   :returns: ``std::unique_ptr<T[]>``
+
+Specializations
+---------------
+
+There are specializations for |poly_ptr| and |deep_ptr| for integration with
+the C++ standard library.
+
+.. namespace:: std
+
+.. class:: hash<poly_ptr<T, Deleter>>
+
+   This specialization of :class:`hash` allows |poly_ptr| to be used as a
+   key type in associative containers.
+
+   For a given |poly_ptr| *ptr*, this specialization insures that
+   ``std::hash<poly_ptr<T, Deleter>> { }(ptr)`` is equivalent to the expression
+   ``std::hash<typename poly_ptr<T, Deleter>::pointer> { }(ptr.get())``
+
+.. class:: std::hash<deep_ptr<T, Deleter, Copier>>
+
+   This specialization of :class:`hash` allows |deep_ptr| to be used as a
+   key type in associative containers.
+
+   For a given |deep_ptr| *ptr*, this specialization insure that
+   ``std::hash<deep_ptr<T, Deleter, Copier>> { }(ptr)`` is equivalent to the
+   expression
+   ``std::hash<typename deep_ptr<T, Deleter, Copier>::pointer> { }(ptr.get())``
+
+.. function:: void swap(poly_ptr<T, D>& lhs, poly_ptr<T, D>& rhs) \
+              noexcept
+
+   A specialization of ``std::swap`` that calls
+   :func:`poly_ptr<T, Deleter>::swap`.
+
+.. function:: void swap(deep_ptr<T, D, C>& lhs, deep_ptr<T, D, C>& rhs) \
+              noexcept
+
+   A specialization of ``std::swap`` that calls
+   :func:`deep_ptr<T, Deleter, Copier>::swap`.
+
diff --git a/src/bsoncxx/third_party/core/docs/numeric.rst b/src/bsoncxx/third_party/core/docs/numeric.rst
new file mode 100644
index 0000000..16f6255
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/numeric.rst
@@ -0,0 +1,90 @@
+.. _core-numeric-component:
+
+Numeric Component
+=================
+
+.. default-domain:: cpp
+.. highlight:: cpp
+
+The numeric component is a wrapper around the C++ stdlib ``<numeric>`` header.
+The functions contained within this header take a range of values. However,
+as is common in the C++ standard library, it requires the user to provide a
+begin and end to the range of elements. Because MNMLSTC Core provides a
+:class:`range <range\<T>>` type, there is no logical reason a version of these
+functions that take a range are not provided.
+
+The numeric component resides in the ``<core/numeric.hpp>`` header.
+
+.. note:: Several functions in this component take a range as its input, and
+   an output iterator for output. These functions *do not* change the output
+   to also be a range. An iterator *must* be passed to them (This reduces the
+   number of overloads needed while also allowing the continued use of
+   ``back_insert_iterator`` and friends.
+
+.. function:: void iota (Range&& range, T&& value)
+
+   :requires: *range* must provide ForwardIterators
+
+   Fills *range* with sequentially increasing values, starting with *value*.
+   While *range* is treated as a universal reference, its lifetime should
+   extend past that of the call to :func:`iota`, in the event that *range*
+   is an rvalue reference. The *value* is simply perfectly forwarded to the
+   underlying ``std::iota`` call.
+
+.. function:: decay_t<T> accumulate (Range&& range, T&& init)
+              decay_t<T> accumulate (Range&& range, T&&, BinaryOp&& op)
+
+   Computes the sum of the given value *init* and the elements in *range*. The
+   first version uses ``operator +``, while the second version uses *op*.
+   Both *init* and *op* are perfectly forwarded. The lifetime of *range* may
+   end with the call to this function.
+
+   :requires: *range* must provide InputIterators.
+
+.. function:: decay_t<T> inner_product (Range&& range, InputIt&& it, T&& value)
+              decay_t<T> inner_product (\
+                Range&& range,\
+                InputIt&& it,\
+                T&& value,\
+                BinaryOp&& op,\
+                BinaryOp2&& op2\
+              )
+
+   Computes the inner product (that is, the sum of products of the element in
+   *range*. The first version uses ``operator *`` to compute the product of
+   element pairs and ``operator +`` to sum the products. The second version
+   uses *op* and *op2* for these tasks respectively.
+
+   :requires: *range* must provide InputIterators
+
+.. function:: decay_t<OutputIt> adjacent_difference (\
+                Range&& range,\
+                OutputIt&& it\
+              )
+              decay_t<OutputIt> adjacent_difference (\
+                Range&& range,\
+                OutputIt&& it,\
+                BinaryOp&& op\
+              )
+
+   Computes the differences between the second and the first of each adjacent
+   pair of elements in *range*, and writes them to the range beginning at
+   *it* + 1. The first version uses ``operator -``, while the second uses
+   *op*. These parameters are perfectly forwarded to the underlying call to
+   ``std::adjacent_difference``.
+
+   :requires: *range* must provide InputIterators.
+
+.. function:: decay_t<OutputIt> partial_sum (Range&& range, OutputIt&& it)
+              decay_t<OutputIt> partial_sum (\
+                Range&& range,\
+                OutputIt&& it,\
+                BinaryOp&& op\
+              )
+
+    Computes the partial sum of the slemenets in the subranges of *range*.
+    It then writes these values to the range beginning at *it*. The first
+    version uses ``operator +``, while the second uses the binary operation
+    *op*.
+
+   :requires: *range* must provide InputIterators.
diff --git a/src/bsoncxx/third_party/core/docs/optional.rst b/src/bsoncxx/third_party/core/docs/optional.rst
new file mode 100644
index 0000000..789ad79
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/optional.rst
@@ -0,0 +1,955 @@
+.. _core-optional-component:
+
+Optional Component
+==================
+
+.. default-domain:: cpp
+
+.. |optional| replace:: :class:`optional <optional\<T>>`
+.. |expected| replace:: :class:`expected <expected\<T>>`
+.. |result| replace:: :class:`result <result\<T>>`
+
+.. |expected-v| replace:: :class:`expected\<void>`
+.. |result-v| replace:: :class:`result\<void>`
+
+The optional component contains several types that store an optional value.
+Arguably the most well known is the |optional| type (for which this component
+is named). |optional| is available in Boost. However, this implementation of
+|optional| follows the revision 5 proposal (N3793_) as closely as possible.
+
+In addition to |optional|, an |expected| type is provided. This type is based
+off of a type mentioned by Andrei Alexandrescu in his 2012 talk *Systematic
+Error Handling in C++*. Instead of an optional null-state, the |expected| type
+contains either a type *T*, or an exception. It differes significantly from
+Alexandrescu's talk in that it's interface closely resembles |optional|. It
+also has the ability to *extract* the contained exception without the need
+of a try-catch block placed by the user, as well as the ability to rethrow
+the contained exception (if any such exception exists). Additionally, a
+specialization for |expected-v| exists, allowing a function that normally
+returns ``void``, (but one that may throw an exception) to return the error
+by way of |expected|.
+
+Lastly, there is a third optional type provided, named |result|. This type
+is closely related to |expected|. However, it does not contain an exception,
+but rather a ``std::error_condition``. This type was partially inspired by
+the Rust language's ``Result<T, E>``. However, the |result| type is intended
+to model non-exception, portable error conditions to check against, hence
+it holding either a instance of type *T* or a non-zero ``std::error_condition``.
+Much like |expected-v|, a |result-v| is also provided to easily allow checking
+for a non-zero ``std::error_condition`` in a function that ideally would return
+void. This type was provided to allow generic use of |result|. *Technically*,
+this type can be replaced with a ``std::error_condition``. However it removes
+the ability to mark a function as returning ``void``.
+
+The optional component resides in the ``<core/optional.hpp>`` header.
+
+.. namespace:: core
+
+.. class:: in_place_t
+
+   :class:`in_place_t` is an empty class type used to disambiguate
+   the overloads and member functions of |optional| that
+   take arguments (such as :func:`optional\<T>::emplace`) for
+   in-place construction of some value.
+
+   An object of this type is available under the name ``in_place``.
+
+.. class:: nullopt_t
+
+   nullopt_t is an empty class type used to indicate an
+   |optional| type with uninitialized state.
+
+   An object of this type is available under the name ``nullopt``.
+
+.. class:: bad_optional_access
+
+   :inherits: std::logic_error
+
+   Thrown when accessing an |optional| that is in a disengaged state.
+
+   .. note:: Accessing an |optional| in a disengaged state does not refer to
+      accessing the underlying object. Specifically it means calling |optional|
+      member functions, and not member functions of the underlying object it
+      may or may not currently manage.
+
+.. class:: bad_expected_type
+
+   :inherits: std::logic_error
+
+   Thrown when calling :func:`expected\<T>::expect`, if the expected type
+   is incorrect. Also thrown when attempting to expect or raise an exception
+   when an |expected| is in a *valid* state (that is, it does not currently
+   manage an exception)
+
+.. class:: bad_result_condition
+
+   :inherits: std::logic_error
+
+   Thrown when attempting to access the ``std::error_condition`` of a |result|
+   in a *valid* state. A |result| will **never** contain a
+   ``std::error_condition`` with a value of 0, and will only be *invalid* if
+   it actively manages a ``std::error_condition``.
+
+Optional Type
+-------------
+
+.. class:: optional<T>
+
+   The |optional| manages an *optional* value. This value may be in either an
+   initialized state, or an uninitialized state. This value is guaranteed to be
+   allocated within the |optional|. Instead of modelling a pointer, such as
+   ``std::unique_ptr<T>`` or ``std::shared_ptr<T>``, |optional| models an
+   object, even though :func:`optional\<T>::operator->` and
+   :func:`optional\<T>::operator*` are provided.
+
+   .. versionadded:: 1.1
+
+      |optional| follows the N3793_ proposal. This means |optional| is now
+      usable as a constexpr-able type. Additionally, |optional| now has the
+      other comparison operators available. These are implemented in terms of
+      ``operator ==`` and ``operator <``.
+
+   An |optional| object is *engaged* when one of the following occurs:
+
+    * The object is initialized with a value of type T
+    * The object is assigned an *engaged* |optional|.
+
+   An |optional| object is *disengaged* when one of the following occurs:
+
+    * The object is default-initialized.
+    * The object is initialized with an instance of :class:`nullopt_t`  or a
+      *disengaged* |optional|.
+    * The object is assigned with an instance of :class:`nullopt_t` or a
+      *disengaged* |optional|.
+
+
+   .. type:: value_type
+
+      Represents the underlying type stored within an |optional|.
+
+      .. warning:: An |optional|'s :type:`value_type` *may not* be:
+
+         * :class:`in_place_t`
+         * :class:`nullopt_t`
+         * ``std::nullptr_t``
+         * ``void``
+         * any type for which ``std::is_reference<T>::value`` is *true*.
+         * any type for which ``std::is_object<T>::value`` is *false*
+
+   .. function:: optional (optional const&)
+
+      Copies the contents of the incoming |optional|. If the incoming
+      |optional| is engaged, the contents of it are initialized into the
+      new |optional| object.
+
+   .. function:: optional (optional&& that)
+
+      Constructs a new |optional| by moving the state of the incoming
+      |optional|. If the incoming |optional| is engaged, its contents will be
+      moved into the new object. The effects of ``bool(that)`` remain the same.
+
+      :noexcept: ``std::is_nothrow_move_constructible<value_type>``
+
+   .. function:: constexpr optional (nullopt_tr) noexcept
+                 constexpr optional () noexcept
+
+      Constructs a new |optional| in a disengaged state.
+
+   .. function:: constexpr optional (value_type const&)
+                 constexpr optional (value_type&&)
+
+      Constructs a new |optional| into an *engaged* state with the contents of
+      the value_type.
+
+      :noexcept: ``std::is_nothrow_move_constructible<value_type>``
+
+   .. function:: explicit constexpr optional (\
+                   in_place_t,\
+                   std::initializer_list<U>,\
+                   Args\
+                 )
+                 explicit constexpr optional (in_place_t, Args)
+
+      Constructs a new |optional| into an *engaged* state by constructing a
+      :type:`value_type` in place with the variadic arguments *Args*.
+
+   .. function:: optional& operator = (optional const&)
+                 optional& operator = (optional&&)
+
+      :noexcept: ``std::is_nothrow_move_assignable<value_type>`` and
+                 ``std::is_nothrow_move_constructible<value_type>``.
+
+      Assigns the state of the incoming |optional|. This is done by
+      constructing an |optional|, and then calling :func:`swap` on it and
+      ``*this``.
+
+   .. function:: optional& operator = (T&& value)
+
+      This assignment operator is only valid if :type:`value_type` is
+      constructible *and* assignable from *value*.
+
+      If ``*this`` is *disengaged*, it will be placed into an *engaged* state
+      afterwards. If ``*this`` is already engaged, it will call the assignment
+      constructor of :type:`value_type`.
+
+   .. function:: optional& operator = (nullopt_t)
+
+      If ``*this`` is in an engaged state, it will be placed into a
+      *disengaged* state.
+
+   .. function:: constexpr value_type const* operator -> () const
+                 value_type* operator -> ()
+
+      Accessing the managed object when the |optional| is in a disengaged state
+      will result in undefined behavior.
+
+      :returns: pointer to the object managed by the |optional|
+
+   .. function:: constexpr value_type const& operator * () const
+                 value_type& operator * ()
+
+      If the |optional| does not manage an object, dereferencing the 
+      |optional| will result in undefined behavior.
+
+      :returns: An lvalue reference to the object managed by the |optional|
+
+   .. function:: constexpr explicit operator bool () const noexcept
+
+      :returns: true if the object is *engaged*, false otherwise.
+
+   .. function:: constexpr value_type value_or (U&& value) const &
+                 value_type value_or (U&& value) &&
+
+      If ``*this`` is an lvalue reference the :type`value_type` will be copy
+      constructed. If ``*this`` is an rvalue reference, the :type:`value_type`
+      is move constructed.
+
+      :returns: the object managed by |optional| or a :type:`value_type`
+                constructed from *value*.
+
+   .. function:: constexpr value_type const& value () const
+                 value_type& value ()
+
+      :raises: :class:`bad_optional_access`
+
+   .. function:: void swap (optional& that)
+
+      Swaps the contents of 'this' with the given object. The behavior that is
+      taken varies as such:
+
+       * If neither ``*this``, nor ``that`` are *engaged*, this function is a
+         no-op.
+       * If only one of either ``*this`` and ``that`` are *engaged*, the
+         contained value of the *disengaged* object is initialized by moving
+         the contained value of the *engaged* object. This is followed by the
+         destruction of the originally *engaged* object's value. The state of
+         both objects has been switched.
+       * If both ``*this`` and ``that`` are *engaged*, their contained values
+         are swapped with ``std::swap(**this, *that)``.
+
+   .. function:: void emplace (std::initializer_list<U>, args)
+                 void emplace (args)
+
+      Constructs the object managed by the |optional|. If the |optional| is
+      already engaged, it will first destruct the object it is currently
+      managing.
+
+Expected Type
+-------------
+
+.. class:: expected<T>
+
+   |expected| works much like |optional| in that it contains an optionally
+   instantiated type *T*. However, unlike |optional| it is never in a
+   *disengaged* state. Instead its managed object is either *valid* or
+   *invalid*. Like |optional| it does not model a pointer, but rather an object
+   and provides the pointer access operator overloads for convenience.
+
+   .. note:: |expected| does *not* implement the interface proposed in N4015_.
+      |expected| was originally written over a year in advance of the proposal.
+
+   An |expected| object is *valid* when one of the following occurs:
+
+    * The object is initialized with a value of type *T*
+    * The object is constructed with a *valid* |expected|
+    * The object is assigned a *valid* |expected|
+    * The object is default-initialized.
+
+   An |expected| object is *invalid* when one of the following occurs:
+
+    * The object is initialized with a ``std::exception_ptr`` or an *invalid*
+      |expected|.
+    * The object is assigned a ``std::exception_ptr`` or an *invalid*
+      |expected|.
+
+   .. versionadded:: 1.1 In addition to ``operator ==`` and ``operator <``,
+      |expected| is now comparable via the other relational operators.
+
+   .. type:: value_type
+
+      Represents the given type *T*.
+
+      .. warning:: An |expected|'s :type:`value_type` *may not* be:
+
+         * :class:`in_place_t`
+         * :class:`nullopt_t`
+         * ``std::exception_ptr``
+         * any type for which ``std::is_reference<T>::value`` is *true*.
+         * any type for which ``std::is_object<T>::value`` is *false*.
+
+   .. function:: explicit expected (std::exception_ptr) noexcept
+
+      Initializes the |expected| with the given exception_ptr. The |expected|
+      is then placed into an *invalid* state.
+
+   .. function:: expected (value_type const&)
+                 expected (value_type&&)
+
+      Initializes the |expected| with the given value. Afterwards, the
+      |expected| is in a *valid* state.
+
+   .. function:: expected (expected const&)
+                 expected (expected&&)
+
+      Initializes the |expected| base on the incoming |expected|'s valid state.
+      The state of the incoming |expected| does not change.
+
+   .. function:: expected ()
+
+      Default initializes the |expected| to be in a *valid* state. This
+      default constructs a :type:`expected\<T>::value_type` inside the
+      |expected|.
+
+   .. function:: explicit expected (in_place_t, std::initializer_list<U>, Args)
+                 explicit expected (in_place_t, Args)
+
+      Constructs a new |expected| into an *engaged* state by constructing a
+      :type:`value_type` in place with the given arguments.
+
+   .. function:: expected& operator = (expected const&)
+                 expected& operator = (expected&&)
+
+      Assigns the content of the incoming |expected| to ``*this``.
+
+   .. function:: expected& operator = (value_type const&)
+                 expected& operator = (value_type&&)
+
+      Initializes the |expected| with the assigned value. If the |expected|
+      holds an exception_ptr, it is destructed, and the
+      :type:`expected\<T>::value_type` is initialized (*not assigned*) the
+      incoming value.
+
+   .. function:: expected& operator = (std::exception_ptr)
+
+      If the |expected| is in a *valid* state, it will be placed into an
+      *invalid* state.
+
+   .. function:: void swap (expected& that)
+
+      :noexcept: ``std::is_nothrow_move_constructible<value_type`` and 
+                 ``core::is_nothrow_swappable<value_type>``.
+
+      If both |expected| are *valid*, then their values are swapped.
+      If both |expected| are *invalid*, then their exception_ptrs are swapped.
+
+      Otherwise, the *valid* and *invalid* state between both |expected| is
+      swapped and the *valid* object is moved into the *invalid* object, and
+      vice versa.
+
+   .. function:: explicit operator bool () const noexcept
+
+      :returns: Whether the |expected| is *valid* or *invalid*.
+
+   .. function:: value_type const* operator -> () const noexcept
+                 value_type* operator -> () noexcept
+
+      Accessing the managed object when the |expected| is *invalid* will
+      result in undefined behavior.
+
+      .. versionadded:: 1.1
+
+      :returns: pointer to the object managed by the |expected|
+
+   .. function:: value_type const& operator * () const noexcept
+                 value_type& operator * () noexcept
+
+      :returns: The object managed by the |expected|. Accessing this object
+                when the |expected| is *invalid* will result in undefined
+                behavior.
+
+   .. function:: value_type const& value () const
+                 value_type& value ()
+
+      :returns: The object managed by |expected|
+      :throws: The exception managed by |expected| if the |expected|
+      :noexcept: ``false``
+
+   .. function:: value_type value_or (U&& value) const &
+                 value_type value_or (U&& value) &&
+
+      :returns: The object managed by |expected| if *valid*, otherwise, *value*
+                is returned. This function will not compile if *U* is not
+                convertible to :type:`expected\<T>::value_type`.
+
+   .. function:: void emplace (std::initializer_list<U>, Args)
+                 void emplace (Args)
+
+      .. versionadded:: 1.1
+
+      Constructs the object managed by |expected|. If the |expected| is
+      already *valid*, it will first destruct the object it is currently
+      managing.
+
+   .. function:: E expect () const
+
+      :noexcept: ``false``
+
+      This function attempts to extract the given exception type *E*. If
+      |expected| is *valid*, :class:`bad_expected_type` is thrown. If
+      |expected| is *invalid*, but *E* is not the correct exception type,
+      ``std::nested_exception`` with :class:`bad_expected_type` and the actual
+      exception are thrown. Otherwise, the exception is returned by value.
+
+   .. function:: void raise () const
+
+      :noexcept: ``false``
+      :attributes: ``[[noreturn]]``.
+
+      Throws the |expected|'s managed exception if *invalid*. Otherwise, throws
+      :class:`bad_expected_type`. This function *always* throws, and will never
+      return.
+
+   .. function:: std::exception_ptr pointer () const
+
+      This function will throw if |expected| is *invalid*.
+
+      .. versionadded:: 1.1 Replaces :func:`get_ptr`.
+
+      :returns: The exception pointer managed by |expected|
+      :throws: :class:`bad_expected_type`
+      :noexcept: ``false``
+
+   .. function:: std::exception_ptr get_ptr () const
+
+      .. deprecated:: 1.1 Use :func:`pointer` as a replacement.
+
+      :returns: The exception pointer managed by |expected|
+      :throws: :class:`bad_expected_type`
+      :noexcept: ``false``
+
+Result Type
+-----------
+
+.. class:: result<T>
+
+   .. versionadded:: 1.1
+
+   |result| works much like |expected|. However, it does not manage an
+   exception, but rather a ``std::error_condition``. This is done to provide a
+   nice rounding out for functions which may want to signal an error, but not
+   require the 'output' value to be passed by reference or by pointer.
+
+   A |result| object is *valid* when one of the following occurs:
+
+    * The object is initialized with a value of type *T*.
+    * The object is constructed with a *valid* |result|.
+    * The object is assigned a *valid* |result|.
+    * The object is default initialized.
+    * The object is constructed with a ``std::error_condition`` whose value
+      is 0.
+    * The object is assigned a ``std::error_condition`` whose value is 0.
+
+   A |result| object is *invalid* when one of the following occurs:
+    * The object is initialized with a non-zero ``std::error_condition``.
+    * The object is assigned a non-zero ``std:error_condition``.
+
+   .. type:: value_type
+
+      Represents the given type *T*.
+
+      .. warning:: A |result|'s :type:`value_type` *may not* be:
+
+         * :class:`in_place_t`
+         * :class:`nullopt_t`
+         * ``std::error_condition``
+         * any type for which ``std::is_error_condition_enum<T>::value`` is
+           *true*
+         * any type for which ``std::is_reference<T>::value`` is *true*.
+         * any type for which ``std::is_object<T>::value`` is *false*.
+         * any type for which ``std::is_nothrow_destructible<T>::value`` is
+           *false*
+
+   .. function:: result (int val, ::std::error_category const& cat) noexcept
+                 result (std::error_condition const& condition) noexcept
+                 result (ErrorConditionEnum e) noexcept
+
+      Initializes the |result| to be *invalid*. The third overload may be
+      passed any value for which ``std::is_error_condition_enum`` is *true*.
+
+   .. function:: result (value_type const& value)
+                 result (value_type&& value)
+
+      Initializes |result| into a *valid* state with the given *value*. The
+      move constructor is marked ``noexcept`` *only* if
+      ``std::is_nothrow_move_constructible`` is *true* for :type:`value_type`.
+
+   .. function:: result (in_place_t p, std::initializer<U> il, Args&& args)
+                 result (in_place_t p, Args&& args)
+
+      Initializes |result| into a *valid* state by constructing a
+      :type:`value_type` in place with the given arguments. These constructors
+      only participate if :type:`value_type` is constructible with the given
+      arguments. *args* is a variadic template of arguments.
+
+   .. function:: result (result const& that)
+                 result (result&& that)
+
+      Copies or moves the state stored in *that* into |result| as well as its
+      managed value or error condition.
+
+   .. function:: result ()
+
+      Initializes |result| into a *valid* state by default constructing a
+      :type:`value_type`.
+
+   .. function:: result& operator = (result const& that)
+                 result& operator = (result&& that)
+
+      Assigns the contents and state of *that* to |result|. If the state of
+      *that* and |result| differ, the condition or object managed by |result|
+      will be destroyed and |result|'s state will then be constructed with
+      the data stored in *that*.
+
+   .. function:: result& operator = (std::error_condition const& condition)
+                 result& operator = (ErrorConditionEnum e)
+
+      Assigns the given *condition* or error condition enum value *e* to
+      |result|. If |result| is in a *valid* state, its managed object will
+      be destructed, and the incoming value assigned. If *condition* or *e*
+      would result in a default constructed :type:`value_type`, (such as
+      ``bool(condition) == false``), the managed object is still destructed
+      and |result| will then be assigned a default constructed
+      :type:`value_type`.
+
+   .. function:: result& operator = (value_type const& value)
+                 result& operator = (value_type&& value)
+                 result& operator = (U&& value)
+
+      Assigns *value* to |result|. If |result| is in a *valid* state, its
+      managed object is also assigned *value*. If it is in an *invalid* state,
+      it will then destroy the stored condition, and then place the |result|
+      into a valid state.
+
+      The third overload requires that :type:`value_type` be assignable and
+      constructible from *U*.
+
+   .. function:: void swap (result& that)
+
+      Swaps the state of *that* with |result|. If both *that* and |result|
+      are *valid*, then they swap their managed objects. If both *that* and
+      |result| are *invalid*, they swap their managed conditions.
+      If their states differ, the *invalid* instance is constructed with the
+      contents of the *valid* instance via move construction. The *valid*
+      instance is then invalidated with the previously *invalid* instance's
+      condition.
+
+      :noexcept: ``std::is_nothrow_move_constructible<value_type>`` and
+                 ``core::is_nothrow_swappable<value_type>``
+
+   .. function:: explicit operator bool () const noexcept
+
+      :returns: Whether |result| is *valid* or *invalid*.
+
+
+   .. function:: value_type const& operator * () const noexcept
+                 value_type& operator * () noexcept
+
+      Calling this function when |result| is *invalid* will result in
+      undefined behavior.
+
+      :returns: The object managed by |result|.
+
+   .. function:: value_type const* operator -> () const noexcept
+                 value_type* operator -> () noexcept
+
+      Calling this function when |result| is *invalid* will result in
+      undefined behavior.
+
+      :returns: The address of the object managed by |result|
+
+   .. function:: void emplace (std::initializer_list<T> il, Args&& args)
+                 void emplace (Args&& args)
+
+      Destroys whatever state is managed by |result| and then reinitializes
+      it to be *valid* while constructing a :type:`value_type` with the given
+      arguments. *args* is a variadic template argument.
+
+   .. function:: value_type const& value () const
+                 value_type& value ()
+
+      If |result| is *invalid*, this function will throw a ``std::system_error``
+      exception with the managed error condition.
+
+      :returns: Object managed by |result|
+      :throws: ``std::system_error``
+
+   .. function:: value_type value_or (U&& value) const&
+                 value_type value_or (U&& value) &&
+
+      If |result| is in an *invalid* state, a :type:`value_type` converted
+      from *value* is returned. Otherwise, the |result|'s managed object is
+      copied or moved into the returning value, depending on whether |result|
+      is an rvalue or const lvalue reference.
+
+      :requires: :type:`value_type` be move or copy constructible
+                 and that *U* is convertible to :type:`value_type`.
+
+      :returns: :type:`value_type`
+
+   .. function:: std::error_condition const& condition () const
+
+      If |result| is *invalid*, the condition it manages is returned. Otherwise
+      an exception is thrown.
+
+      :returns: ``std::error_condition`` managed by |result|
+      :noexcept: false
+      :throws: :class:`bad_result_condition`
+
+Functions
+---------
+
+.. function:: optional<T> make_optional<T>(T&& value)
+
+   :raises: Any exceptions thrown by the constructor of T
+
+   Creates an |optional| object from value. Effectively calls::
+
+       optional<typename std::decay<T>::type>(std::forward<T>(value));
+
+   Due to a bug in Apple Clang-503.0.40, this function is *not* marked
+   constexpr, and this causes an incompatibility with N3793_.
+
+.. function:: expected<T> make_expected (T&& value)
+              expected<T> make_expected (E&& exception)
+              expected<T> make_expected (std::exception_ptr)
+
+   .. versionadded:: 1.1 The overload version which takes exception type *E*
+
+   The first overload returns a *valid* |expected| containing a T constructed
+   with *value*. The second overload returns an *invalid* |expected| with
+   an exception_ptr to *exception*. For this version to be usable, *E* must
+   inherit from ``std::exception``. The third overload takes an exception
+   pointer and returns an *invalid* |expected| from it.
+
+.. function:: result<T> make_result (T&& value)
+              result<T> make_result (std::error_condition cnd)
+              result<T> make_result (ErrorConditionEnum e)
+
+   .. versionadded:: 1.1
+
+   The first overload returns a *valid* |result| containing a T constructed
+   with *value*. The second overload returns an *invalid* |expected| with an
+   error_condition. The last overload takes any type for which
+   ``std::is_error_condition_enum`` is *true*.
+
+
+Operators
+^^^^^^^^^
+
+.. function:: bool operator == (optional const&, optional const&) noexcept
+              bool operator == (optional const&, nullopt_t) noexcept
+              bool operator == (nullopt_t, optional const&) noexcept
+              bool operator == (optional<T> const&, T const&) noexcept
+              bool operator == (T const&, optional<T> const&) noexcept
+
+   For the first overload, if only one of the given |optional| values is
+   *engaged*, it will return false. If both |optional| values are 
+   *disengaged*, it will return true. Otherwise the |optional| values compare
+   their managed objects with ``operator ==``
+
+   The second overload returns whether or not the |optional| value is *engaged*.
+   The third overload *always* returns false.
+   The fourth and fifth overloads will check if the |optional| value is
+   *engaged*. If it is, the object managed by |optional| will be compared
+   with ``operator ==``. Otherwise it will return false.
+
+.. function:: bool operator < (optional<T> const&, optional<T> const&) noexcept
+              bool operator < (optional<T> const&, nullopt_t) noexcept
+              bool operator < (nullopt_t, optional<T> const&) noexcept
+              bool operator < (optional<T> const&, T const&) noexcept
+              bool operator < (T const&, optional<T> const&) noexcept
+
+   For the first overload, if the right |optional| is *disengaged*, it will
+   return false. If the left |optional| is *disengaged*, it will return true.
+   Otherwise, the result of ``*lhs < *rhs`` is returned.
+
+   The second overload returns true if the |optional| is *disengaged*.
+   The third overload returns true if the |optional| is *engaged*.
+   The fourth optional returns true if the |optional| is *disengaged*.
+   The fifth optional returns false if the |optional| is *disengaged*.
+   Otherwise the result ``*opt < value`` or ``value < *opt`` is returned.
+
+.. note:: The rest of the relational operators for |optional| are (mostly)
+   implemented in terms of ``operator ==`` and ``operator <``.
+
+.. function:: bool operator == (expected const&, expected const&) noexcept
+              bool operator == (expected const&, exception_ptr) noexcept
+              bool operator == (exception_ptr, expected const&) noexcept
+              bool operator == (expected const&, T const&) noexcept
+              bool operator == (T const&, expected const&) noexcept
+
+   .. versionchanged:: 1.1 The comparison of an |expected| to an exception_ptr
+      no longer compare the actual underlying exception_ptr if the |expected|
+      is *invalid*. Comparing an |expected| to a ``std::exception_ptr`` now
+      works as though one compared an |optional| to ``nullopt``.
+
+   For the first overload if only one of the |expected| values is *valid*,
+   it will return ``false``. If both |expected| values are *invalid*, it will
+   return ``true`` Otherwise, the |expected| values compare their managed
+   objects with ``operator ==``.
+
+   The second and third overload return ``true`` if the |expected| value is
+   *invalid*.
+
+   The fourth and fifth overload returns ``true`` only if the |expected| value
+   is *valid* and its managed object compares equal wth the *T* via *T*'s
+   ``operator ==``.
+
+.. function:: bool operator < (expected const&, expected const&) noexcept
+              bool operator < (expected const&, exception_ptr) noexcept
+              bool operator < (exception_ptr, expected const&) noexcept
+              bool operator < (expected const&, T const&) noexcept
+              bool operator < (T const&, expected const&) noexcept
+
+   For the first overload, if the right |expected| is *invalid*, it will
+   return ``false``. If the left |expected| is *invalid* it will return
+   ``true``. If both |expected| objects are *valid*, then their managed values
+   are compared via ``operator <``.
+
+   The second overload returns ``true`` if the |expected| is *invalid*.
+   The third overload returns ``true`` if the |expected| is *valid*.
+   The fourth overload returns ``true`` if the |expected| is *invalid*.
+   The fifth overload returns ``false`` if the |expected| is *invalid*.
+   Otherwise the result of ``*exp < value`` or ``value < *exp`` is returned.
+
+.. note:: The rest of the relational operators for |expected| are implemented
+   in terms of ``operator ==`` and ``operator <``.
+
+.. function:: bool operator == (result const&, result const&)
+              bool operator == (result const&, error_condition const&)
+              bool operator == (error_condition const&, result const&)
+              bool operator == (result const&, error_code const&)
+              bool operator == (error_code const&, result const&)
+              bool operator == (result const&, T const&)
+              bool operator == (T const&, result const&)
+
+   .. versionadded:: 1.1
+
+   For the first overload if only one of the |result| objects is *valid*,
+   it will return ``false``. If both |result| objects are *invalid*, the
+   result of comparing their ``error_condition`` is returned. Otherwise, the
+   |result| values compare via ``operator ==``.
+
+   The second, third, fourth, and fifth overload will return ``false`` if
+   the |result| object is *valid* (even if the ``std::error_condition`` or
+   ``std::error_code`` were to return ``false`` in a boolean context. This was
+   done to minimize issues with differing categories). If the |result| is
+   *invalid*, its :func:`result\<T>::condition` is compared against the
+   ``std::error_condition`` or ``std::error_code`` via ``operator ==``.
+
+   The sixth and seventh overloads will return ``false`` if |result| is
+   *invalid*. Otherwise the |result| value is compared with the given *T*
+   via ``operator ==``.
+
+.. function:: bool operator < (result const&, result const&)
+              bool operator < (result const&, error_condition const&)
+              bool operator < (error_condition const&, result const&)
+              bool operator < (result const&, T const&)
+              bool operator < (T const&, result const&)
+
+   .. versionadded:: 1.1
+
+   For the first overload, if both |result| objects are *invalid*, the
+   ``operator <`` comparison of their :func:`result\<T>::condition` are
+   returned. If both |result| objects are *valid*, the comparison of their
+   values via ``operator <`` is returned. If the |result| on the left is
+   *invalid*, but the |result| on the right is not, ``true`` is returned.
+   Otherwise ``false``.
+
+   The second overload returns ``false`` if the |result| is *valid* (even
+   if the ``std::error_condition`` would evaluate to ``false`` in a boolean
+   context. This was done to minimize issues with differing categories). If
+   the |result| is *invalid*, its :func:`result\<T>::condition` is compared
+   against the ``std::error_condition`` via ``operator <``
+
+   Conversely, the third overload returns ``true`` if the |result| is *valid*.
+   If the |result| is *invalid*, its :func:`result\<T>::condition` is compared
+   against the ``std::error_condition`` via ``operator <``.
+
+   For the fourth overload, if the |result| is *invalid*, ``false`` is returned.
+   Otherwise, the comparison of the |result| value and *T* via ``operator <``
+   is returned.
+
+   For the fifth overload, if the |result| is *invalid*, ``true`` is returned.
+   Otherwise, the comparison of the |result| value and *T* via ``operator <``
+   is returned.
+
+.. note:: The rest of the relational operators for |result| are implemented
+   in terms of ``operator ==`` and ``operator <``.
+
+Swap
+^^^^
+
+.. function:: void swap (optional&, optional&)
+              void swap (expected&, expected&)
+              void swap (result&, result&)
+
+   These swap functions are provided to allow for ADL calls to swap.
+
+Specializations
+---------------
+
+.. class:: expected<void>
+
+   |expected-v| is provided as a way to have the same semantics as |expected|,
+   but for functions that do not (or cannot) return a value. Its interface
+   is close to that of |expected|, however as it cannot store a value, it is
+   smaller and only has member functions related to handling the exception
+   stored within the |expected-v|.
+
+   .. type:: value_type
+
+      Always ``void``.
+
+   .. function:: explicit expected (std::exception_ptr) noexcept
+
+      Initializes (and invalidates) the |expected-v|.
+
+   .. function:: expected (expected const&) = default
+                 expected (expected&&) = default
+
+      Copies the exception_ptr stored within the |expected-v|. Invalidates
+      ``*this``.
+
+   .. function:: expected& operator = (expected const&) = default
+                 expected& operator = (expected&&) = default
+
+      Copies the exception_ptr stored within the |expected-v|. Invalidates
+      ``*this``.
+
+   .. function:: void swap (expected&) noexcept
+
+      Swaps the |expected-v|'s exception_ptrs.
+
+   .. function:: explicit operator bool () const noexcept
+
+      :returns: Whether the |expected-v| is *valid* or *invalid*.
+
+   .. function:: E expect<E> () const
+
+      See :func:`expected\<T>::expect\<E>`
+
+   .. function:: void raise () const
+
+      See :func:`expected\<T>::raise`
+
+   .. function:: std::exception_ptr pointer () const
+
+      Throws if |expected-v| is *valid*.
+
+      :returns: The managed exception_ptr if the |expected-v| is *invalid*.
+      :throws: :class:`bad_expected_type` if the |expected-v| is *valid*.
+      :noexcept: ``false``.
+
+   .. function:: std::exception_ptr get_ptr () const
+
+      .. deprecated:: 1.1 Use :func:`pointer` as a replacement.
+
+      :returns: The managed exception_ptr if the |expected-v| is *invalid*.
+      :throws: :class:`bad_expected_type` if the |expected-v| is *valid*.
+      :noexcept: ``false``.
+
+.. class:: result<void>
+
+   |result-v| is provided as a way to have the same semantics as |result|,
+   but for functions that do not (or cannot) return a value. Its interface
+   is close to that of |result|, however as it cannot store an object, it is
+   smaller and only has member functions related to handling error conditions.
+
+   Technically speaking, this type is unnecessary as an error_condition can be
+   supplied instead. However, it's sometimes nice to allow for more generic
+   code to be written, and worrying about whether or not you might accidentally
+   instantiate a |result-v| isn't something one should have to worry about.
+
+   The copy, move, and default constructors as well as the copy and move
+   assignment operators for |result-v| are defaulted, letting the stored
+   ``std::error_condition`` be managed instead.
+
+   .. type:: value_type
+
+      Always ``void``.
+
+   .. function:: result (int value, std::error_category const& category)
+                 result (std::error_condition cnd)
+                 result (ErrorConditionEnum e)
+
+      Constructs the |result-v| with the given value. Any type for which
+      ``std::is_error_condition_enum`` is *true* may be used as an argument in
+      the third overload.
+
+   .. function:: result& operator = (std::error_condition const& condition)
+                 result& operator = (ErrorConditionEnum e) noexcept
+
+      Assigns |result-v| with the given value. Any value for which
+      ``std::is_error_condition_enum`` is *true* may be used in the second
+      overload.
+
+   .. function:: explicit operator bool () const noexcept
+
+      :returns: Whether the |result-v| is *valid* or *invalid*.
+
+   .. function:: void swap (result& that)
+
+      Swaps the stored ``std::error_condition`` with *that*.
+
+   .. function:: std::error_condition const& condition () const
+
+      If the |result-v| is *valid*, it will throw an exception.
+      Otherwise, the ``std::error_condition`` stored will be returned.
+
+      :noexcept: false
+      :throws: :class:`bad_result_condition`
+      :returns: The stored ``std::error_condition`` if |result-v| is *invalid*.
+
+std::hash
+^^^^^^^^^
+
+.. class:: hash<optional<T>>
+
+   Specialization of ``std::hash``.
+
+   Requires that the :type:`optional\<T>::value_type` be specialized for
+   ``std::hash``. If the |optional| is engaged it will return the hash
+   value for ``hash<value_type>``. Otherwise, it will return a default
+   constructed ``std::hash<value_type>::result_type``.
+
+.. class:: hash<expected<T>>
+
+   Specialization of ``std::hash``.
+
+   Requests that the :type:`expected\<T>::value_type` be specialized for
+   ``std::hash``. If the |expected| is *valid*, it will return the hash value
+   for ``hash<value_type>``. Otherwise, it will return a default constructed
+   ``std::hash<value_type>::result_type``.
+
+.. class:: hash<result<T>>
+
+   Specialization of ``std::hash``.
+
+   Requests that the :type:`result\<T>::value_type` be specialized for
+   ``std::hash``. If the |result| is *valid*, it will return the hash value for
+   ``hash<value_type>``. Otherwise, it will return a default constructed
+   ``std::hash<value_type>::result_type``.
+
+.. _N3793: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3793.html
+.. _N4015: https://isocpp.org/files/papers/n4015.pdf
diff --git a/src/bsoncxx/third_party/core/docs/range.rst b/src/bsoncxx/third_party/core/docs/range.rst
new file mode 100644
index 0000000..d2d3d77
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/range.rst
@@ -0,0 +1,278 @@
+.. _core-range-component:
+
+Range Component
+===============
+
+.. default-domain:: cpp
+
+.. |range| replace:: :class:`range <range\<T>>`
+
+Ranges are a common concept in the C++ standard, and in the case of all the
+algorithms available, one usually has to supply a start and end to a range as
+adjacent arguments. This can be tiresome, and in the common case, unnecessary.
+
+The |range| component works as a high level view. Rather than holding onto the
+container, it simply holds the start and end iterators to represent a range.
+The |range| component implements the interface and behavior discussed within
+N3350_. Some decisions pertaining to open questions were made, and these are
+discussed below.
+
+The range component resides in the ``<core/range.hpp>``.
+
+.. namespace:: cpp
+
+.. class:: is_range<R>
+
+   Type trait for determining if a type can return a value when ``std::begin``
+   and ``std::end`` are called on it.
+
+.. class:: range<T>
+
+
+   Represents an open-ended range of [begin, end). The category of range
+   depends on the category of its :type:`iterator`. All the type aliases
+   within the |range| depend on the use of ``std::iterator_traits<T>``.
+
+   The type *T* is actually an Iterator type.
+
+   .. type:: iterator_category
+
+      Represents ``std::iterator_traits<T>::iterator_category``
+
+   .. type:: difference_type
+
+      Represents ``std::iterator_traits<T>::difference_type``
+
+   .. type:: value_type
+
+      Represents ``std::iterator_traits<T>::value_type``
+
+   .. type:: reference
+
+      Represents ``std::iterator_traits<T>::reference``
+
+   .. type:: pointer
+
+      Represents ``std::iterator_traits<T>::pointer``
+
+   .. type:: iterator
+
+      Represents *T*.
+
+   .. function:: range (std::pair<iterator, iterator> pair) noexcept
+
+      Constructs a |range| with the first and second members of the pair to be
+      the begin and end of the |range| respectively.
+
+   .. function:: range (iterator begin, iterator end) noexcept
+
+      Constructs a |range| with the given iterators.
+
+   .. function:: range (range const& that)
+
+      Constructs a |range| with a copy of the iterators stored in *that*.
+
+   .. function:: range (range&& that) noexcept
+
+      Constructs a |range| by moving the iterators stored in *that*.
+
+   .. function:: range ()
+
+      Constructs a |range| by default constructing both its begin and end
+      iterators. The resulting range will be empty.
+
+      :postcondition: ``begin() == end()``
+
+   .. function:: range& operator = (range const&)
+                 range& operator = (range&&)
+
+      Assigns the contents of the incoming |range| to ``*this``.
+
+   .. function:: reference operator[](difference_type idx) const
+
+      :requires: :type:`iterator_category` be ``random_access_iterator_tag``.
+
+   .. function:: iterator begin () const
+
+      :returns: beginning of the range
+
+   .. function:: iterator end () const
+
+      :returns: end of the range.
+
+   .. function:: reference front () const
+
+      :returns: the value returned by dereferencing :func:`begin`
+
+   .. function:: reference back () const
+
+      :requires: :type:`iterator_category` be ``bidirectional_iterator_tag``.
+      :returns: the value returned by dereferencing the iterator before
+                :func:`end`
+   .. function:: bool empty () const
+
+      :returns: :func:`begin` == :func:`end`
+
+   .. function:: difference_type size () const
+
+      Will return the number of elements between :func:`begin` and :func:`end`.
+
+      :requires: :type:`iterator_category` be ``forward_iterator_tag``
+      :returns: ``std::distance(begin(), end())``
+
+   .. function:: range slice (difference_type start, difference_type stop) const
+
+      Slicing a |range| has the most complex behavior out of all the |range|
+      member functions. This is due to the behavior mimicking the slice
+      behavior exhibited by the python language's slicing syntax.
+
+      If *start* is negative, the begin marker is :func:`end` - *start*.
+      If *stop* is negative, the end marker is :func:`end` - *stop*.
+      If *start* is positive, the begin marker is :func:`begin` + *start*.
+      If *stop* is positive, the end marker is :func:`begin` + *stop*.
+
+      If *start* and *stop* are positive, and *stop* is less than or equal to
+      *start*, an empty |range| is returned.
+
+      If *start* and *stop* are negative and *stop* is less than or equal to
+      *start*, an empty |range| is returned.
+
+      If *start* is positive and *stop* is negative and ``abs(stop)`` + *start*
+      is greater or equal to :func:`size`, an empty |range| is returned.
+
+      If *start* is negative and *stop* is positive and :func:`size` + *start*
+      is greater or equal to *stop*, an empty range is returned.
+
+      These first two conditions can be computed cheaply, while the third and
+      fourth are a tad more expensive. However they *are* required in all
+      computations, no matter the :type:`iterator_category`. :func:`slice` does
+      not compute :func:`size` until after checking the first two conditions.
+
+      Some optimizations are taken to insure that finding the begin and end
+      iterators is at most an O(N) operation, rather than O(2N), as it *could*
+      be in some cases.
+
+      :requires: :type:`iterator_category` be ``forward_iterator_tag``.
+
+   .. function:: range slice (difference_type start) const
+
+      :requires: :type:`iterator_category` be ``forward_iterator_tag``.
+      :returns: An open ended range of [:func:`begin` + *start*, :func:`end`).
+
+   .. function:: std::pair<range, range> split (difference_type idx) const
+
+      :requires: :type:`iterator_category` be ``forward_iterator_tag``.
+
+   .. function:: void pop_front (difference_type n)
+                 void pop_front ()
+
+      Moves the start of the range 'forward' by *n*, via ``std::advance``. The
+      overload which takes no arguments moves the range forward by 1.
+
+   .. function:: void pop_back (difference_type n)
+                 void pop_back ()
+
+      :requires: :type:`iterator_category` be ``bidirectional_iterator_tag``.
+
+   .. function:: void pop_front_upto (difference_type n)
+
+      Moves the start of the range by *n* elements. A negative argument causes
+      no change.
+
+   .. function:: void pop_back_upto (difference_type n)
+
+      Moves the end of the range backwards by *n* elements. A negative argument
+      causes no change.
+
+      :requires: :type:`iterator_category` be ``bidirectional_iterator_tag``.
+
+   .. function:: void swap (range& that) noexcept
+
+      Swaps the begin and end of ``*this``, with *that*.
+
+.. function:: range<T> make_range (T begin, T end)
+
+   Creates a |range| from the iterators *begin* and *end*.
+
+.. function:: range<T> make_range(Range&&)
+
+   Constructs a |range| from the given type by calling ``std::begin`` and
+   ``std::end``.
+
+.. function:: range<std::istream_iterator<T, CharT, Traits>> make_range \
+              (std::basic_istream<CharT, Traits>& stream)
+
+   Constructs a |range| for iterating an istream. An example of usage is::
+
+      auto istream_range = make_range<double>(stream);
+
+.. function:: range<std::istreambuf_iterator<CharT, Traits>> make_range \
+              (std::basic_streambuf<CharT, Traits>* buffer)
+
+   Constructs a |range| for iterating a streambuf. An example of usage is::
+
+      auto streambuf_range = make_range(stream.rdbuf());
+
+Specialization
+--------------
+
+.. namespace:: std
+
+.. function:: void swap (range<Iterator>& lhs, range<Iterator>& rhs)
+
+   :noexcept: ``lhs.swap(rhs)``
+
+Answers to Open Questions
+-------------------------
+
+There are several questions raised in N3350_. The decisions related to
+these are discussed below.
+
+make_range
+^^^^^^^^^^
+
+The author of N3350_ mentions that they would like to be able to pass a single
+argument to a :func:`make_range` that is just the beginning of a range, where
+the end of the range is a default constructed iterator. This would make it
+helpful with iterators such as ``istream_iterator``. The author is concerned
+that this will make the use of :func:`make_range` potentially confusing.
+
+It was decided that the author's concerns are valid, however the ability to
+create an ``istream_iterator`` range (and ``istreambuf_iterator`` range) is
+a desirable feature. An overload for make_range is provided to take an
+``istream`` and ``istreambuf`` to create a proper range.
+
+Inherit from std::pair<Iterator, Iterator>
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+The author of N3350_ mentions inheriting from ``std::pair<Iterator, Iterator>``.
+Rather than rely on inheritance to represent a range, it was decided to allow a
+|range| to be constructed implicitly with a std::pair.
+
+Remove member functions and replace as free algorithms
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+The author of N3350_ mentions that it might be worth placing some member
+functions such as ``pop_*`` and :func:`range\<T>::slice` as non member
+functions, at the cost of some Iterator copying.
+
+It was decided that this was unnecessary, and the member functions will stay.
+
+Range Category
+^^^^^^^^^^^^^^
+
+The author of N3350_ proposes defining range categories.
+
+It was decided that these add nothing of use.
+
+Split takes arbitrary number of indices
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+The author of N3350_ mentions taking an arbitrary number o indices and
+returning an N + 1 element ``tuple<>``. The author mentions that this would be
+tricky with negative indices and bidirectional iterators.
+
+It was decided that this is an unnecessary complication of the range
+component's internals.
+
+.. _N3350: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3350.html
diff --git a/src/bsoncxx/third_party/core/docs/string.rst b/src/bsoncxx/third_party/core/docs/string.rst
new file mode 100644
index 0000000..90717ca
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/string.rst
@@ -0,0 +1,313 @@
+.. _core-string-component:
+
+String Component
+================
+
+.. default-domain:: cpp
+
+.. |string_view| replace:: :class:`string_view <basic_string_view\<T>>`
+.. |npos| replace:: :member:`npos <basic_string_view\<T>::npos>`
+
+The string component contains types related to strings, and utilities for
+strings. Specifically, the |string_view| class resides in the
+string component.
+
+The string component resides in the ``<core/string.hpp>`` header.
+
+.. namespace:: core
+
+.. class:: basic_string_view<T>
+
+   The |string_view| type has been recreated in many different projects over the
+   years, especially where work on immutable strings is desired. A |string_view|
+   provides an interface equivalent to a ``std::string const``, and any
+   ``std::string`` or ``char const*`` is implicitly convertible to a
+   |string_view|. A |string_view| is ONLY valid as long as the data it *views* is
+   valid.
+
+   .. warning:: Attempting to access a |string_view| after the data it is
+      viewing has been destructed will result in undefined behavior.
+
+   .. type:: difference_type
+
+      An alias of ``std::ptrdiff_t``
+
+   .. type:: value_type
+
+      An alias of ``T``
+
+   .. type:: size_type
+
+      An alias of ``std::size_t``
+
+   .. type:: const_reference
+             reference
+
+      ``value_type const&``
+
+   .. type:: const_pointer
+             pointer
+
+      ``value_type const*``
+
+   .. type:: const_iterator
+             iterator
+
+      :type:`pointer`
+
+   .. type:: const_reverse_iterator
+             reverse_iterator
+
+      ``std::reverse_iterator<const_iterator>``
+
+   .. member:: static constexpr npos
+
+      :type: :type:`size_type`
+
+      equal to ``std::numeric_limits<size_type>::max()``
+
+   .. function:: basic_string_view (std::string const& str)
+
+      Constructs the object such that it views the entire contents of the given
+      string.
+
+      :postcondition: :func:`size` == *str*.size()
+
+   .. function:: constexpr basic_string_view (pointer str, size_type len)
+
+      Constructs the object such that it views the given string and has a
+      maximum length of the given length.
+
+      :postcondition: :func:`size` == *len*
+
+   .. function:: basic_string_view (pointer str)
+
+      Constructs the object such that it views the given string, and has a
+      length of the entire null terminated string.
+
+   .. function:: basic_string_view (basic_string_view const&)
+
+      Copies the object given, such that they are equivalent in every
+      way.
+
+      .. note:: Because copying a |string_view| is cheap, no move constructor is
+         defined.
+
+   .. function:: constexpr basic_string_view ()
+
+      Constructs the object to be empty.
+
+      :postcondition: :func:`empty` == true
+
+   .. function:: operator std::basic_string<T> () const
+
+      Marked as *explicit*. Creates a new ``std::basic_string`` from the
+      |string_view|.
+
+   .. function:: constexpr const_iterator cbegin () const noexcept
+                 constexpr const_iterator begin () const noexcept
+
+      :returns: Iterator to the beginning of the |string_view|.
+
+   .. function:: constexpr const_iterator cend () const noexcept
+                 constexpr const_iterator end () const noexcept
+
+      :returns: Iterator to the end of the |string_view|.
+
+   .. function:: const_reverse_iterator crbegin() const noexcept
+                 const_reverse_iterator rbegin () const noexcept
+
+      :returns: reverse iterator to the beginning of the |string_view|
+
+   .. function:: const_reverse_iterator crend () const noexcept
+                 const_reverse_iterator rend () const noexcept
+
+      :returns: reverse iterator to the beginning of the |string_view|
+
+   .. function:: constexpr size_type max_size () const noexcept
+
+      :returns: :func:`size`
+
+   .. function:: constexpr size_type length () const noexcept
+                 constexpr size_type size () const noexcept
+
+      :returns: Length of the object in terms of ``sizeof(T) * N``
+
+   .. function:: constexpr bool empty () const noexcept
+
+      :returns: Whether the object is a 'null view'
+
+   .. function:: constexpr reference operator [] (size_type idx) const
+
+      :returns: reference to the :type:`value_type` located at *idx*.
+
+   .. function:: constexpr reference front () const
+
+      :returns: reference to the :type:`value_type` located at the index 0.
+
+   .. function:: constexpr reference back () const
+
+      :returns: reference to the :type:`value_type` located at the end of the
+                |string_view|.
+
+   .. function:: constexpr pointer data () const
+
+      :returns: :type:`pointer` to the data viewed by the |string_view|.
+                This pointer is not guaranteed to be null terminated, and
+                should be treated as such.
+
+   .. function:: void remove_prefix (size_type n)
+
+      Moves the front of the |string_view| forward *n* characters or
+      :func:`size` if *n* is greater than :func:`size`.
+
+   .. function:: void remove_suffix (size_type n)
+
+      Moves the end of the |string_view| backwards *n* characters or
+      :func:`size` if *n* is greater than :func:`size`.
+
+   .. function:: void clear () noexcept
+
+      Sets the |string_view| to be empty.
+
+      :postconditions: :func:`empty` == true
+
+   .. function:: constexpr basic_string_view substr \
+                 (size_type pos, size_type n=npos) const
+
+      :returns: a new |string_view| with starting point *pos* and a length of
+                *n* characters. If *n* is equal to |npos|, or 
+                *pos* + *n* is greater than :func:`size`, the length will be
+                the remainder of the string. Otherwise it will be *n*
+                characters.
+      :throws: ``std::out_of_range`` if *pos* is greater than :func:`size`
+
+   .. function:: bool starts_with (basic_string_view value) const noexcept
+                 bool starts_with (value_type value) const noexcept
+
+      :returns: Whether the |string_view| starts with the given *value*.
+
+   .. function:: bool ends_with (basic_string_view value) const noexcept
+                 bool ends_with (value_type value) const noexcept
+
+      :returns: Whether the |string_view| ends with the given *value*.
+
+   .. function:: difference_type compare (basic_string_view that) const
+
+      Compares two |string_view|'s. First calculates the number of characters
+      to compare, then compares via a character by character lexicographical
+      comparison. If the result is 0, then their sizes are compared and the
+      return value is affected by their length.
+
+      :returns: negative value if this |string_view| is less than the other,
+                zero if the both |string_view|'s are equal,
+                positive value if this |string_view| is greater than the other.
+
+   .. function:: reference at (size_type idx) const
+
+      :returns: :type:`value_type` located at *idx*.
+      :throws: ``std::out_of_range`` if *idx* is greater than or equal to
+               :func:`size`.
+
+   .. function:: size_type find_first_not_of (basic_string_view) const
+                 size_type find_first_not_of (value_type) const
+
+      Finds the first character equal to none of the characters in the given
+      character sequence. 
+
+      :returns: index of the first character not in the given sequence, or
+                |npos| if no such character is found.
+
+   .. function:: size_type find_last_not_of (basic_string_view) const
+                 size_type find_last_not_of (value_type) const
+
+      Finds the last character equal to none of the characters in the given
+      character sequence.
+
+      :returns: index of the last character not in the given sequence, or
+                |npos| if no such character is found.
+
+   .. function:: size_type find_first_of (basic_string_view) const
+                 size_type find_first_of (value_type) const
+
+      Finds the first character equal to one of characters in the given
+      character sequence.
+
+      :returns: Index of the first character found, or |npos| if no such 
+                character is found.
+
+   .. function:: size_type find_last_of (basic_string_view) const
+                 size_type find_last_of (value_type) const
+
+      Finds the last character equal to one of characters in the given
+      character sequence.
+
+      :returns: Index of the last character found, or |npos| is no such
+                character is found.
+
+   .. function:: size_type rfind (basic_string_view) const
+                 size_type rfind (value_type) const
+
+      Finds the last substring equal to the given character sequence.
+
+      :returns: index of the desired substring, or |npos| if no such substring
+                was found.
+
+   .. function:: size_type find (basic_string_view) const
+                 size_type find (value_type) const
+
+      Finds the first substring equal to the given character sequence.
+
+      :returns: index of the desired substring, or |npos| if no such substring
+                was found.
+
+   .. function:: void swap (basic_string_view& that) noexcept
+
+      Swaps the contents of the |string_view| with *that*.
+
+.. function:: bool operator == (basic_string_view, basic_string_view)
+              bool operator != (basic_string_view, basic_string_view)
+              bool operator >= (basic_string_view, basic_string_view)
+              bool operator <= (basic_string_view, basic_string_view)
+              bool operator > (basic_string_view, basic_string_view)
+              bool operator < (basic_string_view, basic_string_view)
+
+   :returns: Whether the given |string_view|'s meet the requirements for the
+             given operator. Follows the same semantics as the ``std::string``
+             comparison operators.
+
+.. function:: std::basic_ostream<T>& operator << \
+              (std::basic_ostream<T>& os, basic_string_view<T> const& str)
+
+   Overload to print a |string_view| directly to the given stream *os*.
+
+.. type:: string_view
+
+   A type alias for |string_view| where ``T`` is ``char``.
+
+.. type:: wstring_view
+
+   A type alias for |string_view| where ``T`` is ``wchar_t``.
+
+.. type:: u16string_view
+
+   A type alias for |string_view| where ``T`` is ``char16_t``.
+
+.. type:: u32string_view
+
+   A type alias for |string_view| where ``T`` is ``char32_t``.
+
+Specializations
+---------------
+
+.. namespace:: std
+
+Several specializations for standard code are provided
+
+.. function:: void swap(basic_string_view&, basic_string_view&)
+
+   Calls :func:`basic_string_view\<T>::swap`
+
+.. class:: hash<basic_string_view<T>>
+
+   Specialization hash for |string_view|.
diff --git a/src/bsoncxx/third_party/core/docs/type-traits.rst b/src/bsoncxx/third_party/core/docs/type-traits.rst
new file mode 100644
index 0000000..44e843d
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/type-traits.rst
@@ -0,0 +1,101 @@
+.. _core-type-traits-component:
+
+Type Traits Component
+=====================
+
+.. default-domain:: cpp
+
+.. |is_nothrow_swappable| replace::
+   :type:`is_nothrow_swappable <is_nothrow_swappable\<T>>`
+
+.. |is_swappable| replace:: :type:`is_swappable <is_swappable\<T>>`
+
+The type traits component contains many utilities that are available in C++14,
+as well as a few custom types. Such as, |is_nothrow_swappable| and
+|is_swappable|. *Most* of the types provided within this component are
+in fact simple type aliases defined for C++14. e.g.,
+``typename std::decay<T>::type`` is aliased to ``core::decay_t<T>``. All types
+that are used as type *modifiers* (rather than type *properties*) have the
+equivalent alias available.
+
+Only type traits not provided by the C++11 standard are documented. If a
+type trait provided by MNMLSTC Core differs from the standard in any way, it is
+also documented here.
+
+The type traits component can be found in the ``<core/type_traits.hpp>`` header.
+
+.. type:: is_null_pointer<T>
+
+   An alias for ``std::true_type`` if *T* is any form of the type
+   ``std::nullptr_t``. This includes its *const* and *volatile* qualified
+   counterparts.
+
+.. type:: is_unpackable<T>
+
+   Given a type *T*, checks if the type may be used with :class:`unpack_t` and
+   :func:`invoke`.
+
+.. type:: is_runpackable<T>
+
+   Given a type *T*, checks if the type may be used with :class:`runpack_t` and
+   :func:`invoke`.
+
+.. type:: class_of<T>
+
+   Given a member function pointer type *T*, it extracts the underlying
+   class type. For example, a type ``void A::*()`` will given the type *A* as
+   its ``type`` member.
+
+.. type:: invokable<Args>
+
+   Given a typelist *Args*, checks if the first type in *Args* may be invoked
+   with the rest of the arguments in *Args*. The rule for deciding if *Args*
+   follows the *INVOKE* pseudo expression.
+
+.. type:: invoke_of<Args>
+
+   Given a typelist *Args*, the member typedef ``type`` will represent the
+   return type if *Args* is invoked according to the *INVOKE* pseudo-expression.
+
+.. type:: result_of<T>
+
+   This is an SFINAE capable version of result_of. It relies on
+   :type:`invoke_of\<Args>` to work correctly.
+
+.. type:: common_type<Ts>
+
+   A more compiler agnostic version of ``std::common_type<Ts>``. This was
+   implemented to workaround an issue with Clang's ``std::common_type``
+   attempting to discover the common type of two ``void&&``.
+
+.. type:: is_swappable<T>
+
+   Unfortunately, this type is not as strong as one would like to believe. It
+   always returns true for a given type, even if an expression is malformed.
+   (For instance, given a type *T const*, it will return true). The only way
+   to fix this would be to place an ``enable_if`` on std::swap. And that's
+   not happening.
+
+.. type:: is_nothrow_swappable<T>
+
+   Unlike |is_swappable|, |is_nothrow_swappable| is actually quite strong.
+   It will be ``std::true_type`` if a given swap call on a type is actually
+   marked as *noexcept*, and ``std::false_type`` otherwise. This type
+   is comparable to libc++'s internal ``__is_nothrow_swappable``.
+
+.. type:: all_traits<Args>
+
+   Given a typelist *Args*, where each type in *Args* is a type trait property
+   that contains a boolean member value, it will ether be equivalent to
+   ``std::true_type`` if *all* of the traits ``value`` members are true.
+   Otherwise, it will be equivalent to ``std::false_type``
+
+.. type:: any_traits<Args>
+
+   Works much like :type:`all_traits\<Args>`, however only *one* of the given
+   traits in *Args* must be true.
+
+.. type:: no_traits<Args>
+
+   The inverse of :type:`all_traits\<Args>`. Will only be true if every
+   trait in *Args* is false.
diff --git a/src/bsoncxx/third_party/core/docs/usage.rst b/src/bsoncxx/third_party/core/docs/usage.rst
new file mode 100644
index 0000000..6f14bad
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/usage.rst
@@ -0,0 +1,24 @@
+.. _using-mnmlstc-core:
+
+Using MNMLSTC Core
+==================
+
+This section of the documentation goes ito detail on how to use the MNMLSTC
+Core library. Specifically, it discusses how the library is laid out, and how
+features will be added and or deprecated.
+
+Library Layout
+--------------
+
+MNMLSTC Core follows the same header layout as the C++ standard library. Each
+library component is located in its own header. For instance, the
+:ref:`memory component <core-memory-component>` is located in
+``<core/memory.hpp>``, and the
+:ref:`optional component <core-optional-component>` is located in
+``<core/optional.hpp>``.
+
+Feature Addition and Deprecation
+--------------------------------
+
+MNMLSTC Core follows `Semantic Versioning 2.0
+<http://semver.org/spec/v2.0.0.html>`_.
diff --git a/src/bsoncxx/third_party/core/docs/utility.rst b/src/bsoncxx/third_party/core/docs/utility.rst
new file mode 100644
index 0000000..deef39b
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/utility.rst
@@ -0,0 +1,77 @@
+.. _core-utility-component:
+
+Utility Component
+=================
+
+.. default-domain:: cpp
+
+The utility component provides additional functions and meta templates that
+cannot be categorized. Most of the utilities provided are for working with
+type lists.
+
+The utility component can be found in the ``<core/utility.hpp>`` header.
+
+.. namespace:: core
+
+.. class:: integer_sequence<T, Is>
+
+   meta template to generate a series of *T* to allow easier unpacking.
+
+.. class:: index_sequence<I>
+
+   A shortcut for :class:`integer_sequence\<T, Is>`.
+
+.. class:: make_index_sequence<N>
+
+   Used to generate the :class:`index_sequence\<I>`, with *N* numbers.
+
+.. class:: typelist_index<T, Ts>
+
+   :inherits: ``std::integral_constant<std::size_t, N>``
+
+   The type of std::integral_constant that :class:`typelist_index\<T, Ts>` will
+   inherit from depends on where *T* exists in the type list *Ts*. No attempts
+   are made to allow multiple *T*s in *Ts*.
+
+.. class:: type_at<N, Ts>
+
+   .. type:: type
+
+      When accessed, provides the type at the index *N* in the type list *Ts*
+
+.. function:: constexpr auto value_at<N>(Ts&&) noexcept
+
+   :returns: The value located at the index *N* in the type list *Ts*.
+   :requires: *N* may not be >= ``sizeof...(Ts)``
+
+.. class:: scope_guard<Callable>
+
+   Scope guard acts much like the Boost.ScopeExit library. It is non-copyable,
+   but movable. It can be constructed with any callable type *Callable*. The
+   type *Callable* must be move assignable and move constructible, and marked
+   as *noexcept*. *Callable* must have a function arity of 0 (that is, it takes
+   no arguments). It does not matter whether or not *Callable* returns a value,
+   as it will be ignored. To easily construct a scope_guard, a function named
+   :func:`make_scope_guard` is provided for type inference. This can easily
+   be used to give a scope_guard a lambda. As an example::
+
+      int x = new int { 4 }
+      auto scope_guard = core::make_scope_guard([x] { delete x; });
+
+   .. function:: void dismiss () noexcept
+
+      Calling dismiss on a scope_guard will result in its *Callable* never
+      being invoked. This can be seen as a way to *rollback* bookkeeping code.
+
+.. function:: make_scope_guard(Callable callable) noexcept
+
+   Constructs a :class:`scope_guard\<Callable>` from the given *callable*.
+
+.. function:: constexpr T&& forward (remove_reference_t<T>&&) noexcept
+              constexpr T&& forward (remove_reference_t<T>&) noexcept
+
+   ``constexpr`` versions of ``std::forward``.
+
+.. function:: constexpr remove_reference_t<T>&& move (T&&) noexcept
+
+   ``constexpr`` version of ``std::move``.
diff --git a/src/bsoncxx/third_party/core/docs/variant.rst b/src/bsoncxx/third_party/core/docs/variant.rst
new file mode 100644
index 0000000..00cce9e
--- /dev/null
+++ b/src/bsoncxx/third_party/core/docs/variant.rst
@@ -0,0 +1,156 @@
+.. _core-variant-component:
+
+Variant Component
+=================
+
+.. default-domain:: cpp
+
+.. |variant| replace:: :class:`variant <variant\<Ts>>`
+
+The |variant| component is a generic type-safe implementation of a
+discriminate union. It is equivalent to the Boost.Variant library, with several
+small exceptions.
+
+Specifically, the |variant| does not allow for recursive variants,
+and makes no attempt to support them in any capacity. It is the author's
+opinion that a |variant| should be stack allocated only, and not
+have to handle or deal with allocating memory.
+
+Additionally, the |variant| has the ability to perform type-based
+pattern matching via lambdas. This allows a user to define the different code
+paths that are desired without requiring a user to implement a visitor functor
+separately. *This means that a variant is capable of performing a type-based
+switch statement*
+
+The variant component resides in ``<core/variant.hpp>``.
+
+.. namespace:: core
+
+.. class:: bad_variant_get
+
+   :inherits: ``std::logic_error``
+
+   Used when the call to get the value out of a |variant| uses the incorrect
+   index of the type list.
+
+.. class:: variant<Ts>
+
+   The |variant| type represents a type-safe discriminate union. Much like
+   the Boost.Variant, a |variant| is never in an uninitialized state. When
+   default constructing a |variant|, the first type in the |variant|'s typelist
+   is initialized.
+
+   .. function:: variant (T&& value)
+
+      :requires: *T* be of a type from which any type in *Ts* is constructible.
+
+      Constructs the first type in *Ts* which can be constructed from *T*. The
+      way in which this construction takes place is a first come first serve
+      construction. The reason for this is simply due to how the constructor
+      delegation occurs internally. As such, it is recommended that a |variant|
+      contain types that cannot be constructed from each other.
+
+   .. function:: variant (variant const& that)
+
+      Constructs a |variant| with the same type that is initialized in *that*.
+      The object is initialized with the type's copy constructor.
+
+   .. function:: variant (variant&& that)
+
+      Constructs a |variant| with the same type that is initialized in *that*.
+      The object is initialized with the type's move constructor.
+
+   .. function:: variant ()
+
+      Constructs a |variant| by initializing the first type in its type list.
+
+   .. function:: variant& operator = (variant const&)
+                 variant& operator = (variant&&)
+
+      Assigns the contents of the other |variant| to ``*this``. The object
+      contained within ``*this`` is destructed first.
+
+   .. function:: bool operator == (variant const& that) const noexcept
+
+      If both |variant|'s :func:`which` is the same value, the values contained
+      within are compared.
+
+   .. function:: bool operator < (variant const& that) const noexcept
+
+      If both |variant|'s :func:`which` are equal, the values contained are
+      compared. Otherwise, the result of comparing :func:`which` is returned.
+
+   .. function:: void swap (variant&)
+
+      Swaps the contents of both variants.
+
+   .. function:: visit (Visitor&&, args) const
+                 visit (Visitor&&, args)
+
+     Visiting a |variant| follows the following semantics. These semantics
+     require that, when given a callable type ``Visitor``, and variadic
+     arguments ``Args...``, that the return type of the visit will be
+     a result of ``common_type_t<invoke_of_t<Visitor, Ts, Args...>...>``.
+
+     If a common type cannot be found, then the visitation function will
+     fail to compile properly. This means that a visitor *must* be capable of
+     being invoked with all types in the |variant|'s typelist and the arguments
+     given. The visitor is executed with the *INVOKE* psuedo expression.
+
+     These same semantics are required for :func:`match`.
+
+     :returns: ``common_type_t<invoke_of_t<Visitor, Ts, Args...>...>``
+
+   .. function:: match (Visitors&&) const
+                 match (Visitors&&)
+
+      Takes a variadic number of arguments that are all callable objects. These
+      objects are combined into a single visitor and then executed on the
+      |variant|.
+
+   .. function:: auto get<N> () noexcept
+
+      Depending on the value of ``*this`` (reference, const reference, rvalue)
+      the type of the value returned will be affected as well.
+
+      :noexcept: false
+      :returns: The element located at N in the type list.
+      :throws: :class:`bad_variant_get` if N != :func:`which`.
+
+   .. function:: std::type_info const& type () const noexcept
+
+      :returns: The typeid of the value currently managed by the |variant|.
+
+   .. function:: std::uint32_t which () const noexcept
+
+      :returns: index into type list of which type is currently managed by the
+                variant.
+
+   .. function:: bool empty () const noexcept
+
+      Provided for compatibility with Boost.Variant, and to keep in line with
+      the other 'object containers' contained within this library.
+
+      :returns: false
+
+
+Specializations
+---------------
+
+.. class:: hash<variant<Ts>>
+
+   A specialization of ``std::hash<T>`` for variants. Requires that all
+   *Ts* in a |variant| be specialized for ``std::hash``.
+
+.. function:: void swap (variant& lhs, variant& rhs)
+
+   Calls :func:`variant\<Ts>::swap`
+
+.. function:: auto const& get<N>(variant const&)
+              auto&& get<N>(variant&&)
+              auto& get<N>(variant&)
+
+   Calls :func:`variant\<Ts>::get`, and returns the value. This specialization
+   is provided to interact with ``std::tuple`` and to provide *some* semblance
+   of boost interoperability. However it does not support using the type
+   to get the value from the variant.
diff --git a/src/bsoncxx/third_party/core/include/core/algorithm.hpp b/src/bsoncxx/third_party/core/include/core/algorithm.hpp
new file mode 100644
index 0000000..5e9138e
--- /dev/null
+++ b/src/bsoncxx/third_party/core/include/core/algorithm.hpp
@@ -0,0 +1,1933 @@
+#ifndef CORE_ALGORITHM_HPP
+#define CORE_ALGORITHM_HPP
+
+#include <algorithm>
+
+#include <core/utility.hpp>
+#include <core/range.hpp>
+
+namespace core {
+inline namespace v1 {
+
+/* non-modifying sequence algorithms */
+template <class Range, class UnaryPredicate>
+auto all_of (Range&& rng, UnaryPredicate&& p) -> enable_if_t<
+  is_range<Range>::value,
+  bool
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "all_of requires InputIterators");
+  return ::std::all_of(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<UnaryPredicate>(p)
+  );
+}
+
+template <class Range, class UnaryPredicate>
+auto any_of (Range&& rng, UnaryPredicate&& p) -> enable_if_t<
+  is_range<Range>::value,
+  bool
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "any_of requires InputIterators");
+  return ::std::any_of(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<UnaryPredicate>(p)
+  );
+}
+
+template <class Range, class UnaryPredicate>
+auto none_of (Range&& rng, UnaryPredicate&& p) -> enable_if_t<
+  is_range<Range>::value,
+  bool
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "none_of requires InputIterators");
+  return ::std::none_of(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<UnaryPredicate>(p)
+  );
+}
+
+template <class Range, class UnaryFunction>
+auto for_each (Range&& rng, UnaryFunction&& f) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<UnaryFunction>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "for_each requires InputIterators");
+  return ::std::for_each(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<UnaryFunction>(f)
+  );
+}
+
+template <class Range, class T>
+auto count (Range&& rng, T const& value) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(
+    ::std::count(
+      ::std::begin(::std::forward<Range>(rng)),
+      ::std::end(::std::forward<Range>(rng)),
+      value
+    )
+  )
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "count requires InputIterators");
+  return ::std::count(::std::begin(range), ::std::end(range), value);
+}
+
+template <class Range, class UnaryPredicate>
+auto count_if (Range&& rng, UnaryPredicate&& p) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(
+    ::std::count_if(
+      ::std::begin(::std::forward<Range>(rng)),
+      ::std::end(::std::forward<Range>(rng)),
+      ::std::forward<UnaryPredicate>(p)
+    )
+  )
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "count_if requires InputIterators");
+  return ::std::count_if(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<UnaryPredicate>(p)
+  );
+}
+
+template <class Range, class InputIt>
+auto mismatch(Range&& rng, InputIt&& it) -> enable_if_t<
+  is_range<Range>::value,
+  ::std::pair<
+    decltype(::std::begin(::std::forward<Range>(rng))),
+    decay_t<InputIt>
+  >
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "mismatch requires InputIterators");
+  return ::std::mismatch(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<InputIt>(it)
+  );
+}
+
+template <class Range, class InputIt, class BinaryPredicate>
+auto mismatch(Range&& rng, InputIt&& it, BinaryPredicate&& bp) -> enable_if_t<
+  is_range<Range>::value,
+  ::std::pair<
+    decltype(::std::begin(::std::forward<Range>(rng))),
+    decay_t<InputIt>
+  >
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "mismatch requires InputIterators");
+  return ::std::mismatch(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<InputIt>(it),
+    ::std::forward<BinaryPredicate>(bp)
+  );
+}
+
+template <class Range, class InputIt>
+auto equal (Range&& rng, InputIt&& it) -> enable_if_t<
+  is_range<Range>::value,
+  bool
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "equal requires InputIterators");
+  return ::std::equal(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<InputIt>(it)
+  );
+}
+
+template <class Range, class InputIt, class BinaryPredicate>
+auto equal (Range&& rng, InputIt&& it, BinaryPredicate&& bp) -> enable_if_t<
+  is_range<Range>::value,
+  bool
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "equal requires InputIterators");
+  return ::std::equal(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<InputIt>(it),
+    ::std::forward<BinaryPredicate>(bp)
+  );
+}
+
+template <class Range, class T>
+auto find (Range&& rng, T const& value) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "find requires InputIterators");
+  return ::std::find(::std::begin(range), ::std::end(range), value);
+}
+
+template <class Range, class UnaryPredicate>
+auto find_if (Range&& rng, UnaryPredicate&& p) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "find_if requires InputIterators");
+  return ::std::find_if(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<UnaryPredicate>(p)
+  );
+}
+
+template <class Range, class UnaryPredicate>
+auto find_if_not (Range&& rng, UnaryPredicate&& p) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "find_if_not requires InputIterators");
+  return ::std::find_if_not(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<UnaryPredicate>(p)
+  );
+}
+
+template <class Range1, class Range2>
+auto find_end (Range1&& rng1, Range2&& rng2) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  decltype(::std::begin(::std::forward<Range1>(rng1)))
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_forward1 = decltype(range1)::is_forward;
+  constexpr auto is_forward2 = decltype(range2)::is_forward;
+  static_assert(is_forward1, "find_end requires ForwardIterators");
+  static_assert(is_forward2, "find_end requires ForwardIterators");
+  return ::std::find_end(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2)
+  );
+}
+
+template <class Range1, class Range2, class BinaryPred>
+auto find_end (Range1&& rng1, Range2&& rng2, BinaryPred& bp) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  decltype(::std::begin(::std::forward<Range1>(rng1)))
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_forward1 = decltype(range1)::is_forward;
+  constexpr auto is_forward2 = decltype(range2)::is_forward;
+  static_assert(is_forward1, "find_end requires ForwardIterators");
+  static_assert(is_forward2, "find_end requires ForwardIterators");
+  return ::std::find_end(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2),
+    ::std::forward<BinaryPred>(bp)
+  );
+}
+
+template <class IRange, class FRange>
+auto find_first_of (IRange&& irng, FRange&& frng) -> enable_if_t<
+  all_traits<is_range<IRange>, is_range<FRange>>::value,
+  decltype(::std::begin(::std::forward<IRange>(irng)))
+> {
+  auto irange = make_range(::std::forward<IRange>(irng));
+  auto frange = make_range(::std::forward<FRange>(frng));
+  constexpr auto is_input = decltype(irange)::is_input;
+  constexpr auto is_forward = decltype(frange)::is_forward;
+  static_assert(is_input, "find_first_of requires InputIterators");
+  static_assert(is_forward, "find_first_of requires ForwardIterators");
+  return ::std::find_first_of(
+    ::std::begin(irange),
+    ::std::end(irange),
+    ::std::begin(frange),
+    ::std::end(frange)
+  );
+}
+
+template <class IRange, class FRange, class BinaryPred>
+auto find_first_of (
+  IRange&& irng,
+  FRange&& frng,
+  BinaryPred&& bp
+) -> enable_if_t<
+  all_traits<is_range<IRange>, is_range<FRange>>::value,
+  decltype(::std::begin(::std::forward<IRange>(irng)))
+> {
+  auto irange = make_range(::std::forward<IRange>(irng));
+  auto frange = make_range(::std::forward<FRange>(frng));
+  constexpr auto is_input = decltype(irange)::is_input;
+  constexpr auto is_forward = decltype(frange)::is_forward;
+  static_assert(is_input, "find_first_of requires InputIterators");
+  static_assert(is_forward, "find_first_of requires ForwardIterators");
+  return ::std::find_first_of(
+    ::std::begin(irange),
+    ::std::end(irange),
+    ::std::begin(frange),
+    ::std::end(frange),
+    ::std::forward<BinaryPred>(bp)
+  );
+}
+
+template <class Range>
+auto adjacent_find (Range&& rng) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "adjacent_find requires ForwardIterators");
+  return ::std::adjacent_find(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class BinaryPredicate>
+auto adjacent_find (Range&& rng, BinaryPredicate&& bp) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "adjacent_find requires ForwardIterators");
+  return ::std::adjacent_find(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<BinaryPredicate>(bp)
+  );
+}
+
+template <class Range1, class Range2>
+auto search (Range1&& rng1, Range2&& rng2) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  decltype(::std::begin(::std::forward<Range1>(rng1)))
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_forward1 = decltype(range1)::is_forward;
+  constexpr auto is_forward2 = decltype(range2)::is_forward;
+  static_assert(is_forward1, "search requires ForwardIterators");
+  static_assert(is_forward2, "search requires ForwardIterators");
+  return ::std::search(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2)
+  );
+}
+
+template <class Range1, class Range2, class BinaryPred>
+auto search (Range1&& rng1, Range2&& rng2, BinaryPred&& bp) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  decltype(::std::begin(::std::forward<Range1>(rng1)))
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_forward1 = decltype(range1)::is_forward;
+  constexpr auto is_forward2 = decltype(range2)::is_forward;
+  static_assert(is_forward1, "search requires ForwardIterators");
+  static_assert(is_forward2, "search requires ForwardIterators");
+  return ::std::search(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2),
+    ::std::forward<BinaryPred>(bp)
+  );
+}
+
+template <class Range, class Size, class T>
+auto search_n (Range&& rng, Size&& count, T const& value) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "search_n requires ForwardIterators");
+  return ::std::search_n(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Size>(count),
+    value
+  );
+}
+
+template <class Range, class Size, class T, class BinaryPred>
+auto search_n (
+  Range&& rng,
+  Size&& count,
+  T const& value,
+  BinaryPred&& bp
+) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "search_n requires ForwardIterators");
+  return ::std::search_n(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Size>(count),
+    value,
+    ::std::forward<BinaryPred>(bp)
+  );
+}
+
+/* modifying sequence algorithms */
+template <class Range, class OutputIt>
+auto copy (Range&& rng, OutputIt&& it) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<OutputIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "copy requires InputIterators");
+  return ::std::copy(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputIt>(it)
+  );
+}
+
+template <class Range, class OutputIt, class UnaryPredicate>
+auto copy_if (Range&& rng, OutputIt&& it, UnaryPredicate&& up) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<OutputIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "copy_if requires InputIterators");
+  return ::std::copy_if(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputIt>(it),
+    ::std::forward<UnaryPredicate>(up)
+  );
+}
+
+template <class Range, class BidirIt>
+auto copy_backward (Range&& rng, BidirIt&& it) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<BidirIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_bidir = decltype(range)::is_bidirectional;
+  static_assert(is_bidir, "copy_backward requires BidirectionalIterators");
+  return ::std::copy_backward(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<BidirIt>(it)
+  );
+}
+
+template <class Range, class OutputIt>
+auto move (Range&& rng, OutputIt&& it) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<OutputIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "move requires InputIterators");
+  return ::std::move(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputIt>(it)
+  );
+}
+
+template <class Range, class BidirIt>
+auto move_backward (Range&& rng, BidirIt&& it) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<BidirIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_bidir = decltype(range)::is_bidirectional;
+  static_assert(is_bidir, "move_backward requires BidirectionalIterators");
+  return ::std::move_backward(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<BidirIt>(it)
+  );
+}
+
+template <class Range, class T>
+auto fill (Range&& rng, T const& value) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "fill requires ForwardIterators");
+  return ::std::fill(::std::begin(range), ::std::end(range), value);
+}
+
+template <class Range, class OutputIt, class UnaryOperation>
+auto transform (
+  Range&& rng,
+  OutputIt&& it,
+  UnaryOperation&& op
+) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<OutputIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "transform requires InputIterators");
+  return ::std::transform(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputIt>(it),
+    ::std::forward<UnaryOperation>(op)
+  );
+}
+
+template <class Range, class OutputIt, class UnaryOperation, class UnaryPred>
+auto transform_if (
+  Range&& rng,
+  OutputIt it,
+  UnaryOperation op,
+  UnaryPred up
+) -> enable_if_t<
+  is_range<Range>::value,
+  OutputIt
+> {
+  auto range = make_range(::core::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "transform_if requires ForwardIterators");
+  while (range.begin() != range.end()) {
+    if (up(range.front())) {
+      *it = op(range.front());
+      ++it;
+    }
+    range.pop_front();
+  }
+  return it;
+}
+
+template <class Range1, class Range2, class OutputIt, class BinaryOperation>
+auto transform (
+  Range1&& rng1,
+  Range2&& rng2,
+  OutputIt&& it,
+  BinaryOperation&& op
+) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  decay_t<OutputIt>
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_input1 = decltype(range1)::is_input;
+  constexpr auto is_input2 = decltype(range2)::is_input;
+  static_assert(is_input1, "transform requires InputIterators");
+  static_assert(is_input2, "transform requires InputIterators");
+  return ::std::transform(
+    ::std::begin(range2),
+    ::std::end(range2),
+    ::std::begin(range2),
+    ::std::forward<OutputIt>(it),
+    ::std::forward<BinaryOperation>(op)
+  );
+}
+
+template <
+  class Range1,
+  class Range2,
+  class OutputIt,
+  class BinaryOperation,
+  class BinaryPredicate
+> auto transform_if (
+  Range1&& rng1,
+  Range2&& rng2,
+  OutputIt it,
+  BinaryOperation op,
+  BinaryPredicate bp
+) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  OutputIt
+> {
+  auto range1 = make_range(::core::forward<Range1>(rng1));
+  auto range2 = make_range(::core::forward<Range2>(rng2));
+  constexpr auto is_forward1 = decltype(range1)::is_forward;
+  constexpr auto is_forward2 = decltype(range2)::is_forward;
+  static_assert(is_forward1, "transform_if requires ForwardIterators");
+  static_assert(is_forward2, "transform_if requires ForwardIterators");
+  while (range1.begin() != range1.end()) {
+    if (bp(range1.front(), range2.front())) {
+      *it = op(range1.front(), range2.front());
+      ++it;
+    }
+    range1.pop_front();
+    range2.pop_front();
+  }
+  return it;
+}
+
+template <class Range, class T>
+auto remove (Range&& rng, T const& value) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "remove requires ForwardIterators");
+  return ::std::remove(::std::begin(range), ::std::end(range), value);
+}
+
+template <class Range, class UnaryPredicate>
+auto remove_if (Range&& rng, UnaryPredicate&& up) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "remove_if requires ForwardIterators");
+  return ::std::remove_if(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<UnaryPredicate>(up)
+  );
+}
+
+template <class Range, class OutputIt, class T>
+auto remove_copy (Range&& rng, OutputIt&& it, T const& value) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<OutputIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "remove_copy requires InputIterators");
+  return ::std::remove_copy(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputIt>(it),
+    value
+  );
+}
+
+template <class Range, class OutputIt, class UnaryPred>
+auto remove_copy_if (Range&& rng, OutputIt&& it, UnaryPred&& up) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<OutputIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "remove_copy_if requires InputIterators");
+  return ::std::remove_copy_if(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputIt>(it),
+    ::std::forward<UnaryPred>(up)
+  );
+}
+
+template <class Range, class T>
+auto remove_erase (Range&& rng, T const& val) -> enable_if_t<
+  is_range<Range>::value
+> {
+  ::std::forward<Range>(rng).erase(
+    remove(::std::forward<Range>(rng), val),
+    ::std::end(::std::forward<Range>(rng))
+  );
+}
+
+template <class Range, class UnaryPred>
+auto remove_erase_if (Range&& rng, UnaryPred&& up) -> enable_if_t<
+  is_range<Range>::value
+> {
+  ::std::forward<Range>(rng).erase(
+    remove_if(
+      ::std::forward<Range>(rng),
+      ::std::forward<UnaryPred>(up)
+    ),
+    ::std::end(::std::forward<Range>(rng))
+  );
+}
+
+template <class Range, class T>
+auto replace (Range&& rng, T const& old, T const& value) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_input;
+  static_assert(is_forward, "replace requires ForwardIterators");
+  return ::std::replace(
+    ::std::begin(range),
+    ::std::end(range),
+    old,
+    value
+  );
+}
+
+template <class Range, class UnaryPred, class T>
+auto replace_if (Range&& rng, UnaryPred&& up, T const& value) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "replace_if requires ForwardIterators");
+  return ::std::replace_if(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<UnaryPred>(up),
+    value
+  );
+}
+
+template <class Range, class OutputIt, class T>
+auto replace_copy (
+  Range&& rng,
+  OutputIt&& it,
+  T const& old,
+  T const& value
+) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<OutputIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "replace_copy requires InputIterators");
+  return ::std::replace_copy(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputIt>(it),
+    old,
+    value
+  );
+}
+
+template <class Range, class OutputIt, class UnaryPred, class T>
+auto replace_copy_if (
+  Range&& rng,
+  OutputIt&& it,
+  UnaryPred&& up,
+  T const& value
+) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<OutputIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "replace_copy_if requires InputIterators");
+  return ::std::replace_copy_if(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputIt>(it),
+    ::std::forward<UnaryPred>(up),
+    value
+  );
+}
+
+template <class Range, class ForwardIt>
+auto swap_ranges (Range&& rng, ForwardIt&& it) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<ForwardIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "swap_ranges requires ForwardIterators");
+  return ::std::swap_ranges(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<ForwardIt>(it)
+  );
+}
+
+template <class Range>
+auto reverse (Range&& rng) -> enable_if_t<is_range<Range>::value> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_bidir = decltype(range)::is_bidirectional;
+  static_assert(is_bidir, "reverse requires BidirectionalIterators");
+  return ::std::reverse(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class OutputIt>
+auto reverse_copy (Range&& rng, OutputIt&& it) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<OutputIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_bidir = decltype(range)::is_bidirectional;
+  static_assert(is_bidir, "reverse_copy requires BidirectionalIterators");
+  return ::std::reverse_copy(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputIt>(it)
+  );
+}
+
+template <class Range, class ForwardIt>
+auto rotate (Range&& rng, ForwardIt&& it) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "rotate requires ForwardIterators");
+  ::std::rotate(
+    ::std::begin(range),
+    ::std::forward<ForwardIt>(it),
+    ::std::end(range)
+  );
+}
+
+template <class Range, class ForwardIt, class OutputIt>
+auto rotate_copy (Range&& rng, ForwardIt&& it, OutputIt&& ot) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<OutputIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "rotate_copy requires ForwardIterators");
+  return ::std::rotate_copy(
+    ::std::begin(range),
+    ::std::forward<ForwardIt>(it),
+    ::std::end(range),
+    ::std::forward<OutputIt>(ot)
+  );
+}
+
+template <class Range, class URNG>
+auto shuffle (Range&& rng, URNG&& g) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "shuffle requires RandomAccessIterators");
+  return ::std::shuffle(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<URNG>(g)
+  );
+}
+
+template <class Range>
+auto unique (Range&& rng) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "unique requires ForwardIterators");
+  return ::std::unique(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class BinaryPredicate>
+auto unique (Range&& rng, BinaryPredicate&& bp) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "unique requires ForwardIterators");
+  return ::std::unique(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<BinaryPredicate>(bp)
+  );
+}
+
+template <class Range, class OutputIt>
+auto unique_copy (Range&& rng, OutputIt&& it) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<OutputIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "unique_copy requires InputIterators");
+  return ::std::unique_copy(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputIt>(it)
+  );
+}
+
+template <class Range, class OutputIt, class BinaryPred>
+auto unique_copy (Range&& rng, OutputIt&& it, BinaryPred&& bp) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<OutputIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "unique_copy requires InputIterators");
+  return ::std::unique_copy(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputIt>(it),
+    ::std::forward<BinaryPred>(bp)
+  );
+}
+
+/* partitioning operations */
+template <class Range, class UnaryPredicate>
+auto is_partitioned (Range&& rng, UnaryPredicate&& up) -> enable_if_t<
+  is_range<Range>::value,
+  bool
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "is_partitioned requires InputIterators");
+  return ::std::is_partitioned(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<UnaryPredicate>(up)
+  );
+}
+
+template <class Range, class UnaryPredicate>
+auto partition (Range&& rng, UnaryPredicate&& up) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "partition requires ForwardIterators");
+  return ::std::partition(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<UnaryPredicate>(up)
+  );
+}
+
+template <class Range, class OutputTrue, class OutputFalse, class UnaryPred>
+auto partition_copy (
+  Range&& rng,
+  OutputTrue&& ot,
+  OutputFalse&& of,
+  UnaryPred&& up
+) -> enable_if_t<
+  is_range<Range>::value,
+  ::std::pair<decay_t<OutputTrue>, decay_t<OutputFalse>>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "partition_copy requires InputIterators");
+  return ::std::partition_copy(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputTrue>(ot),
+    ::std::forward<OutputFalse>(of),
+    ::std::forward<UnaryPred>(up)
+  );
+}
+
+template <class Range, class UnaryPredicate>
+auto stable_partition (Range&& rng, UnaryPredicate&& up) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_bidir = decltype(range)::is_bidirectional;
+  static_assert(is_bidir, "stable_partition requires BidirectionalIterators");
+  return ::std::stable_partition(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<UnaryPredicate>(up)
+  );
+}
+
+template <class Range, class UnaryPredicate>
+auto partition_point (Range&& rng, UnaryPredicate&& up) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "partition_point requires ForwardIterators");
+  return ::std::partition_point(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<UnaryPredicate>(up)
+  );
+}
+
+/* sorting operations */
+
+template <class Range>
+auto is_sorted (Range&& rng) -> enable_if_t<is_range<Range>::value, bool> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "is_sorted requires ForwardIterators");
+  return ::std::is_sorted(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class Compare>
+auto is_sorted (Range&& rng, Compare&& compare) -> enable_if_t<
+  is_range<Range>::value,
+  bool
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "is_sorted requires ForwardIterators");
+  return ::std::is_sorted(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Compare>(compare)
+  );
+}
+
+template <class Range>
+auto is_sorted_until (Range&& rng) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "is_sorted_until requires ForwardIterators");
+  return ::std::is_sorted_until(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class Compare>
+auto is_sorted_until (Range&& rng, Compare&& compare) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "is_sorted_until requires ForwardIterators");
+  return ::std::is_sorted_until(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Compare>(compare)
+  );
+}
+
+template <class Range>
+auto sort (Range&& rng) -> enable_if_t<is_range<Range>::value> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "sort requires RandomAccessIterators");
+  return ::std::sort(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class Compare>
+auto sort (Range&& rng, Compare&& cmp) -> enable_if_t<is_range<Range>::value> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "sort requires RandomAccessIterators");
+  return ::std::sort(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range, class RandomIt>
+auto partial_sort (Range&& rng, RandomIt&& it) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "partial_sort requires RandomAccessIterators");
+  return ::std::partial_sort(
+    ::std::begin(range),
+    ::std::forward<RandomIt>(it),
+    ::std::end(range)
+  );
+}
+
+template <class Range, class RandomIt, class Compare>
+auto partial_sort (Range&& rng, RandomIt&& it, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "partial_sort requires RandomAccessIterators");
+  return ::std::partial_sort(
+    ::std::begin(range),
+    ::std::forward<RandomIt>(it),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class IRange, class RRange>
+auto partial_sort_copy (IRange&& irng, RRange&& rrng) -> enable_if_t<
+  all_traits<is_range<IRange>, is_range<RRange>>::value,
+  decltype(::std::begin(::std::forward<RRange>(rrng)))
+> {
+  auto irange = make_range(::std::forward<IRange>(irng));
+  auto rrange = make_range(::std::forward<RRange>(rrng));
+  constexpr auto is_input = decltype(irange)::is_input;
+  constexpr auto is_random = decltype(rrange)::is_random_access;
+  static_assert(is_input, "partial_sort_copy requires InputIterators");
+  static_assert(is_random, "partial_sort_copy requires RandomAccessIterators");
+  return ::std::partial_sort_copy(
+    ::std::begin(irange),
+    ::std::end(irange),
+    ::std::begin(rrange),
+    ::std::end(rrange)
+  );
+}
+
+template <class IRange, class RRange, class Compare>
+auto partial_sort_copy (
+  IRange&& irng,
+  RRange&& rrng,
+  Compare&& cmp
+) -> enable_if_t<
+  all_traits<is_range<IRange>, is_range<RRange>>::value,
+  decltype(::std::begin(::std::forward<RRange>(rrng)))
+> {
+  auto irange = make_range(::std::forward<IRange>(irng));
+  auto rrange = make_range(::std::forward<RRange>(rrng));
+  constexpr auto is_input = decltype(irange)::is_input;
+  constexpr auto is_random = decltype(rrange)::is_random_access;
+  static_assert(is_input, "partial_sort_copy requires InputIterators");
+  static_assert(is_random, "partial_sort_copy requires RandomAccessIterators");
+  return ::std::partial_sort_copy(
+    ::std::begin(irange),
+    ::std::end(irange),
+    ::std::begin(rrange),
+    ::std::end(rrange),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range>
+auto stable_sort (Range&& rng) -> enable_if_t<is_range<Range>::value> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "stable_sort requires RandomAccessIterators");
+  return ::std::stable_sort(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class Compare>
+auto stable_sort (Range&& rng, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "stable_sort requires RandomAccessIterators");
+  return ::std::stable_sort(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range, class RandomIt>
+auto nth_element (Range&& rng, RandomIt&& it) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "nth_element requires RandomAccessIterators");
+  return ::std::nth_element(
+    ::std::begin(range),
+    ::std::forward<RandomIt>(it),
+    ::std::end(range)
+  );
+}
+
+template <class Range, class RandomIt, class Compare>
+auto nth_element (Range&& rng, RandomIt&& it, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "nth_element requires RandomAccessIterators");
+  return ::std::nth_element(
+    ::std::begin(range),
+    ::std::forward<RandomIt>(it),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+/* binary search operations (on sorted ranges) */
+template <class Range, class T>
+auto lower_bound (Range&& rng, T const& value) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "lower_bound requires ForwardIterators");
+  return ::std::lower_bound(::std::begin(range), ::std::end(range), value);
+}
+
+template <class Range, class T, class Compare>
+auto lower_bound (Range&& rng, T const& value, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "lower_bound requires ForwardIterators");
+  return ::std::lower_bound(
+    ::std::begin(range),
+    ::std::end(range),
+    value,
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range, class T>
+auto upper_bound (Range&& rng, T const& value) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "upper_bound requires ForwardIterators");
+  return ::std::upper_bound(::std::begin(range), ::std::end(range), value);
+}
+
+template <class Range, class T, class Compare>
+auto upper_bound (Range&& rng, T const& value, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "upper_bound requires ForwardIterators");
+  return ::std::upper_bound(
+    ::std::begin(range),
+    ::std::end(range),
+    value,
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range, class T>
+auto binary_search (Range&& rng, T const& value) -> enable_if_t<
+  is_range<Range>::value,
+  bool
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "binary_search requires ForwardIterators");
+  return ::std::binary_search(::std::begin(range), ::std::end(range), value);
+}
+
+template <class Range, class T, class Compare>
+auto binary_search (Range&& rng, T const& value, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value,
+  bool
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "binary_search requires ForwardIterators");
+  return ::std::binary_search(
+    ::std::begin(range),
+    ::std::end(range),
+    value,
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range, class T>
+auto equal_range (Range&& rng, T const& value) -> enable_if_t<
+  is_range<Range>::value,
+  range<decltype(::std::begin(::std::forward<Range>(rng)))>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "equal_range requires ForwardIterators");
+  return ::std::equal_range(::std::begin(range), ::std::end(range), value);
+}
+
+template <class Range, class T, class Compare>
+auto equal_range (Range&& rng, T const& value, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value,
+  range<decltype(::std::begin(::std::forward<Range>(rng)))>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "equal_range requires ForwardIterators");
+  return ::std::equal_range(
+    ::std::begin(range),
+    ::std::end(range),
+    value,
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+/* set operations (on sorted ranges) */
+template <class Range1, class Range2, class OutputIt>
+auto merge (Range1&& rng1, Range2&& rng2, OutputIt&& it) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  decay_t<OutputIt>
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_input1 = decltype(range1)::is_input;
+  constexpr auto is_input2 = decltype(range2)::is_input;
+  static_assert(is_input1, "merge requires InputIterators");
+  static_assert(is_input2, "merge requires InputIterators");
+  return ::std::merge(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2),
+    ::std::forward<OutputIt>(it)
+  );
+}
+
+template <class Range1, class Range2, class OutputIt, class Compare>
+auto merge (
+  Range1&& rng1,
+  Range2&& rng2,
+  OutputIt&& it,
+  Compare&& cmp
+) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  decay_t<OutputIt>
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_input1 = decltype(range1)::is_input;
+  constexpr auto is_input2 = decltype(range2)::is_input;
+  static_assert(is_input1, "merge requires InputIterators");
+  static_assert(is_input2, "merge requires InputIterators");
+  return ::std::merge(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2),
+    ::std::forward<OutputIt>(it),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range, class BidirIt>
+auto inplace_merge (Range&& rng, BidirIt&& it) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_bidir = decltype(range)::is_bidirectional;
+  static_assert(is_bidir, "inplace_merge requires BidirectionalIterators");
+  return ::std::inplace_merge(
+    ::std::begin(range),
+    ::std::forward<BidirIt>(it),
+    ::std::end(range)
+  );
+}
+
+template <class Range, class BidirIt, class Compare>
+auto inplace_merge (Range&& rng, BidirIt&& it, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_bidir = decltype(range)::is_bidirectional;
+  static_assert(is_bidir, "inplace_merge requires BidirectionalIterators");
+  return ::std::inplace_merge(
+    ::std::begin(range),
+    ::std::forward<BidirIt>(it),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range1, class Range2>
+auto includes (Range1&& rng1, Range2&& rng2) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  bool
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_input1 = decltype(range1)::is_input;
+  constexpr auto is_input2 = decltype(range2)::is_input;
+  static_assert(is_input1, "includes requires InputIterators");
+  static_assert(is_input2, "includes requires InputIterators");
+  return ::std::includes(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2)
+  );
+}
+
+template <class Range1, class Range2, class Compare>
+auto includes (Range1&& rng1, Range2&& rng2, Compare&& cmp) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  bool
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_input1 = decltype(range1)::is_input;
+  constexpr auto is_input2 = decltype(range2)::is_input;
+  static_assert(is_input1, "includes requires InputIterators");
+  static_assert(is_input2, "includes requires InputIterators");
+  return ::std::includes(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range1, class Range2, class OutputIt>
+auto set_difference (Range1&& rng1, Range2&& rng2, OutputIt&& it) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  decay_t<OutputIt>
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_input1 = decltype(range1)::is_input;
+  constexpr auto is_input2 = decltype(range2)::is_input;
+  static_assert(is_input1, "set_difference requires InputIterators");
+  static_assert(is_input2, "set_difference requires InputIterators");
+  return ::std::set_difference(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2),
+    ::std::forward<OutputIt>(it)
+  );
+}
+
+template <class Range1, class Range2, class OutputIt, class Compare>
+auto set_difference (
+  Range1&& rng1,
+  Range2&& rng2,
+  OutputIt&& it,
+  Compare&& cmp
+) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  decay_t<OutputIt>
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_input1 = decltype(range1)::is_input;
+  constexpr auto is_input2 = decltype(range2)::is_input;
+  static_assert(is_input1, "set_difference requires InputIterators");
+  static_assert(is_input2, "set_difference requires InputIterators");
+  return ::std::set_difference(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2),
+    ::std::forward<OutputIt>(it),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range1, class Range2, class OutputIt>
+auto set_intersection (Range1&& rng1, Range2&& rng2, OutputIt&& it) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  decay_t<OutputIt>
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_input1 = decltype(range1)::is_input;
+  constexpr auto is_input2 = decltype(range2)::is_input;
+  static_assert(is_input1, "set_intersection requires InputIterators");
+  static_assert(is_input2, "set_intersection requires InputIterators");
+  return ::std::set_intersection(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2),
+    ::std::forward<OutputIt>(it)
+  );
+}
+
+template <class Range1, class Range2, class OutputIt, class Compare>
+auto set_intersection (
+  Range1&& rng1,
+  Range2&& rng2,
+  OutputIt&& it,
+  Compare&& cmp
+) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  decay_t<OutputIt>
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_input1 = decltype(range1)::is_input;
+  constexpr auto is_input2 = decltype(range2)::is_input;
+  static_assert(is_input1, "set_intersection requires InputIterators");
+  static_assert(is_input2, "set_intersection requires InputIterators");
+  return ::std::set_intersection(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2),
+    ::std::forward<OutputIt>(it),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range1, class Range2, class OutputIt>
+auto set_symmetric_difference (Range1&& rng1, Range2&& rng2, OutputIt&& it) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  decay_t<OutputIt>
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_input1 = decltype(range1)::is_input;
+  constexpr auto is_input2 = decltype(range2)::is_input;
+  static_assert(is_input1, "set_symmetric_difference requires InputIterators");
+  static_assert(is_input2, "set_symmetric_difference requires InputIterators");
+  return ::std::set_symmetric_difference(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2),
+    ::std::forward<OutputIt>(it)
+  );
+}
+
+template <class Range1, class Range2, class OutputIt, class Compare>
+auto set_symmetric_difference (
+  Range1&& rng1,
+  Range2&& rng2,
+  OutputIt&& it,
+  Compare&& cmp
+) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  decay_t<OutputIt>
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_input1 = decltype(range1)::is_input;
+  constexpr auto is_input2 = decltype(range2)::is_input;
+  static_assert(is_input1, "set_symmetric_difference requires InputIterators");
+  static_assert(is_input2, "set_symmetric_difference requires InputIterators");
+  return ::std::set_symmetric_difference(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2),
+    ::std::forward<OutputIt>(it),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range1, class Range2, class OutputIt>
+auto set_union (Range1&& rng1, Range2&& rng2, OutputIt&& it) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  decay_t<OutputIt>
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_input1 = decltype(range1)::is_input;
+  constexpr auto is_input2 = decltype(range2)::is_input;
+  static_assert(is_input1, "set_union requires InputIterators");
+  static_assert(is_input2, "set_union requires InputIterators");
+  return ::std::set_union(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2),
+    ::std::forward<OutputIt>(it)
+  );
+}
+
+template <class Range1, class Range2, class OutputIt, class Compare>
+auto set_union (
+  Range1&& rng1,
+  Range2&& rng2,
+  OutputIt&& it,
+  Compare&& cmp
+) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  decay_t<OutputIt>
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_input1 = decltype(range1)::is_input;
+  constexpr auto is_input2 = decltype(range2)::is_input;
+  static_assert(is_input1, "set_union requires InputIterators");
+  static_assert(is_input2, "set_union requires InputIterators");
+  return ::std::set_union(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2),
+    ::std::forward<OutputIt>(it),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+/* heap operations */
+template <class Range>
+auto is_heap (Range&& rng) -> enable_if_t<is_range<Range>::value, bool> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "is_heap requires RandomAccessIterators");
+  return ::std::is_heap(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class Compare>
+auto is_heap (Range&& rng, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value,
+  bool
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "is_heap requires RandomAccessIterators");
+  return ::std::is_heap(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range>
+auto is_heap_until (Range&& rng) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "is_heap_until requires RandomAccessIterators");
+  return ::std::is_heap_until(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class Compare>
+auto is_heap_until (Range&& rng, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "is_heap_until requires RandomAccessIterators");
+  return ::std::is_heap_until(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range>
+auto make_heap (Range&& rng) -> enable_if_t<is_range<Range>::value> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "make_heap requires RandomAccessIterators");
+  return ::std::make_heap(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class Compare>
+auto make_heap (Range&& rng, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "make_heap requires RandomAccessIterators");
+  return ::std::make_heap(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range>
+auto push_heap (Range&& rng) -> enable_if_t<is_range<Range>::value> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "push_heap requires RandomAccessIterators");
+  return ::std::push_heap(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class Compare>
+auto push_heap (Range&& rng, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "push_heap requires RandomAccessIterators");
+  return ::std::push_heap(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range>
+auto pop_heap (Range&& rng) -> enable_if_t<is_range<Range>::value> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "pop_heap requires RandomAccessIterators");
+  return ::std::pop_heap(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class Compare>
+auto pop_heap (Range&& rng, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "pop_heap requires RandomAccessIterators");
+  return ::std::pop_heap(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range>
+auto sort_heap (Range&& rng) -> enable_if_t<is_range<Range>::value> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "sort_heap requires RandomAccessIterators");
+  return ::std::sort_heap(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class Compare>
+auto sort_heap (Range&& rng, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_random = decltype(range)::is_random_access;
+  static_assert(is_random, "sort_heap requires RandomAccessIterators");
+  return ::std::sort_heap(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+/* min/max operations */
+template <class Range>
+auto max_element (Range&& rng) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "max_element requires ForwardIterators");
+  return ::std::max_element(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class Compare>
+auto max_element (Range&& rng, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "max_element requires ForwardIterators");
+  return ::std::max_element(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range>
+auto min_element (Range&& rng) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "min_element requires ForwardIterators");
+  return ::std::min_element(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class Compare>
+auto min_element (Range&& rng, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value,
+  decltype(::std::begin(::std::forward<Range>(rng)))
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "min_element requires ForwardIterators");
+  return ::std::min_element(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range>
+auto minmax_element (Range&& rng) -> enable_if_t<
+  is_range<Range>::value,
+  ::std::pair<
+    decltype(::std::begin(::std::forward<Range>(rng))),
+    decltype(::std::begin(::std::forward<Range>(rng)))
+  >
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "minmax_element requires ForwardIterators");
+  return ::std::minmax_element(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class Compare>
+auto minmax_element (Range&& rng, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value,
+  ::std::pair<
+    range<decltype(::std::begin(::std::forward<Range>(rng)))>,
+    range<decltype(::std::begin(::std::forward<Range>(rng)))>
+  >
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "minmax_element requires ForwardIterators");
+  return ::std::minmax_element(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range1, class Range2>
+auto lexicographical_compare (Range1&& rng1, Range2&& rng2) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  bool
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_input1 = decltype(range1)::is_input;
+  constexpr auto is_input2 = decltype(range2)::is_input;
+  static_assert(is_input1, "lexicographical_compare requires InputIterators");
+  static_assert(is_input2, "lexicographical_compare requires InputIterators");
+  return ::std::lexicographical_compare(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2)
+  );
+}
+
+template <class Range1, class Range2, class Compare>
+auto lexicographical_compare (
+  Range1&& rng1,
+  Range2&& rng2,
+  Compare&& cmp
+) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  bool
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_input1 = decltype(range1)::is_input;
+  constexpr auto is_input2 = decltype(range2)::is_input;
+  static_assert(is_input1, "lexicographical_compare requires InputIterators");
+  static_assert(is_input2, "lexicographical_compare requires InputIterators");
+  return ::std::lexicographical_compare(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::end(range2),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range1, class Range2>
+auto is_permutation (Range1&& rng1, Range2&& rng2) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  bool
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_forward1 = decltype(range1)::is_forward;
+  constexpr auto is_forward2 = decltype(range2)::is_forward;
+  static_assert(is_forward1, "is_permutation requires ForwardIterators");
+  static_assert(is_forward2, "is_permutation requires ForwardIterators");
+  return ::std::is_permutation(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2)
+  );
+}
+
+template <class Range1, class Range2, class BinaryPredicate>
+auto is_permutation (
+  Range1&& rng1,
+  Range2&& rng2,
+  BinaryPredicate&& bp
+) -> enable_if_t<
+  all_traits<is_range<Range1>, is_range<Range2>>::value,
+  bool
+> {
+  auto range1 = make_range(::std::forward<Range1>(rng1));
+  auto range2 = make_range(::std::forward<Range2>(rng2));
+  constexpr auto is_forward1 = decltype(range1)::is_forward;
+  constexpr auto is_forward2 = decltype(range2)::is_forward;
+  static_assert(is_forward1, "is_permutation requires ForwardIterators");
+  static_assert(is_forward2, "is_permutation requires ForwardIterators");
+  return ::std::is_permutation(
+    ::std::begin(range1),
+    ::std::end(range1),
+    ::std::begin(range2),
+    ::std::forward<BinaryPredicate>(bp)
+  );
+}
+
+template <class Range>
+auto next_permutation (Range&& rng) -> enable_if_t<
+  is_range<Range>::value,
+  bool
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_bidir = decltype(range)::is_bidirectional;
+  static_assert(is_bidir, "next_permutation requires BidirectionalIterators");
+  return ::std::next_permutation(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class Compare>
+auto next_permutation (Range&& rng, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value,
+  bool
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_bidir = decltype(range)::is_bidirectional;
+  static_assert(is_bidir, "next_permutation requires BidirectionalIterators");
+  return ::std::next_permutation(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+template <class Range>
+auto prev_permutation (Range&& rng) -> enable_if_t<
+  is_range<Range>::value,
+  bool
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_bidir = decltype(range)::is_bidirectional;
+  static_assert(is_bidir, "prev_permutation requires BidirectionalIterators");
+  return ::std::prev_permutation(::std::begin(range), ::std::end(range));
+}
+
+template <class Range, class Compare>
+auto prev_permutation (Range&& rng, Compare&& cmp) -> enable_if_t<
+  is_range<Range>::value,
+  bool
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_bidir = decltype(range)::is_bidirectional;
+  static_assert(is_bidir, "prev_permutation requires BidirectionalIterators");
+  return ::std::prev_permutation(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<Compare>(cmp)
+  );
+}
+
+}} /* namespace core::v1 */
+
+#endif /* CORE_ALGORITHM_HPP */
diff --git a/src/bsoncxx/third_party/core/include/core/any.hpp b/src/bsoncxx/third_party/core/include/core/any.hpp
new file mode 100644
index 0000000..f95b2a3
--- /dev/null
+++ b/src/bsoncxx/third_party/core/include/core/any.hpp
@@ -0,0 +1,293 @@
+#ifndef CORE_ANY_HPP
+#define CORE_ANY_HPP
+
+#include <stdexcept>
+#include <typeinfo>
+#include <memory>
+
+#include <core/type_traits.hpp>
+#include <core/utility.hpp>
+
+namespace core {
+inline namespace v1 {
+namespace impl {
+
+using data_type = add_pointer_t<void>;
+
+template <class Type>
+using is_small = ::std::integral_constant<
+  bool,
+  sizeof(decay_t<Type>) <= sizeof(void*)
+>;
+
+struct any_dispatch {
+  using destroy_function = void (*)(data_type&);
+  using clone_function = void(*)(data_type const&, data_type&);
+  using type_function = ::std::type_info const& (*)();
+
+  destroy_function const destroy;
+  clone_function const clone;
+  type_function const type;
+};
+
+template <class Type, bool=is_small<Type>::value>
+struct any_dispatch_select;
+
+template <class Type>
+struct any_dispatch_select<Type, true> {
+  using allocator_type = ::std::allocator<Type>;
+  using allocator_traits = ::std::allocator_traits<allocator_type>;
+
+  static void clone (data_type const& source, data_type& data) {
+    allocator_type alloc { };
+    auto const& value = reinterpret_cast<Type const&>(source);
+    auto& ref = reinterpret_cast<Type&>(data);
+    allocator_traits::construct(alloc, ::std::addressof(ref), value);
+  }
+
+  static void destroy (data_type& data) {
+    allocator_type alloc { };
+    auto& ref = reinterpret_cast<Type&>(data);
+    allocator_traits::destroy(alloc, ::std::addressof(ref));
+  }
+};
+
+template <class Type>
+struct any_dispatch_select<Type, false> {
+  using allocator_type = ::std::allocator<Type>;
+  using allocator_traits = ::std::allocator_traits<allocator_type>;
+
+  static void clone (data_type const& source, data_type& data) {
+    allocator_type alloc { };
+    auto const& value = *static_cast<Type* const>(source);
+    auto pointer = allocator_traits::allocate(alloc, 1);
+    auto scope = make_scope_guard([&alloc, pointer] {
+      allocator_traits::deallocate(alloc, pointer, 1);
+    });
+    allocator_traits::construct(alloc, pointer, value);
+    scope.dismiss();
+    data = pointer;
+  }
+
+  static void destroy (data_type& data) {
+    allocator_type alloc { };
+    auto value = static_cast<Type*>(data);
+    allocator_traits::destroy(alloc, value);
+    allocator_traits::deallocate(alloc, value, 1);
+  }
+};
+
+template <class Type>
+any_dispatch const* get_any_dispatch () {
+  static any_dispatch const instance = {
+    any_dispatch_select<Type>::destroy,
+    any_dispatch_select<Type>::clone,
+    [] () -> ::std::type_info const& { return typeid(Type); }
+  };
+  return ::std::addressof(instance);
+}
+
+template <>
+inline any_dispatch const* get_any_dispatch<void> () {
+  static any_dispatch const instance = {
+    [] (data_type&) { },
+    [] (data_type const&, data_type&) { },
+    [] () -> ::std::type_info const& { return typeid(void); }
+  };
+  return ::std::addressof(instance);
+}
+
+} /* namespace impl */
+
+class bad_any_cast final : public ::std::bad_cast {
+public:
+  virtual char const* what () const noexcept override {
+    return "bad any cast";
+  }
+};
+
+class any final {
+  template <class ValueType>
+  friend ValueType const* any_cast (any const*) noexcept;
+  template <class ValueType> friend ValueType* any_cast (any*) noexcept;
+
+  impl::any_dispatch const* table;
+  impl::data_type data;
+
+  template <class ValueType>
+  any (ValueType&& value, ::std::true_type&&) :
+    table { impl::get_any_dispatch<decay_t<ValueType>>() },
+    data { nullptr }
+  {
+    using value_type = decay_t<ValueType>;
+    using allocator_type = ::std::allocator<value_type>;
+    allocator_type alloc { };
+    auto pointer = reinterpret_cast<value_type*>(::std::addressof(this->data));
+    ::std::allocator_traits<allocator_type>::construct(
+      alloc, pointer, ::std::forward<ValueType>(value)
+    );
+  }
+
+  template <class ValueType>
+  any (ValueType&& value, ::std::false_type&&) :
+    table { impl::get_any_dispatch<decay_t<ValueType>>() },
+    data { nullptr }
+  {
+    using value_type = decay_t<ValueType>;
+    using allocator_type = ::std::allocator<value_type>;
+    allocator_type alloc { };
+    auto pointer = ::std::allocator_traits<allocator_type>::allocate(alloc, 1);
+    ::std::allocator_traits<allocator_type>::construct(
+      alloc, pointer, ::std::forward<ValueType>(value)
+    );
+    this->data = pointer;
+  }
+
+  template <class ValueType>
+  ValueType const* cast (::std::true_type&&) const {
+    return reinterpret_cast<ValueType const*>(::std::addressof(this->data));
+  }
+
+  template <class ValueType>
+  ValueType* cast (::std::true_type&&) {
+    return reinterpret_cast<ValueType*>(::std::addressof(this->data));
+  }
+
+  template <class ValueType>
+  ValueType const* cast (::std::false_type&&) const {
+    return static_cast<ValueType const*>(this->data);
+  }
+
+  template <class ValueType>
+  ValueType* cast (::std::false_type&&) {
+    return static_cast<ValueType*>(this->data);
+  }
+
+public:
+  any (any const& that) :
+    table { that.table },
+    data { nullptr }
+  { this->table->clone(that.data, this->data); }
+
+  any (any&& that) noexcept :
+    table { that.table },
+    data { that.data }
+  {
+    that.table = impl::get_any_dispatch<void>();
+    that.data = nullptr;
+  }
+
+  any () noexcept :
+    table { impl::get_any_dispatch<void>() },
+    data { nullptr }
+  { }
+
+  template <
+    class ValueType,
+    class=enable_if_t<not ::std::is_same<any, decay_t<ValueType>>::value>
+  > any (ValueType&& value) :
+    any { ::std::forward<ValueType>(value), impl::is_small<ValueType> { } }
+  { }
+
+  ~any () noexcept { this->clear(); }
+
+  any& operator = (any const& that) {
+    any { that }.swap(*this);
+    return *this;
+  }
+
+  any& operator = (any&& that) noexcept {
+    any { ::std::move(that) }.swap(*this);
+    return *this;
+  }
+
+  template <
+    class ValueType,
+    class=enable_if_t<not ::std::is_same<any, decay_t<ValueType>>::value>
+  > any& operator = (ValueType&& value) {
+    any {
+      ::std::forward<ValueType>(value),
+      impl::is_small<ValueType> { }
+    }.swap(*this);
+    return *this;
+  }
+
+  void swap (any& that) noexcept {
+    using ::std::swap;
+    swap(this->table, that.table);
+    swap(this->data, that.data);
+  }
+
+  void clear () noexcept {
+    this->table->destroy(this->data);
+    this->table = impl::get_any_dispatch<void>();
+  }
+
+  ::std::type_info const& type () const noexcept {
+    return this->table->type();
+  }
+
+  bool empty () const noexcept {
+    return this->table == impl::get_any_dispatch<void>();
+  }
+
+};
+
+template <class ValueType>
+ValueType const* any_cast (any const* operand) noexcept {
+  return operand and operand->type() == typeid(ValueType)
+    ? operand->cast<ValueType>(impl::is_small<ValueType> { })
+    : nullptr;
+}
+
+template <class ValueType>
+ValueType* any_cast (any* operand) noexcept {
+  return operand and operand->type() == typeid(ValueType)
+    ? operand->cast<ValueType>(impl::is_small<ValueType> { })
+    : nullptr;
+}
+
+template <
+  class ValueType,
+  class=enable_if_t<
+    ::std::is_reference<ValueType>::value or
+    ::std::is_copy_constructible<ValueType>::value
+  >
+> ValueType any_cast (any const& operand) {
+  using type = remove_reference_t<ValueType>;
+  auto pointer = any_cast<add_const_t<type>>(::std::addressof(operand));
+  if (not pointer) { throw bad_any_cast { }; }
+  return *pointer;
+}
+
+template <
+  class ValueType,
+  class=enable_if_t<
+    ::std::is_reference<ValueType>::value or
+    ::std::is_copy_constructible<ValueType>::value
+  >
+> ValueType any_cast (any&& operand) {
+  using type = remove_reference_t<ValueType>;
+  auto pointer = any_cast<type>(::std::addressof(operand));
+  if (not pointer) { throw bad_any_cast { }; }
+  return *pointer;
+}
+
+template <
+  class ValueType,
+  class=enable_if_t<
+    ::std::is_reference<ValueType>::value or
+    ::std::is_copy_constructible<ValueType>::value
+  >
+> ValueType any_cast (any& operand) {
+  using type = remove_reference_t<ValueType>;
+  auto pointer = any_cast<type>(::std::addressof(operand));
+  if (not pointer) { throw bad_any_cast { }; }
+  return *pointer;
+}
+
+inline void swap (any& lhs, any& rhs) noexcept { lhs.swap(rhs); }
+
+}} /* namespace core::v1 */
+
+#endif /* CORE_ANY_HPP */
diff --git a/src/bsoncxx/third_party/core/include/core/functional.hpp b/src/bsoncxx/third_party/core/include/core/functional.hpp
new file mode 100644
index 0000000..6c59020
--- /dev/null
+++ b/src/bsoncxx/third_party/core/include/core/functional.hpp
@@ -0,0 +1,201 @@
+#ifndef CORE_FUNCTIONAL_HPP
+#define CORE_FUNCTIONAL_HPP
+
+#include <core/type_traits.hpp>
+#include <core/utility.hpp>
+#include <functional>
+#include <tuple>
+#include <array>
+
+namespace core {
+inline namespace v1 {
+
+template <class F> struct function_traits;
+
+template <class R, class... Args>
+struct function_traits<R(*)(Args...)> : function_traits<R(Args...)> { };
+
+template <class C, class R>
+struct function_traits<R(C::*)> : function_traits<R(C&)> { };
+
+template <class C, class R, class... Args>
+struct function_traits<R(C::*)(Args...)> : function_traits<R(C&, Args...)> { };
+
+template <class C, class R, class... Args>
+struct function_traits<R(C::*)(Args...) const volatile> :
+  function_traits<R(C volatile const&, Args...)>
+{ };
+
+template <class C, class R, class... Args>
+struct function_traits<R(C::*)(Args...) volatile> :
+  function_traits<R(C volatile&, Args...)>
+{ };
+
+template <class C, class R, class... Args>
+struct function_traits<R(C::*)(Args...) const> :
+  function_traits<R(C const&, Args...)>
+{ };
+
+template <class R, class... Args>
+struct function_traits<R(Args...)> {
+  using return_type = R;
+
+  using pointer = return_type(*)(Args...);
+  static constexpr ::std::size_t arity = sizeof...(Args);
+
+  template < ::std::size_t N>
+  using argument = typename ::std::tuple_element<
+    N,
+    ::std::tuple<Args...>
+  >::type;
+};
+
+template <class F> struct function_traits {
+  using functor_type = function_traits<decltype(&decay_t<F>::operator())>;
+  using return_type = typename functor_type::return_type;
+  using pointer = typename functor_type::pointer;
+  static constexpr ::std::size_t arity = functor_type::arity - 1;
+  template < ::std::size_t N>
+  using argument = typename functor_type::template argument<N>;
+};
+
+/* N3727 */
+template <class Functor, class Object, class... Args>
+auto invoke (Functor&& functor, Object&& object, Args&&... args) -> enable_if_t<
+  invokable<Functor, Object, Args...>::value,
+  decltype((object.*functor)(::core::forward<Args>(args)...))
+> { return (object.*functor)(::core::forward<Args>(args)...); }
+
+template <class Functor, class Object, class... Args>
+auto invoke (Functor&& functor, Object&& object, Args&&... args) -> enable_if_t<
+  invokable<Functor, Object, Args...>::value,
+  decltype(
+    ((*::core::forward<Object>(object)).*functor)(::core::forward<Args>(args)...)
+  )
+> {
+  return (
+    (*::core::forward<Object>(object)).*functor
+  )(::core::forward<Args>(args)...);
+}
+
+template <class Functor, class Object>
+auto invoke (Functor&& functor, Object&& object) -> enable_if_t<
+  invokable<Functor, Object>::value,
+  decltype(object.*functor)
+> { return object.*functor; }
+
+template <class Functor, class Object>
+auto invoke (Functor&& functor, Object&& object) -> enable_if_t<
+  invokable<Functor, Object>::value,
+  decltype((*::core::forward<Object>(object)).*functor)
+> { return (*::core::forward<Object>(object)).*functor; }
+
+template <class Functor, class... Args>
+constexpr auto invoke (Functor&& functor, Args&&... args) -> enable_if_t<
+  invokable<Functor, Args...>::value,
+  decltype(::core::forward<Functor>(functor)(::core::forward<Args>(args)...))
+> { return ::core::forward<Functor>(functor)(::core::forward<Args>(args)...); }
+
+namespace impl {
+
+template <class Functor, class U, ::std::size_t... I>
+auto unpack (
+  Functor&& functor,
+  U&& unpackable,
+  index_sequence<I...>&&
+) -> invoke_of_t<
+  Functor,
+  decltype(::std::get<I>(::std::forward<U>(unpackable)))...
+> {
+  return ::core::v1::invoke(::std::forward<Functor>(functor),
+    ::std::get<I>(::std::forward<U>(unpackable))...
+  );
+}
+
+template <class U, ::std::size_t... I>
+auto unpack (U&& unpackable, index_sequence<I...>&&) -> invoke_of_t<
+  decltype(::std::get<I>(::std::forward<U>(unpackable)))...
+> {
+  return ::core::v1::invoke(::std::get<I>(::std::forward<U>(unpackable))...);
+}
+
+template <class Functor, class U, ::std::size_t... I>
+auto runpack (
+  Functor&& functor,
+  U&& runpackable,
+  index_sequence<I...>&&
+) -> invoke_of_t<Functor, decltype(::std::forward<U>(runpackable).at(I))...> {
+  return ::core::v1::invoke(
+    ::std::forward<Functor>(functor),
+    ::std::forward<U>(runpackable).at(I)...);
+}
+
+} /* namespace impl */
+
+struct unpack_t final { };
+constexpr unpack_t unpack { };
+
+struct runpack_t final { };
+constexpr runpack_t runpack { };
+
+template <class Functor, class Unpackable>
+auto invoke (unpack_t, Functor&& functor, Unpackable&& unpackable) ->
+enable_if_t<
+  is_unpackable<decay_t<Unpackable>>::value,
+  decltype(
+    impl::unpack(
+      ::std::forward<Functor>(functor),
+      ::std::forward<Unpackable>(unpackable),
+      make_index_sequence<::std::tuple_size<decay_t<Unpackable>>::value> { }
+    )
+  )
+> {
+  return impl::unpack(
+    ::std::forward<Functor>(functor),
+    ::std::forward<Unpackable>(unpackable),
+    make_index_sequence<::std::tuple_size<decay_t<Unpackable>>::value> { }
+  );
+}
+
+template <class Unpackable>
+auto invoke (unpack_t, Unpackable&& unpackable) ->
+enable_if_t<
+  is_unpackable<decay_t<Unpackable>>::value,
+  decltype(
+    impl::unpack(
+      ::std::forward<Unpackable>(unpackable),
+      make_index_sequence<::std::tuple_size<decay_t<Unpackable>>::value> { }
+    )
+  )
+> {
+  return impl::unpack(
+    ::std::forward<Unpackable>(unpackable),
+    make_index_sequence<::std::tuple_size<decay_t<Unpackable>>::value> { }
+  );
+}
+
+template <class Functor, class Runpackable>
+auto invoke (
+  runpack_t,
+  Functor&& functor,
+  Runpackable&& unpackable
+) -> enable_if_t<
+  is_runpackable<decay_t<Runpackable>>::value,
+  decltype(
+    impl::runpack(
+      ::std::forward<Functor>(functor),
+      ::std::forward<Runpackable>(unpackable),
+      make_index_sequence<function_traits<Functor>::arity> { }
+    )
+  )
+> {
+  return impl::runpack(
+    ::std::forward<Functor>(functor),
+    ::std::forward<Runpackable>(unpackable),
+    make_index_sequence<function_traits<Functor>::arity> { }
+  );
+}
+
+}} /* namespace core::v1 */
+
+#endif /* CORE_FUNCTIONAL_HPP */
diff --git a/src/bsoncxx/third_party/core/include/core/iterator.hpp b/src/bsoncxx/third_party/core/include/core/iterator.hpp
new file mode 100644
index 0000000..af39b97
--- /dev/null
+++ b/src/bsoncxx/third_party/core/include/core/iterator.hpp
@@ -0,0 +1,164 @@
+#ifndef CORE_ITERATOR_HPP
+#define CORE_ITERATOR_HPP
+
+#include <functional>
+#include <iterator>
+#include <ostream>
+
+namespace core {
+inline namespace v1 {
+
+/* capacity */
+template <class Container>
+constexpr auto size (Container const& container) noexcept -> decltype(
+  container.size()
+) { return container.size(); }
+
+template <class T, ::std::size_t N>
+constexpr ::std::size_t size (T const (&)[N]) noexcept { return N; }
+
+template <class Container>
+constexpr bool empty (Container const& container) noexcept {
+  return container.empty();
+}
+
+template <class T, std::size_t N>
+constexpr bool empty (T const (&)[N]) noexcept { return false; }
+
+/* element access */
+template <class Container>
+constexpr auto front (Container const& container) -> decltype(
+  container.front()
+) { return container.front(); }
+
+template <class Container>
+constexpr auto front (Container& container) -> decltype(container.front()) {
+  return container.front();
+}
+
+template <class T, ::std::size_t N>
+constexpr T const& front (T const (&array)[N]) noexcept { return array[0]; }
+
+template <class T, ::std::size_t N>
+constexpr T& front (T (&array)[N]) noexcept { return array[0]; }
+
+template <class Container>
+constexpr auto back (Container const& container) -> decltype(
+  container.back()
+) { return container.back(); }
+
+template <class Container>
+constexpr auto back (Container& container) -> decltype(container.back()) {
+  return container.back();
+}
+
+template <class T, ::std::size_t N>
+constexpr T const& back (T const (&array)[N]) noexcept { return array[N - 1]; }
+
+template <class T, ::std::size_t N>
+constexpr T& back (T (&array)[N]) noexcept { return array[N - 1]; }
+
+/* data access */
+template <class Container>
+constexpr auto data (Container const& container) noexcept -> decltype(
+  container.data()
+) { return container.data(); }
+
+template <class Container>
+constexpr auto data (Container& container) noexcept -> decltype(
+  container.data()
+) { return container.data(); }
+
+template <class T, ::std::size_t N>
+constexpr T const* data (T const (&array)[N]) noexcept { return array; }
+
+template <class T, ::std::size_t N>
+constexpr T* data (T (&array)[N]) noexcept { return array; }
+
+/* iteration */
+template <class Container>
+auto cbegin (Container const& container) -> decltype(::std::begin(container)) {
+  return ::std::begin(container);
+}
+
+template <class Container>
+auto cend (Container const& container) -> decltype(::std::end(container)) {
+  return ::std::end(container);
+}
+
+template <class Container>
+auto rbegin (Container const& container) -> decltype(container.rbegin()) {
+  return container.rbegin();
+}
+
+template <class Container>
+auto rbegin (Container& container) -> decltype(container.rbegin()) {
+  return container.rbegin();
+}
+
+template <class Container>
+auto crbegin (Container const& container) -> decltype(rbegin(container)) {
+  return rbegin(container);
+}
+
+template <class Container>
+auto rend (Container const& container) -> decltype(container.rend()) {
+  return container.rend();
+}
+
+template <class Container>
+auto rend (Container& container) -> decltype(container.rend()) {
+  return container.rend();
+}
+
+template <class Container>
+auto crend (Container const& container) -> decltype(rend(container)) {
+  return rend(container);
+}
+
+template <
+  class T,
+  class CharT=char,
+  class Traits=::std::char_traits<CharT>
+> struct infix_ostream_iterator final : ::std::iterator<
+  ::std::output_iterator_tag,
+  void,
+  void,
+  void,
+  void
+> {
+  using ostream_type = ::std::basic_ostream<CharT, Traits>;
+  using traits_type = Traits;
+  using char_type = CharT;
+
+  infix_ostream_iterator (ostream_type& os) :
+    infix_ostream_iterator { os, nullptr }
+  { }
+
+  infix_ostream_iterator (ostream_type& os, char_type const* delimiter) :
+    os { os },
+    delimiter { delimiter },
+    first { true }
+  { }
+
+  infix_ostream_iterator& operator = (T const& item) {
+    if (not first and delimiter) { this->os.get() << delimiter; }
+    os.get() << item;
+    this->first = false;
+    return *this;
+  }
+
+  infix_ostream_iterator& operator ++ (int) { return *this; }
+  infix_ostream_iterator& operator ++ () { return *this; }
+  infix_ostream_iterator& operator * () { return *this; }
+
+private:
+  ::std::reference_wrapper<ostream_type> os;
+  char_type const* delimiter;
+  bool first;
+
+};
+
+}} /* namespace core::v1 */
+
+#endif /* CORE_ITERATOR_HPP */
diff --git a/src/bsoncxx/third_party/core/include/core/memory.hpp b/src/bsoncxx/third_party/core/include/core/memory.hpp
new file mode 100644
index 0000000..129a14e
--- /dev/null
+++ b/src/bsoncxx/third_party/core/include/core/memory.hpp
@@ -0,0 +1,804 @@
+#ifndef CORE_MEMORY_HPP
+#define CORE_MEMORY_HPP
+
+#include <stdexcept>
+#include <typeinfo>
+#include <memory>
+#include <tuple>
+
+#include <cstddef>
+
+#include <core/type_traits.hpp>
+
+namespace core {
+inline namespace v1 {
+namespace impl {
+
+template <class T>
+using deep_lvalue = conditional_t<
+  ::std::is_reference<T>::value, T, T const&
+>;
+
+template <class T, class D>
+class pointer {
+  template <class U>
+  static auto check (typename U::pointer*) noexcept -> typename U::pointer;
+  template <class> static auto check (...) noexcept(false) -> T*;
+
+  using deleter_type = remove_reference_t<D>;
+
+public:
+  static constexpr bool value = noexcept(check<deleter_type>(nullptr));
+  using type = decltype(check<deleter_type>(nullptr));
+};
+
+} /* namespace impl */
+
+/* poly_ptr copier */
+template <class T, class D, class U>
+::std::unique_ptr<T, D> default_poly_copy (
+  ::std::unique_ptr<T, D> const& ptr
+) {
+  auto value = *dynamic_cast<U*>(ptr.get());
+  auto const& deleter = ptr.get_deleter();
+  return ::std::unique_ptr<T, D> { new U { ::std::move(value) }, deleter };
+}
+
+/* null-state poly_ptr copier (don't copy that poly!) */
+template <class T, class D>
+::std::unique_ptr<T, D> null_poly_copy (
+  ::std::unique_ptr<T, D> const&
+) noexcept { return ::std::unique_ptr<T, D> { }; }
+
+/* deep_ptr copier */
+template <class T>
+struct default_copy {
+  using pointer = T*;
+
+  constexpr default_copy () = default;
+  template <class U> default_copy (default_copy<U> const&) noexcept { }
+
+  pointer operator ()(pointer const ptr) const { return new T { *ptr }; }
+};
+
+struct bad_polymorphic_reset : ::std::logic_error {
+  using ::std::logic_error::logic_error;
+};
+
+template <class T, class Deleter=::std::default_delete<T>>
+struct poly_ptr final {
+  using unique_type = ::std::unique_ptr<T, Deleter>;
+  using element_type = typename unique_type::element_type;
+  using deleter_type = typename unique_type::deleter_type;
+  using copier_type = unique_type (*)(unique_type const&);
+  using pointer = typename unique_type::pointer;
+
+  template <class U>
+  explicit poly_ptr (U* ptr) noexcept :
+    poly_ptr { ptr, deleter_type { } }
+  { }
+
+  template <class U, class E>
+  explicit poly_ptr (
+    ::std::unique_ptr<U, E>&& ptr,
+    copier_type copier=::std::addressof(
+      default_poly_copy<element_type, deleter_type, U>
+    )
+  ) noexcept :
+    copier { copier },
+    ptr { ::std::move(ptr) }
+  {
+    constexpr bool abstract = ::std::is_abstract<U>::value;
+    constexpr bool base = ::std::is_base_of<element_type, U>::value;
+
+    static_assert(not abstract, "cannot create poly_ptr with abstract ptr");
+    static_assert(base, "cannot create poly_ptr with non-derived type");
+  }
+
+  template <class U, class E>
+  poly_ptr (
+    U* ptr, E&& deleter,
+    copier_type copier=::std::addressof(
+      default_poly_copy<element_type, deleter_type, U>
+    )
+  ) noexcept :
+    poly_ptr {
+      unique_type { ::std::move(ptr), ::std::forward<E>(deleter) }, copier
+    }
+  { }
+
+  poly_ptr (poly_ptr const& that) :
+    copier { that.copier },
+    ptr { that.copier(that.ptr) }
+  { }
+
+  poly_ptr (poly_ptr&& that) noexcept :
+    copier { ::std::move(that.copier) },
+    ptr { ::std::move(that.ptr) }
+  { that.copier = null_poly_copy<element_type, deleter_type>; }
+
+  constexpr poly_ptr () noexcept { }
+
+  ~poly_ptr () noexcept { }
+
+  template <class U, class E>
+  poly_ptr& operator = (::std::unique_ptr<U, E>&& ptr) {
+    poly_ptr { ::std::move(ptr) }.swap(*this);
+    return *this;
+  }
+
+  template <class U>
+  poly_ptr& operator = (U* ptr) {
+    poly_ptr { ptr }.swap(*this);
+    return *this;
+  }
+
+  poly_ptr& operator = (::std::nullptr_t) noexcept {
+    this->reset();
+    return *this;
+  }
+
+  poly_ptr& operator = (poly_ptr const& that) {
+    return *this = poly_ptr { that };
+  }
+
+  poly_ptr& operator = (poly_ptr&& that) noexcept {
+    poly_ptr { ::std::move(that) }.swap(*this);
+    return *this;
+  }
+
+  explicit operator bool () const noexcept { return bool(this->ptr); }
+
+  add_lvalue_reference_t<element_type> operator * () const noexcept {
+    return *this->ptr;
+  }
+
+  pointer operator -> () const noexcept { return this->ptr.get(); }
+
+  pointer get () const noexcept { return this->ptr.get(); }
+
+  deleter_type const& get_deleter () const noexcept {
+    return this->ptr.get_deleter();
+  }
+
+  deleter_type& get_deleter () noexcept { return this->ptr.get_deleter(); }
+
+  copier_type const& get_copier () const noexcept { return this->copier; }
+  copier_type& get_copier () noexcept { return this->copier; }
+
+  pointer release () noexcept {
+    this->copier = null_poly_copy<element_type, deleter_type>;
+    return this->ptr.release();
+  }
+
+  void reset (pointer ptr = pointer { }) {
+    constexpr auto invalid = "cannot reset null poly_ptr with valid pointer";
+    constexpr auto type = "cannot reset poly_ptr with different type";
+
+    if (ptr and not this->ptr) { throw bad_polymorphic_reset { invalid }; }
+    if (ptr and typeid(*this->ptr) != typeid(*ptr)) {
+      throw bad_polymorphic_reset { type };
+    }
+
+    this->ptr.reset(ptr);
+    if (not ptr) { this->copier = null_poly_copy<element_type, deleter_type>; }
+  }
+
+  void swap (poly_ptr& that) noexcept {
+    using ::std::swap;
+    swap(this->get_copier(), that.get_copier());
+    swap(this->ptr, that.ptr);
+  }
+
+private:
+  static_assert(
+    ::std::is_polymorphic<element_type>::value,
+    "cannot create a poly_ptr with a non-polymorphic type"
+  );
+
+  copier_type copier { null_poly_copy<element_type, deleter_type> };
+  unique_type ptr;
+};
+
+template <
+  class T,
+  class Deleter=::std::default_delete<T>,
+  class Copier=default_copy<T>
+> struct deep_ptr final {
+
+  using element_type = T;
+  using deleter_type = Deleter;
+  using copier_type = Copier;
+  using pointer = typename impl::pointer<element_type, deleter_type>::type;
+
+  static_assert(
+    ::std::is_same<result_of_t<copier_type(pointer)>, pointer>::value,
+    "deleter_type and copier_type have differing pointer types"
+  );
+
+  using data_type = ::std::tuple<pointer, deleter_type, copier_type>;
+
+  deep_ptr (
+    pointer ptr,
+    impl::deep_lvalue<deleter_type> deleter,
+    impl::deep_lvalue<copier_type> copier
+  ) noexcept :
+    data { ptr, deleter, copier }
+  { }
+
+  deep_ptr (
+    pointer ptr,
+    remove_reference_t<deleter_type>&& deleter,
+    remove_reference_t<copier_type>&& copier
+  ) noexcept :
+    data { ::std::move(ptr), ::std::move(deleter), ::std::move(copier) }
+  { }
+
+  template <class U, class E>
+  deep_ptr (::std::unique_ptr<U, E>&& that) noexcept :
+    deep_ptr {
+      that.release(),
+      ::std::move(that.get_deleter()),
+      copier_type { }
+    }
+  { }
+
+  explicit deep_ptr (pointer ptr) noexcept :
+    deep_ptr { ptr, deleter_type { }, copier_type { } }
+  { }
+
+  constexpr deep_ptr (::std::nullptr_t) noexcept : deep_ptr { } { }
+
+  deep_ptr (deep_ptr const& that) :
+    deep_ptr {
+      that.get() ? that.get_copier()(that.get()) : that.get(),
+      that.get_deleter(),
+      that.get_copier()
+    }
+  { }
+
+  deep_ptr (deep_ptr&& that) noexcept :
+    data {
+      that.release(),
+      ::std::move(that.get_deleter()),
+      ::std::move(that.get_copier())
+    }
+  { }
+
+  constexpr deep_ptr () noexcept : data { } { }
+
+  ~deep_ptr () noexcept {
+    auto& ptr = ::std::get<0>(this->data);
+    if (not ptr) { return; }
+    this->get_deleter()(ptr);
+    ptr = nullptr;
+  }
+
+  deep_ptr& operator = (::std::nullptr_t) noexcept {
+    this->reset();
+    return *this;
+  }
+
+  deep_ptr& operator = (deep_ptr const& that) {
+    return *this = deep_ptr { that };
+  }
+
+  deep_ptr& operator = (deep_ptr&& that) noexcept {
+    deep_ptr { ::std::move(that) }.swap(*this);
+    return *this;
+  }
+
+  explicit operator bool () const noexcept { return this->get(); }
+
+  add_lvalue_reference_t<element_type> operator * () const noexcept {
+    return *this->get();
+  }
+  pointer operator -> () const noexcept { return this->get(); }
+  pointer get () const noexcept { return ::std::get<0>(this->data); }
+
+  deleter_type const& get_deleter () const noexcept {
+    return ::std::get<1>(this->data);
+  }
+
+  deleter_type& get_deleter () noexcept { return ::std::get<1>(this->data); }
+
+  copier_type const& get_copier () const noexcept {
+    return ::std::get<2>(this->data);
+  }
+
+  copier_type& get_copier () noexcept { return ::std::get<2>(this->data); }
+
+  pointer release () noexcept {
+    auto ptr = this->get();
+    ::std::get<0>(this->data) = nullptr;
+    return ptr;
+  }
+
+  void reset (pointer ptr = pointer { }) noexcept {
+    using ::std::swap;
+    swap(::std::get<0>(this->data), ptr);
+    if (not ptr) { return; }
+    this->get_deleter()(ptr);
+  }
+
+  void swap (deep_ptr& that) noexcept(is_nothrow_swappable<data_type>::value) {
+    using ::std::swap;
+    swap(this->data, that.data);
+  }
+
+private:
+  data_type data;
+};
+
+template <class W>
+struct observer_ptr final {
+  using element_type = W;
+
+  using const_pointer = add_pointer_t<add_const_t<element_type>>;
+  using pointer = add_pointer_t<element_type>;
+
+  using const_reference = add_lvalue_reference_t<add_const_t<element_type>>;
+  using reference = add_lvalue_reference_t<element_type>;
+
+  constexpr observer_ptr (::std::nullptr_t) noexcept : ptr { nullptr } { }
+  explicit observer_ptr (pointer ptr) noexcept : ptr { ptr } { }
+
+  template <
+    class T,
+    class=enable_if_t< ::std::is_convertible<pointer, add_pointer_t<T>>::value>
+  > explicit observer_ptr (add_pointer_t<T> ptr) noexcept :
+    ptr { dynamic_cast<pointer>(ptr) }
+  { }
+
+  template <
+    class T,
+    class=enable_if_t< ::std::is_convertible<pointer, add_pointer_t<T>>::value>
+  > observer_ptr (observer_ptr<T> const& that) noexcept :
+    observer_ptr { that.get() }
+  { }
+
+  constexpr observer_ptr () noexcept : observer_ptr { nullptr } { }
+  ~observer_ptr () noexcept { this->ptr = nullptr; }
+
+  template <
+    class T,
+    class=enable_if_t< ::std::is_convertible<pointer, add_pointer_t<T>>::value>
+  > observer_ptr& operator = (add_pointer_t<T> ptr) noexcept {
+    observer_ptr { ptr }.swap(*this);
+    return *this;
+  }
+
+  template <
+    class T,
+    class=enable_if_t< ::std::is_convertible<pointer, add_pointer_t<T>>::value>
+  > observer_ptr& operator = (observer_ptr<T> const& that) noexcept {
+    observer_ptr { that }.swap(*this);
+    return *this;
+  }
+
+  observer_ptr& operator = (::std::nullptr_t) noexcept {
+    this->reset();
+    return *this;
+  }
+
+  void swap (observer_ptr& that) noexcept {
+    using ::std::swap;
+    swap(this->ptr, that.ptr);
+  }
+
+  explicit operator const_pointer () const noexcept { return this->get(); }
+  explicit operator pointer () noexcept { return this->get(); }
+  explicit operator bool () noexcept { return this->get(); }
+
+  reference operator * () const noexcept { return *this->get(); }
+  pointer operator -> () const noexcept { return this->get(); }
+  pointer get () const noexcept { return this->ptr; }
+
+  pointer release () noexcept {
+    auto result = this->get();
+    this->reset();
+    return result;
+  }
+
+  void reset (pointer ptr = nullptr) noexcept { this->ptr = ptr; }
+
+private:
+  pointer ptr;
+};
+
+/* poly_ptr convention for type and deleter is:
+ * T, D : U, E
+ */
+template <class T, class D, class U, class E>
+bool operator == (
+  poly_ptr<T, D> const& lhs,
+  poly_ptr<U, E> const& rhs
+) noexcept { return lhs.get() == rhs.get(); }
+
+template <class T, class D, class U, class E>
+bool operator != (
+  poly_ptr<T, D> const& lhs,
+  poly_ptr<U, E> const& rhs
+) noexcept { return lhs.get() != rhs.get(); }
+
+template <class T, class D, class U, class E>
+bool operator >= (
+  poly_ptr<T, D> const& lhs,
+  poly_ptr<U, E> const& rhs
+) noexcept { return not (lhs < rhs); }
+
+template <class T, class D, class U, class E>
+bool operator <= (
+  poly_ptr<T, D> const& lhs,
+  poly_ptr<U, E> const& rhs
+) noexcept { return not (rhs < lhs); }
+
+template <class T, class D, class U, class E>
+bool operator > (
+  poly_ptr<T, D> const& lhs,
+  poly_ptr<U, E> const& rhs
+) noexcept { return rhs < lhs; }
+
+template <class T, class D, class U, class E>
+bool operator < (
+  poly_ptr<T, D> const& lhs,
+  poly_ptr<U, E> const& rhs
+) noexcept {
+  using common_type = typename ::std::common_type<
+    typename poly_ptr<T, D>::pointer,
+    typename poly_ptr<U, E>::pointer
+  >::type;
+  return ::std::less<common_type> { }(lhs.get(), rhs.get());
+}
+
+/* deep_ptr convention for type, deleter, copier is
+ * T, D, C : U, E, K
+ */
+template <class T, class D, class C, class U, class E, class K>
+bool operator == (
+  deep_ptr<T, D, C> const& lhs,
+  deep_ptr<U, E, K> const& rhs
+) noexcept { return lhs.get() == rhs.get(); }
+
+template <class T, class D, class C, class U, class E, class K>
+bool operator != (
+  deep_ptr<T, D, C> const& lhs,
+  deep_ptr<U, E, K> const& rhs
+) noexcept { return lhs.get() != rhs.get(); }
+
+template <class T, class D, class C, class U, class E, class K>
+bool operator >= (
+  deep_ptr<T, D, C> const& lhs,
+  deep_ptr<U, E, K> const& rhs
+) noexcept { return not (lhs < rhs); }
+
+template <class T, class D, class C, class U, class E, class K>
+bool operator <= (
+  deep_ptr<T, D, C> const& lhs,
+  deep_ptr<U, E, K> const& rhs
+) noexcept { return not (rhs < lhs); }
+
+template <class T, class D, class C, class U, class E, class K>
+bool operator > (
+  deep_ptr<T, D, C> const& lhs,
+  deep_ptr<U, E, K> const& rhs
+) noexcept { return rhs < lhs; }
+
+template <class T, class D, class C, class U, class E, class K>
+bool operator < (
+  deep_ptr<T, D, C> const& lhs,
+  deep_ptr<U, E, K> const& rhs
+) noexcept {
+  using common_type = common_type_t<
+    typename deep_ptr<T, D, C>::pointer,
+    typename deep_ptr<U, E, K>::pointer
+  >;
+  return ::std::less<common_type> { }(lhs.get(), rhs.get());
+}
+
+/* poly_ptr nullptr operator overloads */
+template <class T, class D>
+bool operator == (poly_ptr<T, D> const& lhs, ::std::nullptr_t) noexcept {
+  return not lhs;
+}
+
+template <class T, class D>
+bool operator == (::std::nullptr_t, poly_ptr<T, D> const& rhs) noexcept {
+  return not rhs;
+}
+
+template <class T, class D>
+bool operator != (poly_ptr<T, D> const& lhs, ::std::nullptr_t) noexcept {
+  return bool(lhs);
+}
+
+template <class T, class D>
+bool operator != (::std::nullptr_t, poly_ptr<T, D> const& rhs) noexcept {
+  return bool(rhs);
+}
+
+template <class T, class D>
+bool operator >= (poly_ptr<T, D> const& lhs, ::std::nullptr_t) noexcept {
+  return not (lhs < nullptr);
+}
+
+template <class T, class D>
+bool operator >= (::std::nullptr_t, poly_ptr<T, D> const& rhs) noexcept {
+  return not (nullptr < rhs);
+}
+
+template <class T, class D>
+bool operator <= (poly_ptr<T, D> const& lhs, ::std::nullptr_t) noexcept {
+  return not (nullptr < lhs);
+}
+
+template <class T, class D>
+bool operator <= (::std::nullptr_t, poly_ptr<T, D> const& rhs) noexcept {
+  return not (rhs < nullptr);
+}
+
+template <class T, class D>
+bool operator > (poly_ptr<T, D> const& lhs, ::std::nullptr_t) noexcept {
+  return nullptr < lhs;
+}
+
+template <class T, class D>
+bool operator > (::std::nullptr_t, poly_ptr<T, D> const& rhs) noexcept {
+  return rhs < nullptr;
+}
+
+template <class T, class D>
+bool operator < (poly_ptr<T, D> const& lhs, ::std::nullptr_t) noexcept {
+  using pointer = typename poly_ptr<T, D>::pointer;
+  return ::std::less<pointer> { }(lhs.get(), nullptr);
+}
+
+template <class T, class D>
+bool operator < (::std::nullptr_t, poly_ptr<T, D> const& rhs) noexcept {
+  using pointer = typename poly_ptr<T, D>::pointer;
+  return ::std::less<pointer> { }(nullptr, rhs.get());
+}
+
+/* deep_ptr nullptr operator overloads */
+template <class T, class D, class C>
+bool operator == (deep_ptr<T, D, C> const& lhs, ::std::nullptr_t) noexcept {
+  return not lhs;
+}
+
+template <class T, class D, class C>
+bool operator == (::std::nullptr_t, deep_ptr<T, D, C> const& rhs) noexcept {
+  return not rhs;
+}
+
+template <class T, class D, class C>
+bool operator != (deep_ptr<T, D, C> const& lhs, ::std::nullptr_t) noexcept {
+  return bool(lhs);
+}
+
+template <class T, class D, class C>
+bool operator != (::std::nullptr_t, deep_ptr<T, D, C> const& rhs) noexcept {
+  return bool(rhs);
+}
+
+template <class T, class D, class C>
+bool operator >= (deep_ptr<T, D, C> const& lhs, ::std::nullptr_t) noexcept {
+  return not (lhs < nullptr);
+}
+
+template <class T, class D, class C>
+bool operator >= (::std::nullptr_t, deep_ptr<T, D, C> const& rhs) noexcept {
+  return not (nullptr < rhs);
+}
+
+template <class T, class D, class C>
+bool operator <= (deep_ptr<T, D, C> const& lhs, ::std::nullptr_t) noexcept {
+  return not (nullptr < lhs);
+}
+
+template <class T, class D, class C>
+bool operator <= (::std::nullptr_t, deep_ptr<T, D, C> const& rhs) noexcept {
+  return not (rhs < nullptr);
+}
+
+template <class T, class D, class C>
+bool operator > (deep_ptr<T, D, C> const& lhs, ::std::nullptr_t) noexcept {
+  return nullptr < lhs;
+}
+
+template <class T, class D, class C>
+bool operator > (::std::nullptr_t, deep_ptr<T, D, C> const& rhs) noexcept {
+  return rhs < nullptr;
+}
+
+template <class T, class D, class C>
+bool operator < (deep_ptr<T, D, C> const& lhs, ::std::nullptr_t) noexcept {
+  using pointer = typename deep_ptr<T, D, C>::pointer;
+  return ::std::less<pointer> { }(lhs.get(), nullptr);
+}
+
+template <class T, class D, class C>
+bool operator < (::std::nullptr_t, deep_ptr<T, D, C> const& rhs) noexcept {
+  using pointer = typename deep_ptr<T, D, C>::pointer;
+  return ::std::less<pointer> { }(nullptr, rhs.get());
+}
+
+/* observer_ptr and nullptr overloads */
+template <class T, class U>
+bool operator == (
+  observer_ptr<T> const& lhs,
+  observer_ptr<U> const& rhs
+) noexcept { return lhs.get() == rhs.get(); }
+
+template <class T, class U>
+bool operator != (
+  observer_ptr<T> const& lhs,
+  observer_ptr<U> const& rhs
+) noexcept { return lhs.get() != rhs.get(); }
+
+template <class T>
+bool operator == (observer_ptr<T> const& lhs, ::std::nullptr_t) noexcept {
+  return lhs.get() == nullptr;
+}
+
+template <class T>
+bool operator != (observer_ptr<T> const& lhs, ::std::nullptr_t) noexcept {
+  return lhs.get() != nullptr;
+}
+
+template <class T>
+bool operator == (::std::nullptr_t, observer_ptr<T> const& rhs) noexcept {
+  return nullptr == rhs.get();
+}
+
+template <class T>
+bool operator != (::std::nullptr_t, observer_ptr<T> const& rhs) noexcept {
+  return nullptr != rhs.get();
+}
+
+template <class T, class U>
+bool operator >= (
+  observer_ptr<T> const& lhs,
+  observer_ptr<U> const& rhs
+) noexcept { return lhs.get() >= rhs.get(); }
+
+template <class T, class U>
+bool operator <= (
+  observer_ptr<T> const& lhs,
+  observer_ptr<U> const& rhs
+) noexcept { return lhs.get() <= rhs.get(); }
+
+template <class T, class U>
+bool operator > (
+  observer_ptr<T> const& lhs,
+  observer_ptr<U> const& rhs
+) noexcept { return lhs.get() > rhs.get(); }
+
+template <class T, class U>
+bool operator < (
+  observer_ptr<T> const& lhs,
+  observer_ptr<U> const& rhs
+) noexcept { return lhs.get() < rhs.get(); }
+
+/* make_observer */
+template <class W>
+observer_ptr<W> make_observer (W* ptr) noexcept {
+  return observer_ptr<W> { ptr };
+}
+
+template <class W, class D>
+observer_ptr<W> make_observer (::std::unique_ptr<W, D> const& ptr) noexcept {
+  return observer_ptr<W> { ptr.get() };
+}
+
+template <class W>
+observer_ptr<W> make_observer (::std::shared_ptr<W> const& ptr) noexcept {
+  return observer_ptr<W> { ptr.get() };
+}
+
+template <class W>
+observer_ptr<W> make_observer (::std::weak_ptr<W> const& ptr) noexcept {
+  return make_observer(ptr.lock());
+}
+
+template <class W, class C, class D>
+observer_ptr<W> make_observer (deep_ptr<W, C, D> const& ptr) noexcept {
+  return observer_ptr<W> { ptr.get() };
+}
+
+template <class W, class D>
+observer_ptr<W> make_observer (poly_ptr<W, D> const& ptr) noexcept {
+  return observer_ptr<W> { ptr.get() };
+}
+
+/* make_poly */
+template <
+  class T,
+  class U,
+  class=enable_if_t<
+    ::std::is_polymorphic<T>::value and ::std::is_base_of<T, U>::value
+  >
+> auto make_poly (U&& value) -> poly_ptr<T> {
+  return poly_ptr<T> { new U { ::std::forward<U>(value) } };
+}
+
+/* make_deep */
+template <
+  class T,
+  class=enable_if_t<not ::std::is_array<T>::value>,
+  class... Args
+> auto make_deep (Args&&... args) -> deep_ptr<T> {
+  return deep_ptr<T> { new T { ::std::forward<Args>(args)... } };
+}
+
+/* make_unique */
+template <
+  class Type,
+  class=enable_if_t<not ::std::is_array<Type>::value>,
+  class... Args
+> auto make_unique(Args&&... args) -> ::std::unique_ptr<Type> {
+  return ::std::unique_ptr<Type> {
+    new Type { ::std::forward<Args>(args)... }
+  };
+}
+
+template <
+  class Type,
+  class=enable_if_t< ::std::is_array<Type>::value>,
+  class=enable_if_t<not ::std::extent<Type>::value>
+> auto make_unique(::std::size_t size) -> ::std::unique_ptr<Type> {
+  return ::std::unique_ptr<Type> { new remove_extent_t<Type>[size] { } };
+}
+
+template <
+  class Type,
+  class=enable_if_t< ::std::is_array<Type>::value>,
+  class=enable_if_t< ::std::extent<Type>::value>,
+  class... Args
+> auto make_unique(Args&&...) -> void = delete;
+
+template <class T, class D>
+void swap (poly_ptr<T, D>& lhs, poly_ptr<T, D>& rhs) noexcept(
+  noexcept(lhs.swap(rhs))
+) { lhs.swap(rhs); }
+
+template <class T, class D, class C>
+void swap (deep_ptr<T, D, C>& lhs, deep_ptr<T, D, C>& rhs) noexcept(
+  noexcept(lhs.swap(rhs))
+) { lhs.swap(rhs); }
+
+template <class W>
+void swap (observer_ptr<W>& lhs, observer_ptr<W>& rhs) noexcept(
+  noexcept(lhs.swap(rhs))
+) { lhs.swap(rhs); }
+
+}} /* namespace core::v1 */
+
+namespace std {
+
+template <class T, class D>
+struct hash<core::v1::poly_ptr<T, D>> {
+  using value_type = core::v1::poly_ptr<T, D>;
+  size_t operator ()(value_type const& value) const noexcept {
+    return hash<typename value_type::pointer>{ }(value.get());
+  }
+};
+
+template <class T, class Deleter, class Copier>
+struct hash<core::v1::deep_ptr<T, Deleter, Copier>> {
+  using value_type = core::v1::deep_ptr<T, Deleter, Copier>;
+  size_t operator ()(value_type const& value) const noexcept {
+    return hash<typename value_type::pointer> { }(value.get());
+  }
+};
+
+template <class W>
+struct hash<core::v1::observer_ptr<W>> {
+  using value_type = core::v1::observer_ptr<W>;
+  size_t operator ()(value_type const& value) const noexcept {
+    return hash<typename value_type::pointer> { }(value.get());
+  }
+};
+
+} /* namespace std */
+
+#endif /* CORE_MEMORY_HPP */
diff --git a/src/bsoncxx/third_party/core/include/core/numeric.hpp b/src/bsoncxx/third_party/core/include/core/numeric.hpp
new file mode 100644
index 0000000..22cc6ca
--- /dev/null
+++ b/src/bsoncxx/third_party/core/include/core/numeric.hpp
@@ -0,0 +1,156 @@
+#ifndef CORE_NUMERIC_HPP
+#define CORE_NUMERIC_HPP
+
+#include <numeric>
+
+#include <core/range.hpp>
+
+namespace core {
+inline namespace v1 {
+
+template <class Range, class T>
+auto iota (Range&& rng, T&& value) -> enable_if_t<is_range<Range>::value> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_forward = decltype(range)::is_forward;
+  static_assert(is_forward, "iota requires ForwardIterators");
+  return ::std::iota(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<T>(value)
+  );
+}
+
+template <class Range, class T>
+auto accumulate (Range&& rng, T&& init) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<T>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "accumulate requires InputIterators");
+  return ::std::accumulate(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<T>(init)
+  );
+}
+
+template <class Range, class T, class BinaryOp>
+auto accumulate (Range&& rng, T&& init, BinaryOp&& op) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<T>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "accumulate requires InputIterators");
+  return ::std::accumulate(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<T>(init),
+    ::std::forward<BinaryOp>(op)
+  );
+}
+
+template <class Range, class InputIt, class T>
+auto inner_product (Range&& rng, InputIt&& it, T&& value) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<T>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "inner_product requires InputIterators");
+  return ::std::inner_product(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<InputIt>(it),
+    ::std::forward<T>(value)
+  );
+}
+
+template <class Range, class InputIt, class T, class BinaryOp, class BinaryOp2>
+auto inner_product (
+  Range&& rng,
+  InputIt&& it,
+  T&& value,
+  BinaryOp&& op,
+  BinaryOp2&& op2
+) -> enable_if_t<is_range<Range>::value, decay_t<T>> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "inner_product requires InputIterators");
+  return ::std::inner_product(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<InputIt>(it),
+    ::std::forward<T>(value),
+    ::std::forward<BinaryOp>(op),
+    ::std::forward<BinaryOp2>(op2)
+  );
+}
+
+template <class Range, class OutputIt>
+auto adjacent_difference (Range&& rng, OutputIt&& it) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<OutputIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "adjacent_difference requires InputIterators");
+  return ::std::adjacent_difference(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputIt>(it)
+  );
+}
+
+template <class Range, class OutputIt, class BinaryOp>
+auto adjacent_difference (
+  Range&& rng,
+  OutputIt&& it,
+  BinaryOp&& op
+) -> enable_if_t<is_range<Range>::value, decay_t<OutputIt>> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "adjacent_difference requires InputIterators");
+  return ::std::adjacent_difference(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputIt>(it),
+    ::std::forward<BinaryOp>(op)
+  );
+}
+
+template <class Range, class OutputIt>
+auto partial_sum (Range&& rng, OutputIt&& it) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<OutputIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "partial_sum requires InputIterators");
+  return ::std::partial_sum(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputIt>(it)
+  );
+}
+
+template <class Range, class OutputIt, class BinaryOp>
+auto partial_sum (Range&& rng, OutputIt&& it, BinaryOp&& op) -> enable_if_t<
+  is_range<Range>::value,
+  decay_t<OutputIt>
+> {
+  auto range = make_range(::std::forward<Range>(rng));
+  constexpr auto is_input = decltype(range)::is_input;
+  static_assert(is_input, "partial_sum requires InputIterators");
+  return ::std::partial_sum(
+    ::std::begin(range),
+    ::std::end(range),
+    ::std::forward<OutputIt>(it),
+    ::std::forward<BinaryOp>(op)
+  );
+}
+
+}} /* namespace core::v1 */
+
+#endif /* CORE_NUMERIC_HPP */
diff --git a/src/bsoncxx/third_party/core/include/core/optional.hpp b/src/bsoncxx/third_party/core/include/core/optional.hpp
new file mode 100644
index 0000000..5e94003
--- /dev/null
+++ b/src/bsoncxx/third_party/core/include/core/optional.hpp
@@ -0,0 +1,1705 @@
+#ifndef CORE_OPTIONAL_HPP
+#define CORE_OPTIONAL_HPP
+
+#include <initializer_list>
+#include <system_error>
+#include <functional>
+#include <exception>
+#include <stdexcept>
+#include <memory>
+
+#include <cstdint>
+
+#include <core/type_traits.hpp>
+#include <core/functional.hpp>
+#include <core/utility.hpp>
+
+namespace core {
+inline namespace v1 {
+namespace impl {
+
+template <class T>
+class has_addressof {
+  template <class U>
+  static auto test (U* ptr) noexcept -> decltype(ptr->operator&(), void());
+  template <class> static void test (...) noexcept(false);
+public:
+  static constexpr bool value = noexcept(test<T>(nullptr));
+};
+
+template <class T>
+struct addressof : ::std::integral_constant<bool, has_addressof<T>::value> { };
+
+struct place_t { };
+constexpr place_t place { };
+
+/* this is the default 'false' case */
+template <class T, bool = ::std::is_trivially_destructible<T>::value>
+struct storage {
+  using value_type = T;
+  static constexpr bool nothrow_mv_ctor = ::std::is_nothrow_move_constructible<
+    value_type
+  >::value;
+
+  union {
+    ::std::uint8_t dummy;
+    value_type val;
+  };
+  bool engaged { false };
+
+  constexpr storage () noexcept : dummy { '\0' } { }
+  storage (storage const& that) :
+    engaged { that.engaged }
+  {
+    if (not this->engaged) { return; }
+    ::new(::std::addressof(this->val)) value_type { that.val };
+  }
+
+  storage (storage&& that) noexcept(nothrow_mv_ctor) :
+    engaged { that.engaged }
+  {
+    if (not this->engaged) { return; }
+    ::new(::std::addressof(this->val)) value_type { ::core::move(that.val) };
+  }
+
+  constexpr storage (value_type const& value) :
+    val { value },
+    engaged { true }
+  { }
+
+  constexpr storage (value_type&& value) noexcept(nothrow_mv_ctor) :
+    val { ::core::move(value) },
+    engaged { true }
+  { }
+
+  template <class... Args>
+  constexpr explicit storage (place_t, Args&&... args) :
+    val { ::core::forward<Args>(args)... },
+    engaged { true }
+  { }
+
+  ~storage () noexcept { if (this->engaged) { this->val.~value_type(); } }
+};
+
+template <class T>
+struct storage<T, true> {
+  using value_type = T;
+  static constexpr bool nothrow_mv_ctor = ::std::is_nothrow_move_constructible<
+    value_type
+  >::value;
+  union {
+    ::std::uint8_t dummy;
+    value_type val;
+  };
+  bool engaged { false };
+
+  constexpr storage () noexcept : dummy { '\0' } { }
+  storage (storage const& that) :
+    engaged { that.engaged }
+  {
+    if (not this->engaged) { return; }
+    ::new(::std::addressof(this->val)) value_type { that.val };
+  }
+
+  storage (storage&& that) noexcept(nothrow_mv_ctor) :
+    engaged { that.engaged }
+  {
+    if (not this->engaged) { return; }
+    ::new(::std::addressof(this->val)) value_type {
+      ::core::move(that.val)
+    };
+  }
+
+  constexpr storage (value_type const& value) :
+    val { value },
+    engaged { true }
+  { }
+
+  constexpr storage (value_type&& value) noexcept(nothrow_mv_ctor) :
+    val { ::core::move(value) },
+    engaged { true }
+  { }
+
+  template <class... Args>
+  constexpr explicit storage (place_t, Args&&... args) :
+    val { ::core::forward<Args>(args)... },
+    engaged { true }
+  { }
+};
+
+} /* namespace impl */
+
+struct in_place_t { };
+struct nullopt_t { constexpr explicit nullopt_t (int) noexcept { } };
+
+constexpr in_place_t in_place { };
+constexpr nullopt_t nullopt { 0 };
+
+struct bad_optional_access final : ::std::logic_error {
+  using ::std::logic_error::logic_error;
+};
+
+struct bad_expected_type : ::std::logic_error {
+  using ::std::logic_error::logic_error;
+};
+
+struct bad_result_condition : ::std::logic_error {
+  using ::std::logic_error::logic_error;
+};
+
+template <class Type>
+struct optional final : private impl::storage<Type> {
+  using base = impl::storage<Type>;
+  using value_type = typename impl::storage<Type>::value_type;
+
+  /* compiler enforcement */
+  static_assert(
+    not ::std::is_reference<value_type>::value,
+    "Cannot have optional reference (ill-formed)"
+  );
+
+  static_assert(
+    not ::std::is_same<decay_t<value_type>, nullopt_t>::value,
+    "Cannot have optional<nullopt_t> (ill-formed)"
+  );
+
+  static_assert(
+    not ::std::is_same<decay_t<value_type>, in_place_t>::value,
+    "Cannot have optional<in_place_t> (ill-formed)"
+  );
+
+  static_assert(
+    not ::std::is_same<decay_t<value_type>, ::std::nullptr_t>::value,
+    "Cannot have optional nullptr (tautological)"
+  );
+
+  static_assert(
+    not ::std::is_same<decay_t<value_type>, void>::value,
+    "Cannot have optional<void> (ill-formed)"
+  );
+
+  static_assert(
+    ::std::is_object<value_type>::value,
+    "Cannot have optional with a non-object type (undefined behavior)"
+  );
+
+  static_assert(
+    ::std::is_nothrow_destructible<value_type>::value,
+    "Cannot have optional with non-noexcept destructible (undefined behavior)"
+  );
+
+  constexpr optional () noexcept { }
+  optional (optional const&) = default;
+  optional (optional&&) = default;
+  ~optional () = default;
+
+  constexpr optional (nullopt_t) noexcept { }
+
+  constexpr optional (value_type const& value) :
+    base { value }
+  { }
+
+  constexpr optional (value_type&& value) noexcept(base::nothrow_mv_ctor) :
+    base { ::core::move(value) }
+  { }
+
+  template <
+    class... Args,
+    class=enable_if_t< ::std::is_constructible<value_type, Args...>::value>
+  > constexpr explicit optional (in_place_t, Args&&... args) :
+    base { impl::place, ::core::forward<Args>(args)... }
+  { }
+
+  template <
+    class T,
+    class... Args,
+    class=enable_if_t<
+      ::std::is_constructible<
+        value_type,
+        ::std::initializer_list<T>&,
+        Args...
+      >::value
+    >
+  > constexpr explicit optional (
+    in_place_t,
+    ::std::initializer_list<T> il,
+    Args&&... args
+  ) : base { impl::place, il, ::core::forward<Args>(args)... } { }
+
+  optional& operator = (optional const& that) {
+    optional { that }.swap(*this);
+    return *this;
+  }
+
+  optional& operator = (optional&& that) noexcept (
+    all_traits<
+      ::std::is_nothrow_move_assignable<value_type>,
+      ::std::is_nothrow_move_constructible<value_type>
+    >::value
+  ) {
+    optional { ::core::move(that) }.swap(*this);
+    return *this;
+  }
+
+  template <
+    class T,
+    class=enable_if_t<
+      not ::std::is_same<decay_t<T>, optional>::value and
+      ::std::is_constructible<value_type, T>::value and
+      ::std::is_assignable<value_type&, T>::value
+    >
+  > optional& operator = (T&& value) {
+    if (not this->engaged) { this->emplace(::core::forward<T>(value)); }
+    else { **this = ::core::forward<T>(value); }
+    return *this;
+  }
+
+  optional& operator = (nullopt_t) noexcept {
+    if (this->engaged) {
+      this->val.~value_type();
+      this->engaged = false;
+    }
+    return *this;
+  }
+
+  void swap (optional& that) noexcept(
+    all_traits<
+      is_nothrow_swappable<value_type>,
+      ::std::is_nothrow_move_constructible<value_type>
+    >::value
+  ) {
+    using ::std::swap;
+    if (not *this and not that) { return; }
+    if (*this and that) {
+      swap(**this, *that);
+      return;
+    }
+
+    auto& to_disengage = *this ? *this : that;
+    auto& to_engage = *this ? that : *this;
+
+    to_engage.emplace(::core::move(*to_disengage));
+    to_disengage = nullopt;
+  }
+
+  constexpr explicit operator bool () const { return this->engaged; }
+
+  constexpr value_type const& operator * () const noexcept {
+    return this->val;
+  }
+
+  value_type& operator * () noexcept { return this->val; }
+
+  constexpr value_type const* operator -> () const noexcept {
+    return this->ptr(impl::addressof<value_type> { });
+  }
+
+  value_type* operator -> () noexcept { return ::std::addressof(this->val); }
+
+  template <class T, class... Args>
+  void emplace (::std::initializer_list<T> il, Args&&... args) {
+    *this = nullopt;
+    ::new(::std::addressof(this->val)) value_type {
+      il,
+      ::core::forward<Args>(args)...
+    };
+    this->engaged = true;
+  }
+
+  template <class... Args>
+  void emplace (Args&&... args) {
+    *this = nullopt;
+    ::new(::std::addressof(this->val)) value_type {
+      ::core::forward<Args>(args)...
+    };
+    this->engaged = true;
+  }
+
+  constexpr value_type const& value () const noexcept(false) {
+    return *this
+      ? **this
+      : (throw bad_optional_access { "optional is disengaged" }, **this);
+  }
+
+  value_type& value () noexcept(false) {
+    if (*this) { return **this; }
+    throw bad_optional_access { "optional is disengaged" };
+  }
+
+  template <
+    class T,
+    class=enable_if_t<
+      all_traits<
+        ::std::is_copy_constructible<value_type>,
+        ::std::is_convertible<T, value_type>
+      >::value
+    >
+  > constexpr value_type value_or (T&& val) const& {
+    return *this ? **this : static_cast<value_type>(::core::forward<T>(val));
+  }
+
+  template <
+    class T,
+    class=enable_if_t<
+      all_traits<
+        ::std::is_move_constructible<value_type>,
+        ::std::is_convertible<T, value_type>
+      >::value
+    >
+  > value_type value_or (T&& val) && {
+    return *this
+      ? value_type { ::core::move(**this) }
+      : static_cast<value_type>(::core::forward<T>(val));
+  }
+
+private:
+  constexpr value_type const* ptr (::std::false_type) const noexcept {
+    return &this->val;
+  }
+
+  value_type const* ptr (::std::true_type) const noexcept {
+    return ::std::addressof(this->val);
+  }
+};
+
+template <class Type>
+struct expected final {
+  using value_type = Type;
+
+  static constexpr bool nothrow = ::std::is_nothrow_move_constructible<
+    value_type
+  >::value;
+
+  /* compiler enforcement */
+  static_assert(
+    not ::std::is_reference<value_type>::value,
+    "Cannot have expected reference (ill-formed)"
+  );
+
+  static_assert(
+    not ::std::is_same<decay_t<value_type>, nullopt_t>::value,
+    "Cannot have expected<nullopt_t> (ill-formed)"
+  );
+
+  static_assert(
+    not ::std::is_same<decay_t<value_type>, in_place_t>::value,
+    "Cannot have expected<in_place_t> (ill-formed)"
+  );
+
+  static_assert(
+    not ::std::is_same<decay_t<value_type>, ::std::exception_ptr>::value,
+    "Cannot have expected<std::exception_ptr> (tautological)"
+  );
+
+  static_assert(
+    ::std::is_object<value_type>::value,
+    "Cannot have expected with non-object type (undefined behavior)"
+  );
+
+  static_assert(
+    ::std::is_nothrow_destructible<value_type>::value,
+    "Cannot have expected with throwable destructor (undefined behavior)"
+  );
+
+  expected (::std::exception_ptr ptr) noexcept :
+    ptr { ptr }
+  { }
+
+  expected (value_type const& val) :
+    val { val },
+    valid { true }
+  { }
+
+  expected (value_type&& val) noexcept(nothrow) :
+    val { ::core::move(val) },
+    valid { true }
+  { }
+
+  template <
+    class... Args,
+    class=enable_if_t< ::std::is_constructible<value_type, Args...>::value>
+  > explicit expected (in_place_t, Args&&... args) :
+    val { ::core::forward<Args>(args)... },
+    valid { true }
+  { }
+
+  template <
+    class T,
+    class... Args,
+    class=enable_if_t<
+      ::std::is_constructible<
+        value_type,
+        ::std::initializer_list<T>&,
+        Args...
+      >::value
+    >
+  > explicit expected (
+    in_place_t,
+    ::std::initializer_list<T> il,
+    Args&&... args
+  ) : val { il, ::core::forward<Args>(args)... }, valid { true } { }
+
+  expected (expected const& that) :
+    valid { that.valid }
+  {
+    if (*this) { ::new (::std::addressof(this->val)) value_type { that.val }; }
+    else {
+      ::new (::std::addressof(this->ptr)) ::std::exception_ptr { that.ptr };
+    }
+  }
+
+  expected (expected&& that) noexcept(nothrow) :
+    valid { that.valid }
+  {
+    if (*this) {
+      ::new (::std::addressof(this->val)) value_type { ::core::move(that.val) };
+    } else {
+      ::new (::std::addressof(this->ptr)) ::std::exception_ptr { that.ptr };
+    }
+  }
+
+  expected () :
+    val { },
+    valid { true }
+  { }
+
+  ~expected () noexcept { this->reset(); }
+
+  expected& operator = (expected const& that) {
+    expected { that }.swap(*this);
+    return *this;
+  }
+
+  expected& operator = (expected&& that) noexcept(
+    all_traits<
+      ::std::is_nothrow_move_assignable<value_type>,
+      ::std::is_nothrow_move_constructible<value_type>
+    >::value
+  ) {
+    expected { ::core::move(that) }.swap(*this);
+    return *this;
+  }
+
+  template <
+    class T,
+    class=enable_if_t<
+      all_traits<
+        no_traits<
+          ::std::is_same<decay_t<T>, expected>,
+          ::std::is_same<decay_t<T>, ::std::exception_ptr>
+        >,
+        ::std::is_constructible<value_type, T>,
+        ::std::is_assignable<value_type&, T>
+      >::value
+    >
+  > expected& operator = (T&& value) {
+    if (not *this) { this->emplace(::core::forward<T>(value)); }
+    else { **this = ::core::forward<T>(value); }
+    return *this;
+  }
+
+  expected& operator = (value_type const& value) {
+    if (not *this) { this->emplace(value); }
+    else { **this = value; }
+    return *this;
+  }
+
+  expected& operator = (value_type&& value) {
+    if (not *this) { this->emplace(::core::move(value)); }
+    else { **this = ::core::move(value); }
+    return *this;
+  }
+
+  expected& operator = (::std::exception_ptr ptr) {
+    if (not *this) { this->ptr = ptr; }
+    else {
+      this->val.~value_type();
+      ::new (::std::addressof(this->ptr)) ::std::exception_ptr { ptr };
+      this->valid = false;
+    }
+    return *this;
+  }
+
+  void swap (expected& that) noexcept(
+    all_traits<
+      is_nothrow_swappable<value_type>,
+      ::std::is_nothrow_move_constructible<value_type>
+    >::value
+  ) {
+    using ::std::swap;
+
+    if (not *this and not that) {
+      swap(this->ptr, that.ptr);
+      return;
+    }
+
+    if (*this and that) {
+      swap(this->val, that.val);
+      return;
+    }
+
+    auto& to_invalidate = *this ? *this : that;
+    auto& to_validate = *this ? that : *this;
+    auto ptr = to_validate.ptr;
+    to_validate.emplace(::core::move(*to_invalidate));
+    to_invalidate = ptr;
+  }
+
+  explicit operator bool () const noexcept { return this->valid; }
+
+  value_type const& operator * () const noexcept { return this->val; }
+  value_type& operator * () noexcept { return this->val; }
+
+  value_type const* operator -> () const noexcept {
+    return ::std::addressof(this->val);
+  }
+  value_type* operator -> () noexcept { return ::std::addressof(this->val); }
+
+  template <class T, class... Args>
+  void emplace (::std::initializer_list<T> il, Args&&... args) {
+    this->reset();
+    ::new (::std::addressof(this->val)) value_type {
+      il,
+      ::core::forward<Args>(args)...
+    };
+    this->valid = true;
+  }
+
+  template <class... Args>
+  void emplace (Args&&... args) {
+    this->reset();
+    ::new (::std::addressof(this->val)) value_type {
+      ::core::forward<Args>(args)...
+    };
+    this->valid = true;
+  }
+
+  value_type const& value () const noexcept(false) {
+    if (not *this) { ::std::rethrow_exception(this->ptr); }
+    return **this;
+  }
+
+  value_type& value () noexcept(false) {
+    if (not *this) { ::std::rethrow_exception(this->ptr); }
+    return **this;
+  }
+
+  template <
+    class T,
+    class=enable_if_t<
+      all_traits<
+        ::std::is_copy_constructible<value_type>,
+        ::std::is_convertible<T, value_type>
+      >::value
+    >
+  > value_type value_or (T&& val) const& {
+    return *this ? **this : static_cast<value_type>(::core::forward<T>(val));
+  }
+
+  template <
+    class T,
+    class=enable_if_t<
+      all_traits<
+        ::std::is_move_constructible<value_type>,
+        ::std::is_convertible<T, value_type>
+      >::value
+    >
+  > value_type value_or (T&& val) && {
+    return *this
+      ? value_type { ::core::move(**this) }
+      : static_cast<value_type>(::core::forward<T>(val));
+  }
+
+  template <class E>
+  E expect () const noexcept(false) {
+    try { this->raise(); }
+    catch (E const& e) { return e; }
+    catch (...) {
+      ::std::throw_with_nested(bad_expected_type { "unexpected exception" });
+    }
+  }
+
+  [[noreturn]] void raise () const noexcept(false) {
+    if (*this) { throw bad_expected_type { "expected<T> is valid" }; }
+    ::std::rethrow_exception(this->ptr);
+  }
+
+  ::std::exception_ptr pointer () const noexcept(false) {
+    if (*this) { throw bad_expected_type { "expected<T> is valid" }; }
+    return this->ptr;
+  }
+
+  [[gnu::deprecated]] ::std::exception_ptr get_ptr () const noexcept(false) {
+    return this->pointer();
+  }
+
+private:
+
+  void reset () {
+    *this ? this->val.~value_type() : this->ptr.~exception_ptr();
+  }
+
+  union {
+    value_type val;
+    ::std::exception_ptr ptr;
+  };
+  bool valid { false };
+};
+
+template <class Type>
+struct result final {
+  using value_type = Type;
+
+  static constexpr bool nothrow = ::std::is_nothrow_move_constructible<
+    value_type
+  >::value;
+
+  static_assert(
+    not ::std::is_same<decay_t<value_type>, nullopt_t>::value,
+    "Cannot have result<nullopt_t> (ill-formed)"
+  );
+
+  static_assert(
+    not ::std::is_same<decay_t<value_type>, in_place_t>::value,
+    "Cannot have result<in_place_t> (ill-formed)"
+  );
+
+  static_assert(
+    not ::std::is_same<decay_t<value_type>, ::std::error_condition>::value,
+    "Cannot have result<error_condition> (tautological)"
+  );
+
+  static_assert(
+    not ::std::is_error_condition_enum<value_type>::value,
+    "Cannot have result with an error condition enum as the value (ill-formed)"
+  );
+
+  static_assert(
+    not ::std::is_reference<value_type>::value,
+    "Cannot have result<T&> (ill-formed)"
+  );
+
+  static_assert(
+    ::std::is_object<value_type>::value,
+    "Cannot have result with non-object type (undefined behavior)"
+  );
+
+  static_assert(
+    ::std::is_nothrow_destructible<value_type>::value,
+    "Cannot have result with throwable destructor (undefined behavior)"
+  );
+
+  result (int val, ::std::error_category const& cat) noexcept :
+    valid { val == 0 }
+  {
+    if (*this) { ::new (::std::addressof(this->val)) value_type { }; }
+    else {
+      ::new (::std::addressof(this->cnd)) ::std::error_condition { val, cat };
+    }
+  }
+
+  template <
+    class ErrorConditionEnum,
+    class=enable_if_t<
+      ::std::is_error_condition_enum<ErrorConditionEnum>::value
+    >
+  > result (ErrorConditionEnum e) noexcept :
+    valid { static_cast<core::underlying_type_t<ErrorConditionEnum>>(e) == 0 }
+  {
+    if (*this) { ::new (::std::addressof(this->val)) value_type { }; }
+    else { ::new (::std::addressof(this->cnd)) ::std::error_condition { e }; }
+  }
+
+  result (::std::error_condition const& ec) :
+    valid { not ec }
+  {
+    if (*this) { ::new (::std::addressof(this->val)) value_type { }; }
+    else { ::new (::std::addressof(this->cnd)) ::std::error_condition { ec }; }
+  }
+
+  result (value_type const& val) :
+    val { val },
+    valid { true }
+  { }
+
+  result (value_type&& val) noexcept(nothrow) :
+    val { ::core::move(val) },
+    valid { true }
+  { }
+
+  template <
+    class... Args,
+    class=enable_if_t< ::std::is_constructible<value_type, Args...>::value>
+  > explicit result (in_place_t, Args&&... args) :
+    val { ::core::forward<Args>(args)... },
+    valid { true }
+  { }
+
+  template <
+    class T,
+    class... Args,
+    class=enable_if_t<
+      ::std::is_constructible<
+        value_type,
+        ::std::initializer_list<T>&,
+        Args...
+      >::value
+    >
+  > explicit result (
+    in_place_t,
+    ::std::initializer_list<T> il,
+    Args&&... args
+  ) : val { il, ::core::forward<Args>(args)... }, valid { true } { }
+
+  result (result const& that) :
+    valid { that.valid }
+  {
+    if (*this) { ::new (::std::addressof(this->val)) value_type { that.val }; }
+    else {
+      ::new (::std::addressof(this->cnd)) ::std::error_condition { that.cnd };
+    }
+  }
+
+  result (result&& that) :
+    valid { that.valid }
+  {
+    if (*this) {
+      ::new (::std::addressof(this->val)) value_type { ::core::move(that.val) };
+    } else {
+      ::new (::std::addressof(this->cnd)) ::std::error_condition { that.cnd };
+    }
+  }
+
+  result () :
+    val { },
+    valid { true }
+  { }
+
+  ~result () noexcept { this->reset(); }
+
+  result& operator = (result const& that) {
+    result { that }.swap(*this);
+    return *this;
+  }
+
+  result& operator = (result&& that) noexcept(
+    all_traits<
+      ::std::is_nothrow_move_assignable<value_type>,
+      ::std::is_nothrow_move_constructible<value_type>
+    >::value
+  ) {
+    result { ::core::move(that) }.swap(*this);
+    return *this;
+  }
+
+  template <
+    class T,
+    class=enable_if_t<
+      all_traits<
+        no_traits<
+          ::std::is_same<decay_t<T>, result>,
+          ::std::is_same<decay_t<T>, ::std::error_condition>
+        >,
+        ::std::is_constructible<value_type, T>,
+        ::std::is_assignable<value_type&, T>
+      >::value
+    >
+  > result& operator = (T&& value) {
+    if (not *this) { this->emplace(::core::forward<T>(value)); }
+    else { **this = ::core::forward<T>(value); }
+    return *this;
+  }
+
+  template <
+    class ErrorConditionEnum,
+    class=enable_if_t<
+      ::std::is_error_condition_enum<ErrorConditionEnum>::value
+    >
+  > result& operator = (ErrorConditionEnum e) {
+    result { e }.swap(*this);
+    return *this;
+  }
+
+  result& operator = (value_type const& value) {
+    if (not *this) { this->emplace(value); }
+    else { **this = value; }
+    return *this;
+  }
+
+  result& operator = (value_type&& value) {
+    if (not *this) { this->emplace(::core::move(value)); }
+    else { **this = ::core::move(value); }
+    return *this;
+  }
+
+  result& operator = (::std::error_condition const& cnd) {
+    if (not cnd) { return *this; }
+    if (not *this) { this->cnd = cnd; }
+    else {
+      this->reset();
+      ::new (::std::addressof(this->cnd)) ::std::error_condition { cnd };
+      this->valid = false;
+    }
+    return *this;
+  }
+
+  void swap (result& that) noexcept(
+    all_traits<
+      is_nothrow_swappable<value_type>,
+      ::std::is_nothrow_move_constructible<value_type>
+    >::value
+  ) {
+    using ::std::swap;
+    if (not *this and not that) {
+      swap(this->cnd, that.cnd);
+      return;
+    }
+
+    if (*this and that) {
+      swap(this->val, that.val);
+      return;
+    }
+
+    auto& to_invalidate = *this ? *this : that;
+    auto& to_validate = *this ? that : *this;
+    auto cnd = to_validate.cnd;
+    to_validate.emplace(::core::move(*to_invalidate));
+    to_invalidate = cnd;
+  }
+
+  explicit operator bool () const noexcept { return this->valid; }
+
+  value_type const& operator * () const noexcept { return this->val; }
+  value_type& operator * () noexcept { return this->val; }
+
+  value_type const* operator -> () const noexcept {
+    return ::std::addressof(this->val);
+  }
+
+  value_type* operator -> () noexcept { return ::std::addressof(this->val); }
+
+  template <class T, class... Args>
+  void emplace (::std::initializer_list<T> il, Args&&... args) {
+    this->reset();
+    ::new (::std::addressof(this->val)) value_type {
+      il,
+      ::core::forward<Args>(args)...
+    };
+    this->valid = true;
+  }
+
+  template <class... Args>
+  void emplace (Args&&... args) {
+    this->reset();
+    ::new (::std::addressof(this->val)) value_type {
+      ::core::forward<Args>(args)...
+    };
+    this->valid = true;
+  }
+
+  value_type const& value () const noexcept(false) {
+    if (*this) { return **this; }
+    throw ::std::system_error { this->cnd.value(), this->cnd.category() };
+  }
+
+  value_type& value () noexcept(false) {
+    if (*this) { return **this; }
+   throw ::std::system_error { this->cnd.value(), this->cnd.category() };
+  }
+
+  template <
+    class T,
+    class=enable_if_t<
+      all_traits<
+        ::std::is_copy_constructible<value_type>,
+        ::std::is_convertible<T, value_type>
+      >::value
+    >
+  > value_type value_or (T&& val) const& {
+    return *this ? **this : static_cast<value_type>(::core::forward<T>(val));
+  }
+
+  template <
+    class T,
+    class=enable_if_t<
+      all_traits<
+        ::std::is_move_constructible<value_type>,
+        ::std::is_convertible<T, value_type>
+      >::value
+    >
+  > value_type value_or (T&& val) && {
+    return *this
+      ? value_type { ::core::move(**this) }
+      : static_cast<value_type>(::core::forward<T>(val));
+  }
+
+  ::std::error_condition const& condition () const noexcept(false) {
+    if (*this) { throw bad_result_condition { "result<T> is valid" }; }
+    return this->cnd;
+  }
+
+private:
+  void reset () {
+    *this ? this->val.~value_type() : this->cnd.~error_condition();
+  }
+
+  union {
+    value_type val;
+    ::std::error_condition cnd;
+  };
+  bool valid { false };
+};
+
+template <>
+struct expected<void> final {
+  using value_type = void;
+
+  explicit expected (::std::exception_ptr ptr) noexcept : ptr { ptr } { }
+  expected (expected const&) = default;
+  expected (expected&&) = default;
+  expected () = default;
+  ~expected () = default;
+
+  expected& operator = (::std::exception_ptr ptr) noexcept {
+    expected { ptr }.swap(*this);
+    return *this;
+  }
+
+  expected& operator = (expected const&) = default;
+  expected& operator = (expected&&) = default;
+
+  void swap (expected& that) noexcept {
+    using ::std::swap;
+    swap(this->ptr, that.ptr);
+  }
+
+  explicit operator bool () const noexcept { return not this->ptr; }
+
+  template <class E>
+  E expect () const noexcept(false) {
+    try { this->raise(); }
+    catch (E const& e) { return e; }
+    catch (...) {
+      ::std::throw_with_nested(bad_expected_type { "unexpected exception" });
+    }
+  }
+
+  [[noreturn]] void raise () const noexcept(false) {
+    if (*this) { throw bad_expected_type { "valid expected<void>" }; }
+    ::std::rethrow_exception(this->ptr);
+  }
+
+  ::std::exception_ptr pointer () const noexcept(false) {
+    if (*this) { throw bad_expected_type { "valid expected<void>" }; }
+    return this->ptr;
+  }
+
+  [[gnu::deprecated]] ::std::exception_ptr get_ptr () const noexcept(false) {
+    return this->pointer();
+  }
+
+private:
+  ::std::exception_ptr ptr;
+};
+
+template <>
+struct result<void> final {
+  using value_type = void;
+
+  result (int val, ::std::error_category const& cat) :
+    cnd { val, cat }
+  { }
+
+  result (::std::error_condition const& ec) :
+    cnd { ec }
+  { }
+
+  template <
+    class ErrorConditionEnum,
+    class=enable_if_t<
+      ::std::is_error_condition_enum<ErrorConditionEnum>::value
+    >
+  > result (ErrorConditionEnum e) noexcept :
+    cnd { e }
+  { }
+
+  result (result const&) = default;
+  result (result&&) = default;
+  result () = default;
+
+  template <
+    class ErrorConditionEnum,
+    class=enable_if_t<std::is_error_condition_enum<ErrorConditionEnum>::value>
+  > result& operator = (ErrorConditionEnum e) noexcept {
+    result { e }.swap(*this);
+    return *this;
+  }
+
+  result& operator = (::std::error_condition const& ec) {
+    result { ec }.swap(*this);
+    return *this;
+  }
+
+  result& operator = (result const&) = default;
+  result& operator = (result&&) = default;
+
+  void swap (result& that) noexcept {
+    using ::std::swap;
+    swap(this->cnd, that.cnd);
+  }
+
+  explicit operator bool () const noexcept { return not this->cnd; }
+
+  ::std::error_condition const& condition () const noexcept(false) {
+    if (*this) { throw bad_result_condition { "result<void> is valid" }; }
+    return this->cnd;
+  }
+
+private:
+  ::std::error_condition cnd;
+};
+
+/* operator == */
+template <class T>
+constexpr bool operator == (
+  optional<T> const& lhs,
+  optional<T> const& rhs
+) noexcept {
+  return static_cast<bool>(lhs) != static_cast<bool>(rhs)
+    ? false
+    : (not lhs and not rhs) or *lhs == *rhs;
+}
+
+template <class T>
+constexpr bool operator == (optional<T> const& lhs, nullopt_t) noexcept {
+  return not lhs;
+}
+
+template <class T>
+constexpr bool operator == (nullopt_t, optional<T> const& rhs) noexcept {
+  return not rhs;
+}
+
+template <class T>
+constexpr bool operator == (optional<T> const& opt, T const& value) noexcept {
+  return opt and *opt == value;
+}
+
+template <class T>
+constexpr bool operator == (T const& value, optional<T> const& opt) noexcept {
+  return opt and value == *opt;
+}
+
+template <class T>
+bool operator == (expected<T> const& lhs, expected<T> const& rhs) noexcept {
+  if (lhs and rhs) { return *lhs == *rhs; }
+  return not lhs and not rhs;
+}
+
+template <class T>
+bool operator == (expected<T> const& lhs, ::std::exception_ptr) noexcept {
+  return not lhs;
+}
+
+template <class T>
+bool operator == (::std::exception_ptr, expected<T> const& rhs) noexcept {
+  return not rhs;
+}
+
+template <class T>
+bool operator == (expected<T> const& lhs, T const& rhs) noexcept {
+  return lhs and *lhs == rhs;
+}
+
+template <class T>
+bool operator == (T const& lhs, expected<T> const& rhs) noexcept {
+  return rhs and lhs == *rhs;
+}
+
+template <class T>
+bool operator == (result<T> const& lhs, result<T> const& rhs) noexcept {
+  if (lhs and rhs) { return *lhs == *rhs; }
+  if (not lhs and not rhs) { return lhs.condition() == rhs.condition(); }
+  return false;
+}
+
+template <class T>
+bool operator == (
+  result<T> const& lhs,
+  ::std::error_condition const& rhs
+) noexcept { return not lhs and rhs and lhs.condition() == rhs; }
+
+template <class T>
+bool operator == (
+  ::std::error_condition const& lhs,
+  result<T> const& rhs
+) noexcept { return lhs and not rhs and lhs == rhs.condition(); }
+
+template <class T>
+bool operator == (
+  result<T> const& lhs,
+  ::std::error_code const& rhs
+) noexcept { return not lhs and rhs and lhs.condition() == rhs; }
+
+template <class T>
+bool operator == (
+  ::std::error_code const& lhs,
+  result<T> const& rhs
+) noexcept { return lhs and not rhs and lhs == rhs.condition(); }
+
+template <class T>
+bool operator == (result<T> const& res, T const& value) noexcept {
+  return res and *res == value;
+}
+
+template <class T>
+bool operator == (T const& value, result<T> const& res) noexcept {
+  return res and value == *res;
+}
+
+/* void specializations */
+template <>
+inline bool operator == <void> (
+  expected<void> const& lhs,
+  expected<void> const& rhs
+) noexcept {
+  if (not lhs and not rhs) { return lhs.pointer() == rhs.pointer(); }
+  return lhs and rhs;
+}
+
+template <>
+inline bool operator == <void> (
+  result<void> const& lhs,
+  result<void> const& rhs
+) noexcept {
+  if (not lhs and not rhs) { return lhs.condition() == rhs.condition(); }
+  return lhs and rhs;
+}
+
+/* operator < */
+template <class T>
+constexpr bool operator < (
+  optional<T> const& lhs,
+  optional<T> const& rhs
+) noexcept {
+  return static_cast<bool>(rhs) == false ? false : not lhs or *lhs < *rhs;
+}
+
+template <class T>
+constexpr bool operator < (optional<T> const& lhs, nullopt_t) noexcept {
+  return not lhs;
+}
+
+template <class T>
+constexpr bool operator < (nullopt_t, optional<T> const& rhs) noexcept {
+  return static_cast<bool>(rhs);
+}
+
+template <class T>
+constexpr bool operator < (optional<T> const& opt, T const& value) noexcept {
+  return not opt or *opt < value;
+}
+
+template <class T>
+constexpr bool operator < (T const& value, optional<T> const& opt) noexcept {
+  return opt and value < *opt;
+}
+
+template <class T>
+bool operator < (expected<T> const& lhs, expected<T> const& rhs) noexcept {
+  if (not rhs) { return false; }
+  return not lhs or *lhs < *rhs;
+}
+
+template <class T>
+bool operator < (expected<T> const& lhs, ::std::exception_ptr) noexcept {
+  return not lhs;
+}
+
+template <class T>
+bool operator < (::std::exception_ptr, expected<T> const& rhs) noexcept {
+  return static_cast<bool>(rhs);
+}
+
+template <class T>
+bool operator < (expected<T> const& exp, T const& value) noexcept {
+  return not exp or *exp < value;
+}
+
+template <class T>
+bool operator < (T const& value, expected<T> const& exp) noexcept {
+  return exp and value < *exp;
+}
+
+template <class T>
+bool operator < (result<T> const& lhs, result<T> const& rhs) noexcept {
+  if (not rhs and not lhs) { return lhs.condition() < rhs.condition(); }
+  if (lhs and rhs) { return *lhs < *rhs; }
+  return static_cast<bool>(rhs);
+}
+
+template <class T>
+bool operator < (
+  result<T> const& lhs,
+  ::std::error_condition const& rhs
+) noexcept { return not lhs and lhs.condition() < rhs; }
+
+template <class T>
+bool operator < (
+  ::std::error_condition const& lhs,
+  result<T> const& rhs
+) noexcept { return rhs or lhs < rhs.condition(); }
+
+template <>
+inline bool operator < <void> (
+  result<void> const& lhs,
+  result<void> const& rhs
+) noexcept {
+  if (not lhs and not rhs) { return lhs.condition() < rhs.condition(); }
+  return static_cast<bool>(rhs);
+}
+
+template <class T>
+bool operator < (result<T> const& res, T const& value) noexcept {
+  return not res or *res < value;
+}
+
+template <class T>
+bool operator < (T const& value, result<T> const& res) noexcept {
+  return res and value < *res;
+}
+
+/* operator != */
+template <class T>
+constexpr bool operator != (
+  optional<T> const& lhs,
+  optional<T> const& rhs
+) noexcept { return not (lhs == rhs); }
+
+template <class T>
+constexpr bool operator != (optional<T> const& lhs, nullopt_t) noexcept {
+  return not (lhs == nullopt);
+}
+
+template <class T>
+constexpr bool operator != (nullopt_t, optional<T> const& rhs) noexcept {
+  return not (nullopt == rhs);
+}
+
+template <class T>
+constexpr bool operator != (optional<T> const& opt, T const& value) noexcept {
+  return not (opt == value);
+}
+
+template <class T>
+constexpr bool operator != (T const& value, optional<T> const& opt) noexcept {
+  return not (value == opt);
+}
+
+template <class T>
+bool operator != (expected<T> const& lhs, expected<T> const& rhs) noexcept {
+  return not (lhs == rhs);
+}
+
+template <class T>
+bool operator != (expected<T> const& lhs, ::std::exception_ptr rhs) noexcept {
+  return not (lhs == rhs);
+}
+
+template <class T>
+bool operator != (::std::exception_ptr lhs, expected<T> const& rhs) noexcept {
+  return not (lhs == rhs);
+}
+
+template <class T>
+bool operator != (expected<T> const& exp, T const& value) noexcept {
+  return not (exp == value);
+}
+
+template <class T>
+bool operator != (T const& value, expected<T> const& exp) noexcept {
+  return not (value == exp);
+}
+
+template <class T>
+bool operator != (result<T> const& lhs, result<T> const& rhs) noexcept {
+  return not (lhs == rhs);
+}
+
+template <class T>
+bool operator != (
+  result<T> const& lhs,
+  ::std::error_condition const& rhs
+) noexcept { return not (lhs == rhs); }
+
+template <class T>
+bool operator != (
+  ::std::error_condition const& lhs,
+  result<T> const& rhs
+) noexcept { return not (lhs == rhs); }
+
+template <class T>
+bool operator != (
+  result<T> const& lhs,
+  ::std::error_code const& rhs
+) noexcept { return not (lhs == rhs); }
+
+template <class T>
+bool operator != (
+  ::std::error_code const& lhs,
+  result<T> const& rhs
+) noexcept { return not (lhs == rhs); }
+
+template <class T>
+bool operator != (result<T> const& res, T const& value) noexcept {
+  return not (res == value);
+}
+
+template <class T>
+bool operator != (T const& value, result<T> const& res) noexcept {
+  return not (value == res);
+}
+
+template <>
+inline bool operator != <void> (
+  expected<void> const& lhs,
+  expected<void> const& rhs
+) noexcept { return not (lhs == rhs); }
+
+template <>
+inline bool operator != <void> (
+  result<void> const& lhs,
+  result<void> const& rhs
+) noexcept { return not (lhs == rhs); }
+
+/* optional<T> operator >= */
+template <class T>
+constexpr bool operator >= (
+  optional<T> const& lhs,
+  optional<T> const& rhs
+) noexcept { return not (lhs < rhs); }
+
+template <class T>
+constexpr bool operator >= (optional<T> const&, nullopt_t) noexcept {
+  return true;
+}
+
+template <class T>
+constexpr bool operator >= (nullopt_t, optional<T> const& opt) noexcept {
+  return opt < nullopt;
+}
+
+template <class T>
+constexpr bool operator >= (optional<T> const& opt, T const& value) noexcept {
+  return not (opt < value);
+}
+
+template <class T>
+constexpr bool operator >= (T const& value, optional<T> const& opt) noexcept {
+  return not (value < opt);
+}
+
+template <class T>
+bool operator >= (expected<T> const& lhs, expected<T> const& rhs) noexcept {
+  return not (lhs < rhs);
+}
+
+template <class T>
+bool operator >= (expected<T> const&, ::std::exception_ptr) noexcept {
+  return true;
+}
+
+template <class T>
+bool operator >= (::std::exception_ptr ptr, expected<T> const& exp) noexcept {
+  return exp < ptr;
+}
+
+template <class T>
+bool operator >= (expected<T> const& exp, T const& value) noexcept {
+  return not (exp < value);
+}
+
+template <class T>
+bool operator >= (T const& value, expected<T> const& exp) noexcept {
+  return not (value < exp);
+}
+
+template <class T>
+bool operator >= (result<T> const& lhs, result<T> const& rhs) noexcept {
+  return not (lhs < rhs);
+}
+
+template <class T>
+bool operator >= (
+  result<T> const& lhs,
+  ::std::error_condition const& rhs
+) noexcept { return not (lhs < rhs); }
+
+template <class T>
+bool operator >= (
+  ::std::error_condition const& lhs,
+  result<T> const& rhs
+) noexcept { return not (lhs < rhs); }
+
+template <class T>
+bool operator >= (result<T> const& res, T const& value) noexcept {
+  return not (res < value);
+}
+
+template <class T>
+bool operator >= (T const& value, result<T> const& res) noexcept {
+  return not (value < res);
+}
+
+template <>
+inline bool operator >= <void> (
+  result<void> const& lhs,
+  result<void> const& rhs
+) noexcept { return not (lhs < rhs); }
+
+/* operator <= */
+template <class T>
+constexpr bool operator <= (
+  optional<T> const& lhs,
+  optional<T> const& rhs
+) noexcept { return not (rhs < lhs); }
+
+template <class T>
+constexpr bool operator <= (optional<T> const& lhs, nullopt_t) noexcept {
+  return not lhs;
+}
+
+template <class T>
+constexpr bool operator <= (nullopt_t, optional<T> const&) noexcept {
+  return true;
+}
+
+template <class T>
+constexpr bool operator <= (optional<T> const& opt, T const& value) noexcept {
+  return not (opt > value);
+}
+
+template <class T>
+constexpr bool operator <= (T const& value, optional<T> const& opt) noexcept {
+  return not (value > opt);
+}
+
+template <class T>
+bool operator <= (expected<T> const& lhs, expected<T> const& rhs) noexcept {
+  return not (rhs < lhs);
+}
+
+template <class T>
+bool operator <= (expected<T> const& lhs, ::std::exception_ptr) noexcept {
+  return not lhs;
+}
+
+template <class T>
+bool operator <= (::std::exception_ptr, expected<T> const&) noexcept {
+  return true;
+}
+
+template <class T>
+bool operator <= (expected<T> const& exp, T const& value) noexcept {
+  return not (value < exp);
+}
+
+template <class T>
+bool operator <= (T const& value, expected<T> const& exp) noexcept {
+  return not (exp < value);
+}
+
+template <class T>
+bool operator <= (result<T> const& lhs, result<T> const& rhs) noexcept {
+  return not (rhs < lhs);
+}
+
+template <class T>
+bool operator <= (
+  result<T> const& lhs,
+  ::std::error_condition const& rhs
+) noexcept { return not (rhs < lhs); }
+
+template <class T>
+bool operator <= (
+  ::std::error_condition const& lhs,
+  result<T> const& rhs
+) noexcept { return not (rhs < lhs); }
+
+template <class T>
+bool operator <= (result<T> const& res, T const& value) noexcept {
+  return not (value < res);
+}
+
+template <class T>
+bool operator <= (T const& value, result<T> const& res) noexcept {
+  return not (res < value);
+}
+
+/* operator > */
+template <class T>
+constexpr bool operator > (
+  optional<T> const& lhs,
+  optional<T> const& rhs
+) noexcept { return rhs < lhs; }
+
+template <class T>
+constexpr bool operator > (optional<T> const& lhs, nullopt_t) noexcept {
+  return static_cast<bool>(lhs);
+}
+
+template <class T>
+constexpr bool operator > (nullopt_t, optional<T> const&) noexcept {
+  return false;
+}
+
+template <class T>
+constexpr bool operator > (optional<T> const& opt, T const& value) noexcept {
+  return value < opt;
+}
+
+template <class T>
+constexpr bool operator > (T const& value, optional<T> const& opt) noexcept {
+  return opt < value;
+}
+
+template <class T>
+bool operator > (expected<T> const& lhs, expected<T> const& rhs) noexcept {
+  return rhs < lhs;
+}
+
+template <class T>
+bool operator > (expected<T> const& exp, T const& value) noexcept {
+  return value < exp;
+}
+
+template <class T>
+bool operator > (T const& value, expected<T> const& exp) noexcept {
+  return exp < value;
+}
+
+template <class T>
+bool operator > (result<T> const& lhs, result<T> const& rhs) noexcept {
+  return rhs < lhs;
+}
+
+template <class T>
+bool operator > (
+  result<T> const& lhs,
+  ::std::error_condition const& rhs
+) noexcept { return rhs < lhs; }
+
+template <class T>
+bool operator > (
+  ::std::error_condition const& lhs,
+  result<T> const& rhs
+) noexcept { return rhs < lhs; }
+
+template <class T>
+bool operator > (result<T> const& res, T const& value) noexcept {
+  return value < res;
+}
+
+template <class T>
+bool operator > (T const& value, result<T> const& res) noexcept {
+  return res < value;
+}
+
+/* make_ functions */
+template <class Type>
+auto make_optional (Type&& value) -> optional<decay_t<Type>> {
+  return optional<decay_t<Type>> { ::core::forward<Type>(value) };
+}
+
+template <class T>
+auto make_expected (::std::exception_ptr error) -> expected<T> {
+  return expected<T> { error };
+}
+
+template <class T>
+auto make_expected (T&& value) -> enable_if_t<
+  not ::std::is_base_of< ::std::exception, decay_t<T>>::value,
+  expected<decay_t<T>>
+> { return expected<T> { ::core::forward<T>(value) }; }
+
+template <class T, class U>
+auto make_expected (U&& value) -> enable_if_t<
+  ::std::is_base_of< ::std::exception, decay_t<U>>::value,
+  expected<T>
+> {
+  return make_expected<T>(
+    ::std::make_exception_ptr(::core::forward<U>(value))
+  );
+}
+
+template <class T>
+auto make_result (::std::error_condition const& e) -> result<T> {
+  return result<T> { e };
+}
+
+template <
+  class T,
+  class ErrorConditionEnum,
+  class=enable_if_t<
+    std::is_error_condition_enum<ErrorConditionEnum>::value
+  >
+> auto make_result (ErrorConditionEnum e) -> result<T> {
+  return result<T> { e };
+}
+
+template <class T> auto make_result (T&& value) -> result<decay_t<T>> {
+  return result<T> { ::core::forward<T>(value) };
+}
+
+template <class T>
+void swap (optional<T>& lhs, optional<T>& rhs) noexcept(
+  noexcept(lhs.swap(rhs))
+) { lhs.swap(rhs); }
+
+template <class T>
+void swap (expected<T>& lhs, expected<T>& rhs) noexcept(
+  noexcept(lhs.swap(rhs))
+) { lhs.swap(rhs); }
+
+template <class T>
+void swap (result<T>& lhs, result<T>& rhs) noexcept (
+  noexcept(lhs.swap(rhs))
+) { lhs.swap(rhs); }
+
+}} /* namespace core::v1 */
+
+namespace std {
+
+template <class Type>
+struct hash< ::core::v1::optional<Type>> {
+  using result_type = typename hash<Type>::result_type;
+  using argument_type = ::core::v1::optional<Type>;
+
+  result_type operator () (argument_type const& value) const noexcept {
+    return value ? hash<Type> { }(*value) : result_type { };
+  }
+};
+
+template <class Type>
+struct hash< ::core::v1::expected<Type>> {
+  using result_type = typename hash<Type>::result_type;
+  using argument_type = ::core::v1::expected<Type>;
+
+  result_type operator () (argument_type const& value) const noexcept {
+    return value ? hash<Type> { }(*value) : result_type { };
+  }
+};
+
+template <class Type>
+struct hash< ::core::v1::result<Type>> {
+  using result_type = typename hash<Type>::result_type;
+  using argument_type = ::core::v1::result<Type>;
+
+  result_type operator () (argument_type const& value) const noexcept {
+    return value ? hash<Type> { }(*value) : result_type { };
+  }
+};
+
+} /* namespace std */
+
+#endif /* CORE_OPTIONAL_HPP */
diff --git a/src/bsoncxx/third_party/core/include/core/range.hpp b/src/bsoncxx/third_party/core/include/core/range.hpp
new file mode 100644
index 0000000..48d15c4
--- /dev/null
+++ b/src/bsoncxx/third_party/core/include/core/range.hpp
@@ -0,0 +1,313 @@
+#ifndef CORE_RANGE_HPP
+#define CORE_RANGE_HPP
+
+#include <iterator>
+#include <istream>
+#include <utility>
+#include <memory>
+
+#include <cstdlib>
+
+#include <core/type_traits.hpp>
+
+namespace core {
+inline namespace v1 {
+namespace impl {
+
+template <class T>
+class begin {
+  template <class U>
+  static auto check (U&& u) noexcept -> decltype(::std::begin(u));
+  static void check (...) noexcept(false);
+public:
+  using type = decltype(check(::std::declval<T>()));
+  static constexpr bool value = noexcept(check(::std::declval<T>()));
+};
+
+template <class T>
+class end {
+  template <class U>
+  static auto check (U&& u) noexcept -> decltype(::std::end(u));
+  static void check (...) noexcept(false);
+public:
+  using type = decltype(check(::std::declval<T>()));
+  static constexpr bool value = noexcept(check(::std::declval<T>()));
+};
+
+} /* namespace impl */
+
+template <class R>
+struct is_range : ::std::integral_constant<bool,
+  impl::begin<R>::value and impl::end<R>::value
+> { };
+
+template <class Iterator>
+struct range {
+  using traits = ::std::iterator_traits<Iterator>;
+
+  using iterator_category = typename traits::iterator_category;
+
+  using difference_type = typename traits::difference_type;
+  using value_type = typename traits::value_type;
+
+  using reference = typename traits::reference;
+  using pointer = typename traits::pointer;
+
+  using iterator = Iterator;
+
+  static constexpr bool is_input = ::std::is_convertible<
+    iterator_category,
+    ::std::input_iterator_tag
+  >::value;
+
+  static constexpr bool is_output = ::std::is_convertible<
+    iterator_category,
+    ::std::output_iterator_tag
+  >::value;
+
+  static constexpr bool is_forward = ::std::is_convertible<
+    iterator_category,
+    ::std::forward_iterator_tag
+  >::value;
+
+  static constexpr bool is_bidirectional = ::std::is_convertible<
+    iterator_category,
+    ::std::bidirectional_iterator_tag
+  >::value;
+
+  static constexpr bool is_random_access = ::std::is_convertible<
+    iterator_category,
+    ::std::random_access_iterator_tag
+  >::value;
+
+  template <
+    typename Range,
+    typename=enable_if_t<
+      not ::std::is_pointer<iterator>::value and
+      is_range<Range>::value and
+      ::std::is_convertible<typename impl::begin<Range>::type, iterator>::value
+    >
+  > explicit range (Range&& r) noexcept :
+    range { ::std::begin(r), ::std::end(r) }
+  { }
+
+  range (::std::pair<iterator, iterator> pair) noexcept :
+    range { ::std::get<0>(pair), ::std::get<1>(pair) }
+  { }
+
+  range (iterator begin_, iterator end_) noexcept :
+    begin_ { begin_ },
+    end_ { end_ }
+  { }
+
+  range (range const& that) :
+    range { that.begin_, that.end_ }
+  { }
+
+  range (range&& that) noexcept :
+    range { ::std::move(that.begin_), ::std::move(that.end_) }
+  { that.begin_ = that.end_; }
+
+  range () = default;
+  ~range () = default;
+
+  range& operator = (range const& that) {
+    return *this = range { that };
+  }
+
+  range& operator = (range&& that) {
+    range { ::std::move(that) }.swap(*this);
+    return *this;
+  }
+
+  reference operator [](difference_type idx) const {
+    static_assert(is_random_access, "can only subscript into random-access");
+    return idx < 0 ? this->end()[idx] : this->begin()[idx];
+  }
+
+  iterator begin () const { return this->begin_; }
+  iterator end () const { return this->end_; }
+
+  reference front () const { return *this->begin(); }
+  reference back () const {
+    static_assert(is_bidirectional, "can only get back of bidirectional");
+    return *::std::prev(this->end());
+  }
+
+  bool empty () const { return this->begin() == this->end(); }
+
+  difference_type size () const {
+    static_assert(is_forward, "can only get size of forward-range");
+    return ::std::distance(this->begin(), this->end());
+  }
+
+  /* Creates an open-ended range of [start, stop) */
+  range slice (difference_type start, difference_type stop) const {
+    static_assert(is_forward, "can only slice forward-range");
+    /* Behavior is:
+     * if start is negative, the begin marker is this->end() - start
+     * if stop is negative, the end marker is this->end() - stop
+     * if start is positive, the begin marker is this->begin() + start
+     * if stop is positive, the end marker is this->begin() + stop
+     *
+     * if start and stop are positive, and stop is less than or equal to start,
+     * an empty range is returned.
+     *
+     * if start and stop are negative and stop is less than or equal to start,
+     * an empty range is returned.
+     *
+     * if start is positive and stop is negative and abs(stop) + start is
+     * greater than or equal to this->size(), an empty range is returned.
+     *
+     * if start is negative and stop is positive and this->size() + start is
+     * greater or equal to stop, an empty range is returned.
+     *
+     * The first two conditions can be computed cheaply, while the third and
+     * fourth are a bit more expensive, but WILL be required no matter what
+     * iterator type we are. However we don't compute the size until after
+     * we've checked the first two conditions
+     *
+     * An example with python style slicing for each would be:
+     * [4:3] -> empty range
+     * [-4:-4] -> empty range
+     * [7:-4] -> empty range for string of size 11 or more
+     * [-4:15] -> empty range for a string of size 19 or less.
+     */
+    bool const start_positive = start > 0;
+    bool const stop_positive = stop > 0;
+    bool const stop_less = stop < start;
+    bool const first_return_empty =
+      (start_positive and stop_positive and stop_less) or
+      (not start_positive and not stop_positive and stop_less);
+    if (first_return_empty) { return range { }; }
+
+    /* now safe to compute size */
+    auto const size = this->size();
+    auto third_empty = ::std::abs(stop) + start;
+
+    bool const second_return_empty =
+      (start_positive and not stop_positive and third_empty >= size) or
+      (not start_positive and stop_positive and size + start >= stop);
+    if (second_return_empty) { return range { }; }
+
+    /* While the code below technically works for all iterators it is
+     * ineffecient in some cases for bidirectional ranges, where either of
+     * start or stop are negative.
+     * TODO: Specialize for bidirectional operators
+     */
+    if (not start_positive) { start = size + start; }
+    if (not stop_positive) { stop = size + stop; }
+
+    auto begin = this->begin();
+    ::std::advance(begin, start);
+
+    auto end = begin;
+    ::std::advance(end, stop - start);
+
+    return range { begin, end };
+  }
+
+  /* Creates an open-ended range of [start, end()) */
+  range slice (difference_type start) const {
+    static_assert(is_forward, "can only slice forward-range");
+    return range { split(start).second };
+  }
+
+  ::std::pair<range, range> split (difference_type idx) const {
+    static_assert(is_forward,"can only split a forward-range");
+    if (idx >= 0) {
+      range second { *this };
+      second.pop_front_upto(idx);
+      return ::std::make_pair(range { this->begin(), second.begin() }, second);
+    }
+
+    range first { *this };
+    first.pop_back_upto(-idx);
+    return ::std::make_pair(first, range { first.end(), this->end() });
+  }
+
+  /* mutates range */
+  void pop_front (difference_type n) { ::std::advance(this->begin_, n); }
+  void pop_front () { ++this->begin_; }
+
+  void pop_back (difference_type n) {
+    static_assert(is_bidirectional, "can only pop-back bidirectional-range");
+    ::std::advance(this->end_, -n);
+  }
+
+  void pop_back () {
+    static_assert(is_bidirectional, "can only pop-back bidirectional-range");
+    --this->end_;
+  }
+
+  /* Negative argument causes no change */
+  void pop_front_upto (difference_type n) {
+    ::std::advance(
+      this->begin_,
+      ::std::min(::std::max<difference_type>(0, n), this->size())
+    );
+  }
+
+  /* Negative argument causes no change */
+  void pop_back_upto (difference_type n) {
+    static_assert(is_bidirectional, "can only pop-back-upto bidirectional");
+    ::std::advance(
+      this->end_,
+      -::std::min(::std::max<difference_type>(0, n), this->size())
+    );
+  }
+
+  void swap (range& that) noexcept(is_nothrow_swappable<iterator>::value) {
+    using ::std::swap;
+    swap(this->begin_, that.begin_);
+    swap(this->end_, that.end_);
+  }
+
+private:
+  iterator begin_;
+  iterator end_;
+};
+
+template <class Iterator>
+auto make_range (Iterator begin, Iterator end) -> range<Iterator> {
+  return range<Iterator> { begin, end };
+}
+
+template <class Range>
+auto make_range (Range&& value) -> range<decltype(::std::begin(value))> {
+  return make_range(::std::begin(value), ::std::end(value));
+}
+
+template <class Range>
+auto make_ptr_range (Range&& value) -> range<
+  decltype(::std::addressof(*::std::begin(value)))
+>;
+
+/* Used like: core::make_range<char>(::std::cin) */
+template <
+  class T,
+  class CharT,
+  class Traits=::std::char_traits<CharT>
+> auto make_range (::std::basic_istream<CharT, Traits>& stream) -> range<
+  ::std::istream_iterator<T, CharT, Traits>
+> {
+  using iterator = ::std::istream_iterator<T, CharT, Traits>;
+  return make_range(iterator { stream }, iterator { });
+}
+
+template <class CharT, class Traits=::std::char_traits<CharT>>
+auto make_range (::std::basic_streambuf<CharT, Traits>* buffer) -> range<
+  ::std::istreambuf_iterator<CharT, Traits>
+> {
+  using iterator = ::std::istreambuf_iterator<CharT, Traits>;
+  return make_range(iterator { buffer }, iterator { });
+}
+
+template <class Iterator>
+void swap (range<Iterator>& lhs, range<Iterator>& rhs) noexcept(
+  noexcept(lhs.swap(rhs))
+) { lhs.swap(rhs); }
+
+}} /* namespace core::v1 */
+
+#endif /* CORE_RANGE_HPP */
diff --git a/src/bsoncxx/third_party/core/include/core/string.hpp b/src/bsoncxx/third_party/core/include/core/string.hpp
new file mode 100644
index 0000000..9e149d1
--- /dev/null
+++ b/src/bsoncxx/third_party/core/include/core/string.hpp
@@ -0,0 +1,369 @@
+#ifndef CORE_STRING_HPP
+#define CORE_STRING_HPP
+
+#include <initializer_list>
+#include <functional>
+#include <stdexcept>
+#include <algorithm>
+#include <iterator>
+#include <string>
+#include <limits>
+
+namespace core {
+inline namespace v1 {
+
+template <class CharT, class Traits=::std::char_traits<CharT>>
+struct basic_string_view {
+  using difference_type = ::std::ptrdiff_t;
+  using value_type = CharT;
+  using size_type = ::std::size_t;
+
+  using reference = value_type const&;
+  using pointer = value_type const*;
+
+  using const_reference = reference;
+  using const_pointer = pointer;
+
+  using const_iterator = pointer;
+  using iterator = const_iterator;
+
+  using const_reverse_iterator = ::std::reverse_iterator<const_iterator>;
+  using reverse_iterator = const_reverse_iterator;
+
+  using traits = Traits;
+
+  static constexpr size_type npos = ::std::numeric_limits<size_type>::max();
+
+  template <class Allocator>
+  basic_string_view (
+    ::std::basic_string<CharT, Traits, Allocator> const& that
+  ) : str { that.data() }, len { that.size() } { }
+
+  constexpr basic_string_view (pointer str, size_type len) noexcept :
+    str { str },
+    len { len }
+  { }
+
+  basic_string_view (pointer str) noexcept :
+    basic_string_view { str, traits::length(str) }
+  { }
+
+  constexpr basic_string_view (basic_string_view const& that) noexcept :
+    str { that.str },
+    len { that.len }
+  { }
+
+  constexpr basic_string_view () noexcept :
+    str { nullptr },
+    len { 0 }
+  { }
+
+  basic_string_view& operator = (basic_string_view const& that) noexcept {
+    basic_string_view { that }.swap(*this);
+    return *this;
+  }
+
+  template <class Allocator>
+  explicit operator ::std::basic_string<CharT, Traits, Allocator> () const {
+    return ::std::basic_string<CharT, Traits, Allocator> {
+      this->data(),
+      this->size()
+    };
+  }
+
+  template <class Allocator=std::allocator<CharT>>
+  ::std::basic_string<CharT, Traits, Allocator> to_string (
+    Allocator const& allocator = Allocator()
+  ) const {
+    return ::std::basic_string<CharT, Traits, Allocator> {
+      this->data(),
+      this->size(),
+      allocator
+    };
+  }
+
+  constexpr const_iterator begin () const noexcept { return this->data(); }
+  constexpr const_iterator end () const noexcept {
+    return this->data() + this->size();
+  }
+
+  constexpr const_iterator cbegin () const noexcept { return this->begin(); }
+  constexpr const_iterator cend () const noexcept { return this->end(); }
+
+  const_reverse_iterator rbegin () const noexcept {
+    return const_reverse_iterator { this->end()};
+  }
+
+  const_reverse_iterator rend () const noexcept {
+    return const_reverse_iterator { this->begin() };
+  }
+
+  const_reverse_iterator crbegin () const noexcept { return this->rbegin(); }
+  const_reverse_iterator crend () const noexcept { return this->rend(); }
+
+  constexpr size_type max_size () const noexcept { return this->size(); }
+  constexpr size_type length () const noexcept { return this->size(); }
+  constexpr size_type size () const noexcept { return this->len; }
+
+  constexpr bool empty () const noexcept { return this->size() == 0; }
+
+  constexpr reference operator [] (size_type idx) const {
+    return this->str[idx];
+  }
+
+  constexpr reference front () const { return this->str[0]; }
+  constexpr reference back () const { return this->str[this->size() - 1]; }
+  constexpr pointer data () const { return this->str; }
+
+  void remove_prefix (size_type n) {
+    if (n > this->size()) { n = this->size(); }
+    this->str += n;
+    this->len -= n;
+  }
+
+  void remove_suffix (size_type n) {
+    if (n > this->size()) { n = this->size(); }
+    this->len -= n;
+  }
+
+  void clear () noexcept {
+    this->str = nullptr;
+    this->len = 0;
+  }
+
+  constexpr basic_string_view substr (size_type pos, size_type n=npos) const {
+    return pos > this->size()
+      ? throw ::std::out_of_range { "start position out of range" }
+      : basic_string_view {
+        this->data() + pos,
+        n == npos or pos + n > this->size()
+          ? (this->size() - pos)
+          : n
+      };
+  }
+
+  bool starts_with (value_type value) const noexcept {
+    return not this->empty() and traits::eq(value, this->front());
+  }
+
+  bool ends_with (value_type value) const noexcept {
+    return not this->empty() and traits::eq(value, this->back());
+  }
+
+  bool starts_with (basic_string_view that) const noexcept {
+    return this->size() >= that.size() and
+      traits::compare(this->data(), that.data(), that.size()) == 0;
+  }
+
+  bool ends_with (basic_string_view that) const noexcept {
+    return this->size() >= that.size() and
+      traits::compare(
+        this->data() + this->size() - that.size(),
+        that.data(),
+        that.size()
+      ) == 0;
+  }
+
+  difference_type compare (basic_string_view that) const {
+    auto cmp = traits::compare(
+      this->data(),
+      that.data(),
+      ::std::min(this->size(), that.size())
+    );
+
+    if (cmp != 0) { return cmp; }
+    if (this->size() == that.size()) { return 0; }
+    if (this->size() < that.size()) { return -1; }
+    return 1;
+  }
+
+  reference at (size_type idx) const {
+    if (idx >= this->size()) {
+      throw ::std::out_of_range { "requested index out of range" };
+    }
+    return this->str[idx];
+  }
+
+  /* functions that take a string-ref */
+  size_type find_first_not_of (basic_string_view that) const {
+    for (auto iter = this->begin(); iter != this->end(); ++iter) {
+      if (traits::find(that.data(), that.size(), *iter)) { continue; }
+      return ::std::distance(this->begin(), iter);
+    }
+    return npos;
+  }
+
+  size_type find_last_not_of (basic_string_view that) const {
+    for (auto iter = this->rbegin(); iter != this->rend(); ++iter) {
+      if (traits::find(that.data(), that.size(), *iter)) { continue; }
+      return this->size() - ::std::distance(this->rbegin(), iter) - 1;
+    }
+    return npos;
+  }
+
+  size_type find_first_of (basic_string_view that) const {
+    auto iter = ::std::find_first_of(
+      this->begin(), this->end(),
+      that.begin(), that.end(),
+      traits::eq
+    );
+    if (iter == this->end()) { return npos; }
+    return ::std::distance(this->begin(), iter);
+  }
+
+  size_type find_last_of (basic_string_view that) const {
+    auto iter = ::std::find_first_of(
+      this->rbegin(), this->rend(),
+      that.rbegin(), that.rend(),
+      traits::eq
+    );
+    if (iter == this->rend()) { return npos; }
+    return this->size() - ::std::distance(this->rbegin(), iter) - 1;
+  }
+
+  size_type rfind (basic_string_view that) const {
+    auto iter = ::std::search(
+      this->rbegin(), this->rend(),
+      that.rbegin(), that.rend(),
+      traits::eq
+    );
+    if (iter == this->rend()) { return npos; }
+    return this->size() - ::std::distance(this->rbegin(), iter) - 1;
+  }
+
+  size_type find (basic_string_view that) const {
+    auto iter = ::std::search(
+      this->begin(), this->end(),
+      that.begin(), that.end(),
+      traits::eq
+    );
+    if (iter == this->end()) { return npos; }
+    return ::std::distance(this->begin(), iter);
+  }
+
+  /* functions that take a single CharT */
+  size_type find_first_not_of (value_type value) const {
+    auto end = this->end();
+    auto iter = ::std::find_if_not(
+      this->begin(),
+      end,
+      [value](value_type val) { return traits::eq(val, value); }
+    );
+    if (iter == end) { return npos; }
+    return ::std::distance(this->begin(), iter);
+  }
+
+  size_type find_last_not_of (value_type value) const {
+    auto end = this->rend();
+    auto iter = ::std::find_if_not(
+      this->rbegin(),
+      end,
+      [value](value_type val) { return traits::eq(val, value); }
+    );
+    if (iter == end) { return npos; }
+    return this->size() - ::std::distance(this->rbegin(), iter) - 1;
+  }
+
+  size_type find_first_of (value_type value) const {
+    return this->find(value);
+  }
+
+  size_type find_last_of (value_type value) const {
+    return this->rfind(value);
+  }
+
+  size_type rfind (value_type value) const {
+    auto end = this->rend();
+    auto iter = ::std::find(this->rbegin(), end, value);
+    if (iter == end) { return npos; }
+    return this->size() - ::std::distance(this->rbegin(), iter) -1;
+  }
+
+  size_type find (value_type value) const {
+    auto end = this->end();
+    auto iter = ::std::find(this->begin(), end, value);
+    if (iter == end) { return npos; }
+    return ::std::distance(this->begin(), iter);
+  }
+
+  void swap (basic_string_view& that) noexcept {
+    using ::std::swap;
+    swap(this->str, that.str);
+    swap(this->len, that.len);
+  }
+
+private:
+  pointer str;
+  size_type len;
+};
+
+using u32string_view = basic_string_view<char32_t>;
+using u16string_view = basic_string_view<char16_t>;
+using wstring_view = basic_string_view<wchar_t>;
+using string_view = basic_string_view<char>;
+
+template <class CharT, typename Traits>
+bool operator == (
+  basic_string_view<CharT, Traits> lhs,
+  basic_string_view<CharT, Traits> rhs
+) noexcept { return lhs.size() == rhs.size() and lhs.compare(rhs) == 0; }
+
+template <class CharT, typename Traits>
+bool operator != (
+  basic_string_view<CharT, Traits> lhs,
+  basic_string_view<CharT, Traits> rhs
+) noexcept { return lhs.size() != rhs.size() or lhs.compare(rhs) != 0; }
+
+template <class CharT, typename Traits>
+bool operator >= (
+  basic_string_view<CharT, Traits> lhs,
+  basic_string_view<CharT, Traits> rhs
+) noexcept { return lhs.compare(rhs) >= 0; }
+
+template <class CharT, typename Traits>
+bool operator <= (
+  basic_string_view<CharT, Traits> lhs,
+  basic_string_view<CharT, Traits> rhs
+) noexcept { return lhs.compare(rhs) <= 0; }
+
+template <class CharT, typename Traits>
+bool operator > (
+  basic_string_view<CharT, Traits> lhs,
+  basic_string_view<CharT, Traits> rhs
+) noexcept { return lhs.compare(rhs) > 0; }
+
+template <class CharT, typename Traits>
+bool operator < (
+  basic_string_view<CharT, Traits> lhs,
+  basic_string_view<CharT, Traits> rhs
+) noexcept { return lhs.compare(rhs) < 0; }
+
+template <class CharT, class Traits>
+::std::basic_ostream<CharT, Traits>& operator << (
+  ::std::basic_ostream<CharT, Traits>& os,
+  basic_string_view<CharT, Traits> const& str
+) { return os << str.to_string(); }
+
+template <class CharT, class Traits>
+void swap (
+  basic_string_view<CharT, Traits>& lhs,
+  basic_string_view<CharT, Traits>& rhs
+) noexcept { return lhs.swap(rhs); }
+
+}} /* namespace core::v1 */
+
+namespace std {
+
+template <typename CharT, typename Traits>
+struct hash<core::v1::basic_string_view<CharT, Traits>> {
+  using argument_type = core::v1::basic_string_view<CharT, Traits>;
+  using result_type = size_t;
+
+  result_type operator ()(argument_type const& ref) const noexcept {
+    return hash<typename argument_type::pointer> { }(ref.data());
+  }
+};
+
+} /* namespace std */
+
+#endif /* CORE_STRING_HPP */
diff --git a/src/bsoncxx/third_party/core/include/core/type_traits.hpp b/src/bsoncxx/third_party/core/include/core/type_traits.hpp
new file mode 100644
index 0000000..9fc5e07
--- /dev/null
+++ b/src/bsoncxx/third_party/core/include/core/type_traits.hpp
@@ -0,0 +1,267 @@
+#ifndef CORE_TYPE_TRAITS_HPP
+#define CORE_TYPE_TRAITS_HPP
+
+#include <type_traits>
+#include <utility>
+
+namespace core {
+inline namespace v1 {
+
+/* custom type traits */
+/* tuple_size is used by unpack, so we expect it to be available.
+ * We also expect ::std::get<N> to be available for the give type T
+ */
+template <class T>
+class is_unpackable {
+  template <class U> using tuple_size_t = typename ::std::tuple_size<U>::type;
+  template <class U> static void check (tuple_size_t<U>*) noexcept;
+  template <class> static void check (...) noexcept(false);
+public:
+  static constexpr bool value = noexcept(check<T>(nullptr));
+};
+
+/* Used for types that have a .at(size_type) member function */
+template <class T>
+class is_runpackable {
+  template <class U>
+  static auto check (U* u) noexcept -> decltype(u->at(0ul), void());
+  template <class> static void check (...) noexcept(false);
+public:
+  static constexpr bool value = noexcept(check<T>(nullptr));
+};
+
+/* extracts the class of a member function ponter */
+template <class T> struct class_of { using type = T; };
+template <class Signature, class Type>
+struct class_of<Signature Type::*> { using type = Type; };
+
+/* forward declaration */
+template <class... Args> struct invokable;
+template <class... Args> struct invoke_of;
+template <class T> struct result_of; /* SFINAE result_of */
+
+/* C++14 style aliases for standard traits */
+template <class T>
+using remove_volatile_t = typename ::std::remove_volatile<T>::type;
+
+template <class T>
+using remove_const_t = typename ::std::remove_const<T>::type;
+template <class T> using remove_cv_t = typename ::std::remove_cv<T>::type;
+
+template <class T>
+using add_volatile_t = typename ::std::add_volatile<T>::type;
+template <class T> using add_const_t = typename ::std::add_const<T>::type;
+template <class T> using add_cv_t = typename ::std::add_cv<T>::type;
+
+template <class T>
+using add_lvalue_reference_t = typename ::std::add_lvalue_reference<T>::type;
+
+template <class T>
+using add_rvalue_reference_t = typename ::std::add_rvalue_reference<T>::type;
+
+template <class T>
+using remove_reference_t = typename ::std::remove_reference<T>::type;
+
+template <class T>
+using remove_pointer_t = typename ::std::remove_pointer<T>::type;
+
+template <class T> using add_pointer_t = typename ::std::add_pointer<T>::type;
+
+template <class T>
+using make_unsigned_t = typename ::std::make_unsigned<T>::type;
+template <class T> using make_signed_t = typename ::std::make_signed<T>::type;
+
+template <class T>
+using remove_extent_t = typename ::std::remove_extent<T>::type;
+
+template <class T>
+using remove_all_extents_t = typename ::std::remove_all_extents<T>::type;
+
+template < ::std::size_t Len, ::std::size_t Align>
+using aligned_storage_t = typename ::std::aligned_storage<Len, Align>::type;
+
+template <class T> using decay_t = typename ::std::decay<T>::type;
+
+template <bool B, class T = void>
+using enable_if_t = typename ::std::enable_if<B, T>::type;
+
+template <bool B, class T, class F>
+using conditional_t = typename ::std::conditional<B, T, F>::type;
+
+template <class T>
+using underlying_type_t = typename ::std::underlying_type<T>::type;
+
+/* custom type trait specializations */
+template <class... Args> using invoke_of_t = typename invoke_of<Args...>::type;
+template <class T> using class_of_t = typename class_of<T>::type;
+
+namespace impl {
+
+struct undefined { undefined (...); };
+
+/* Get the result of an attempt at the INVOKE expression */
+/* fallback */
+template <class... Args> auto invoke_expr (undefined, Args&&...) -> undefined;
+
+template <class Functor, class Object, class... Args>
+auto invoke_expr (Functor&& fun, Object&& obj, Args&&... args) -> enable_if_t<
+  ::std::is_member_function_pointer<remove_reference_t<Functor>>::value and
+  ::std::is_base_of<
+    class_of_t<remove_reference_t<Functor>>,
+    remove_reference_t<Object>
+  >::value,
+  decltype((::std::forward<Object>(obj).*fun)(::std::forward<Args>(args)...))
+>;
+
+template <class Functor, class Object, class... Args>
+auto invoke_expr (Functor&& fun, Object&& obj, Args&&... args) -> enable_if_t<
+  ::std::is_member_function_pointer<remove_reference_t<Functor>>::value and
+  not ::std::is_base_of<
+    class_of_t<remove_reference_t<Functor>>,
+    remove_reference_t<Object>
+  >::value,
+  decltype(
+    ((*::std::forward<Object>(obj)).*fun)(::std::forward<Args>(args)...)
+  )
+>;
+
+template <class Functor, class Object>
+auto invoke_expr (Functor&& functor, Object&& object) -> enable_if_t<
+  ::std::is_member_object_pointer<remove_reference_t<Functor>>::value and
+  ::std::is_base_of<
+    class_of_t<remove_reference_t<Functor>>,
+    remove_reference_t<Object>
+  >::value,
+  decltype(::std::forward<Object>(object).*functor)
+>;
+
+template <class Functor, class Object>
+auto invoke_expr (Functor&& functor, Object&& object) -> enable_if_t<
+  ::std::is_member_object_pointer<remove_reference_t<Functor>>::value and
+  not ::std::is_base_of<
+    class_of_t<remove_reference_t<Functor>>,
+    remove_reference_t<Object>
+  >::value,
+  decltype((*::std::forward<Object>(object)).*functor)
+>;
+
+template <class Functor, class... Args>
+auto invoke_expr (Functor&& functor, Args&&... args) -> decltype(
+  ::std::forward<Functor>(functor)(::std::forward<Args>(args)...)
+);
+
+template <bool, class... Args> struct invoke_of { };
+template <class... Args>
+struct invoke_of<true, Args...> {
+  using type = decltype(invoke_expr(::std::declval<Args>()...));
+};
+
+/* swappable implementation details */
+using ::std::declval;
+using ::std::swap;
+
+template <class T, class U>
+class is_swappable {
+  template <class X, class Y>
+  static auto check (int) noexcept -> decltype(
+    swap(declval<X&>(), declval<Y&>()),
+    void()
+  );
+  template <class X, class Y> static void check (...) noexcept(false);
+public:
+  static constexpr bool value =
+    noexcept(check<T, U>(0)) and noexcept(check<U, T>(0));
+};
+
+template <class T, class U>
+struct is_nothrow_swappable : ::std::integral_constant<
+  bool,
+  is_swappable<T, U>::value and noexcept(swap(declval<T&>(), declval<U&>()))
+> { };
+
+} /* namespace impl */
+
+template <class... Args> struct invokable : ::std::integral_constant<
+  bool,
+  not ::std::is_same<
+    decltype(impl::invoke_expr(::std::declval<Args>()...)),
+    impl::undefined
+  >::value
+> { };
+
+template <class... Args> struct invoke_of :
+  impl::invoke_of<invokable<Args...>::value, Args...>
+{ };
+
+template <class F, class... Args>
+struct result_of<F(Args...)> : invoke_of<F, Args...> { };
+
+template <class T> using result_of_t = typename result_of<T>::type;
+
+template <class... Ts> struct common_type;
+
+template <class T> struct common_type<T> { using type = decay_t<T>; };
+template <class T, class U>
+struct common_type<T, U> {
+  using type = decay_t<
+    decltype(true ? ::std::declval<T>() : ::std::declval<U>())
+  >;
+};
+
+template <class T, class U, class... Ts>
+struct common_type<T, U, Ts...> {
+  using type = typename common_type<
+    typename common_type<T, U>::type,
+    Ts...
+  >::type;
+};
+
+template <class... T> using common_type_t = typename common_type<T...>::type;
+
+/* is_null_pointer */
+template <class T> struct is_null_pointer : ::std::false_type { };
+
+template <>
+struct is_null_pointer<add_cv_t< ::std::nullptr_t>> : ::std::true_type { };
+template <>
+struct is_null_pointer< ::std::nullptr_t volatile> : ::std::true_type { };
+template <>
+struct is_null_pointer< ::std::nullptr_t const> : ::std::true_type { };
+template <>
+struct is_null_pointer< ::std::nullptr_t> : ::std::true_type { };
+
+/* is_swappable */
+template <class T, class U=T>
+using is_swappable = ::std::integral_constant<
+  bool,
+  impl::is_swappable<T, U>::value
+>;
+
+/* is_nothrow_swappable */
+template <class T, class U=T>
+using is_nothrow_swappable = impl::is_nothrow_swappable<T, U>;
+
+/* all-traits */
+template <class...> struct all_traits;
+template <class T, class... Args>
+struct all_traits<T, Args...> : ::std::integral_constant<bool,
+  T::value and all_traits<Args...>::value
+> { };
+template <> struct all_traits<> : ::std::true_type { };
+
+/* any-traits */
+template <class...> struct any_traits;
+template <class T, class... Args>
+struct any_traits<T, Args...> : ::std::integral_constant<bool,
+  T::value or any_traits<Args...>::value
+> { };
+template <> struct any_traits<> : ::std::false_type { };
+
+/* no-traits */
+template <class... Args> struct no_traits : ::std::integral_constant<bool,
+  not all_traits<Args...>::value
+> { };
+
+}} /* namespace core::v1 */
+
+#endif /* CORE_TYPE_TRAITS_HPP */
diff --git a/src/bsoncxx/third_party/core/include/core/utility.hpp b/src/bsoncxx/third_party/core/include/core/utility.hpp
new file mode 100644
index 0000000..54a5e11
--- /dev/null
+++ b/src/bsoncxx/third_party/core/include/core/utility.hpp
@@ -0,0 +1,142 @@
+#ifndef CORE_UTILITY_HPP
+#define CORE_UTILITY_HPP
+
+#include <functional>
+
+#include <cstddef>
+
+#include <core/type_traits.hpp>
+
+namespace core {
+inline namespace v1 {
+namespace impl {
+
+template <class T, T... I> struct integer_sequence {
+  static_assert(
+    ::std::is_integral<T>::value,
+    "integer_sequence must use an integral type"
+  );
+
+  template <T N> using append = integer_sequence<T, I..., N>;
+  static constexpr ::std::size_t size () noexcept { return sizeof...(I); }
+  using next = append<size()>;
+  using type = T;
+};
+
+template <class T, T Index, ::std::size_t N>
+struct sequence_generator {
+  static_assert(Index >= 0, "Index cannot be negative");
+  using type = typename sequence_generator<T, Index - 1, N - 1>::type::next;
+};
+
+template <class T, T Index>
+struct sequence_generator<T, Index, 0ul> { using type = integer_sequence<T>; };
+
+template < ::std::size_t Index, class T, class U, class... Types>
+struct typelist_index {
+  using type = typename typelist_index<Index + 1, T, Types...>::type;
+  static constexpr ::std::size_t value = Index;
+};
+
+template < ::std::size_t Index, class T, class... Types>
+struct typelist_index<Index, T, T, Types...> {
+  using type = typelist_index;
+  static constexpr ::std::size_t value = Index;
+};
+
+} /* namespace impl */
+
+template <class T>
+constexpr T&& forward (remove_reference_t<T>& t) noexcept {
+  return static_cast<T&&>(t);
+}
+
+template <class T>
+constexpr T&& forward (remove_reference_t<T>&& t) noexcept {
+  return static_cast<T&&>(t);
+}
+
+template <class T>
+constexpr auto move (T&& t) noexcept -> decltype(
+  static_cast<remove_reference_t<T>&&>(t)
+) { return static_cast<remove_reference_t<T>&&>(t); }
+
+
+template <class T, T... I>
+using integer_sequence = impl::integer_sequence<T, I...>;
+
+template < ::std::size_t... I>
+using index_sequence = integer_sequence< ::std::size_t, I...>;
+
+template <class T, T N>
+using make_integer_sequence = typename impl::sequence_generator<T, N, N>::type;
+
+template < ::std::size_t N>
+using make_index_sequence = make_integer_sequence< ::std::size_t, N>;
+
+template <class T, class... Ts>
+using typelist_index = ::std::integral_constant<
+  ::std::size_t,
+  impl::typelist_index<0ul, T, Ts...>::type::value
+>;
+
+/* N3761 (with some additions) */
+template < ::std::size_t N, class T, class... Ts>
+struct type_at { using type = typename type_at<N - 1, Ts...>::type; };
+
+template <class T, class... Ts>
+struct type_at<0ul, T, Ts...> { using type = T; };
+
+template < ::std::size_t N, class... Ts>
+using type_at_t = typename type_at<N, Ts...>::type;
+
+template < ::std::size_t N, class T, class... Ts>
+constexpr auto value_at (T&& value, Ts&&...) -> enable_if_t<
+  N == 0 and N < (sizeof...(Ts) + 1),
+  decltype(::core::forward<T>(value))
+> { return ::core::forward<T>(value); }
+
+template < ::std::size_t N, class T, class... Ts>
+constexpr auto value_at (T&&, Ts&&... values) -> enable_if_t<
+  N != 0 and N < (sizeof...(Ts) + 1),
+  type_at_t<N, T, Ts...>
+> { return value_at<N - 1, Ts...>(::core::forward<Ts>(values)...); }
+
+template <class Callable>
+struct scope_guard final {
+
+  static_assert(
+    ::std::is_nothrow_move_constructible<Callable>::value,
+    "Given type must be nothrow move constructible"
+  );
+
+  explicit scope_guard (Callable callable) noexcept :
+    callable { ::core::move(callable) },
+    dismissed { false }
+  { }
+
+  scope_guard (scope_guard const&) = delete;
+  scope_guard (scope_guard&&) = default;
+  scope_guard () = delete;
+  ~scope_guard () noexcept { if (not this->dismissed) { callable(); } }
+
+  scope_guard& operator = (scope_guard const&) = delete;
+  scope_guard& operator = (scope_guard&&) = default;
+
+  void dismiss () noexcept { this->dismissed = true; }
+
+private:
+  Callable callable;
+  bool dismissed;
+};
+
+template <class Callable>
+auto make_scope_guard(Callable&& callable) -> scope_guard<decay_t<Callable>> {
+  return scope_guard<decay_t<Callable>> {
+    ::core::forward<Callable>(callable)
+  };
+}
+
+}} /* namespace core::v1 */
+
+#endif /* CORE_UTILITY_HPP */
diff --git a/src/bsoncxx/third_party/core/include/core/variant.hpp b/src/bsoncxx/third_party/core/include/core/variant.hpp
new file mode 100644
index 0000000..0027a0d
--- /dev/null
+++ b/src/bsoncxx/third_party/core/include/core/variant.hpp
@@ -0,0 +1,400 @@
+#ifndef CORE_VARIANT_HPP
+#define CORE_VARIANT_HPP
+
+#include <core/type_traits.hpp>
+#include <core/functional.hpp>
+#include <core/utility.hpp>
+
+#include <stdexcept>
+#include <typeinfo>
+#include <limits>
+
+#include <cstdint>
+
+namespace core {
+inline namespace v1 {
+namespace impl {
+
+template <class... Ts> union discriminate;
+template <> union discriminate<> { };
+template <class T, class... Ts>
+union discriminate<T, Ts...> {
+  T value;
+  discriminate<Ts...> rest;
+};
+
+/* Used to provide lambda based pattern matching for the variant
+ * Based off of Dave Abrahams C++11 'generic lambda' example.
+ */
+template <class... Lambdas> struct overload;
+template <class Lambda> struct overload<Lambda> : Lambda {
+  using call_type = Lambda;
+  using call_type::operator ();
+};
+template <class Lambda, class... Lambdas>
+struct overload<Lambda, Lambdas...> :
+  private Lambda,
+  private overload<Lambdas...>::call_type
+{
+  using base_type = typename overload<Lambdas...>::call_type;
+
+  using lambda_type = Lambda;
+  using call_type = overload;
+
+  overload (Lambda&& lambda, Lambdas&&... lambdas) :
+    lambda_type(::core::forward<Lambda>(lambda)),
+    base_type(::core::forward<Lambdas>(lambdas)...)
+  { }
+
+  using lambda_type::operator ();
+  using base_type::operator ();
+};
+
+template <class... Lambdas>
+auto make_overload(Lambdas&&... lambdas) -> overload<Lambdas...> {
+  return overload<Lambdas...> { ::core::forward<Lambdas>(lambdas)... };
+}
+
+template <class Visitor, class Type, class Data, class Result, class... Args>
+auto visitor_gen () -> Result {
+  return [](Visitor&& visitor, Data& data, Args&&... args) {
+    return invoke(
+      ::core::forward<Visitor>(visitor),
+      reinterpret_cast<Type&>(data),
+      ::core::forward<Args>(args)...
+    );
+  };
+}
+
+} /* namespace impl */
+
+
+struct bad_variant_get final : ::std::logic_error {
+  using ::std::logic_error::logic_error;
+};
+
+/* visitation semantics require that, given a callable type C, and variadic
+ * arguments Args... that the return type of the visit will be SFINAE-ified
+ * as common_type_t<invoke_of_t<C, Args>...> (this assumes a variadic
+ * approach can be taken with common_type, which it cannot at this time. A
+ * custom SFINAE-capable version has been written within the type traits
+ * component.
+ *
+ * Obviously if a common type cannot be found, then the visitation function
+ * cannot be generated.
+ *
+ * These same semantics are required for variant<Ts...>::match which simply
+ * calls visit with a generate overload<Lambdas...> type.
+ */
+template <class... Ts>
+class variant final {
+  static_assert(
+    sizeof...(Ts) < ::std::numeric_limits<uint8_t>::max(),
+    "Cannot have more elements than variant can contain"
+  );
+
+  using tuple_type = ::std::tuple<Ts...>;
+  using storage_type = aligned_storage_t<
+    sizeof(impl::discriminate<Ts...>),
+    ::std::alignment_of<impl::discriminate<Ts...>>::value
+  >;
+
+  template < ::std::size_t N>
+  using element = typename ::std::tuple_element<N, tuple_type>::type;
+
+  template < ::std::size_t N>
+  using index = ::std::integral_constant< ::std::size_t, N>;
+
+  struct copier final {
+    using data_type = ::std::reference_wrapper<storage_type>;
+    data_type data;
+
+    template <class T>
+    void operator ()(T const& value) const {
+      new (::std::addressof(this->data.get())) T { value };
+    }
+  };
+
+  struct mover final {
+    using data_type = ::std::reference_wrapper<storage_type>;
+    data_type data;
+
+    template <class T>
+    void operator () (T&& value) {
+      new (::std::addressof(this->data.get())) decay_t<T> { ::std::move(value) };
+    }
+  };
+
+  struct destroyer final {
+    template <class T> void operator ()(T const& value) const { value.~T(); }
+  };
+
+  struct swapper final {
+    using data_type = ::std::reference_wrapper<storage_type>;
+    data_type data;
+    template <class T>
+    void operator ()(T&& value) noexcept(is_nothrow_swappable<T>::value) {
+      using ::std::swap;
+      swap(reinterpret_cast<decay_t<T>&>(this->data.get()), value);
+    }
+  };
+
+  struct equality final {
+    using data_type = ::std::reference_wrapper<storage_type const>;
+    data_type data;
+
+    template <class T>
+    bool operator ()(T const& value) {
+      return ::std::equal_to<T> { }(
+        reinterpret_cast<T const&>(this->data.get()),
+        value
+      );
+    }
+  };
+
+  struct less_than final {
+    using data_type = ::std::reference_wrapper<storage_type const>;
+    data_type data;
+
+    template <class T>
+    bool operator ()(T const& value) noexcept {
+      return ::std::less<T> { }(
+        reinterpret_cast<T const&>(this->data.get()),
+        value
+      );
+    }
+  };
+
+  struct type_info final {
+    template <class T>
+    ::std::type_info const* operator ()(T&&) const noexcept {
+      return ::std::addressof(typeid(decay_t<T>));
+    }
+  };
+
+  template <
+    ::std::size_t N,
+    class=enable_if_t<N < sizeof...(Ts)>,
+    class T
+  > explicit variant (index<N>&&, ::std::false_type&&, T&& value) :
+    variant {
+      index<N + 1> { },
+      ::std::is_constructible<type_at_t<N + 1, Ts...>, T> { },
+      ::core::forward<T>(value)
+    }
+  { }
+
+  template <
+    ::std::size_t N,
+    class=enable_if_t<N < sizeof...(Ts)>,
+    class T
+  > explicit variant (index<N>&&, ::std::true_type&&, T&& value) :
+    data { }, tag { N }
+  {
+    new (::std::addressof(this->data)) type_at_t<N, Ts...> (
+      ::core::forward<T>(value)
+    );
+  }
+
+public:
+
+  template <
+    class T,
+    class=enable_if_t<not ::std::is_same<decay_t<T>, variant>::value>
+  > variant (T&& value) :
+    variant {
+      index<0> { },
+      ::std::is_constructible<type_at_t<0, Ts...>, T> { },
+      ::core::forward<T>(value)
+    }
+  { }
+
+  variant (variant const& that) :
+    data { }, tag { that.tag }
+  { that.visit(copier { ::std::ref(this->data) }); }
+
+  variant (variant&& that) noexcept :
+    data { }, tag { that.tag }
+  { that.visit(mover { ::std::ref(this->data) }); }
+
+  template <
+    class=enable_if_t<
+      ::std::is_default_constructible<type_at_t<0, Ts...>>::value
+    >
+  > variant () : variant { type_at_t<0, Ts...> { } } { }
+
+  ~variant () { this->visit(destroyer { }); }
+
+  template <
+    class T,
+    class=enable_if_t<not ::std::is_same<decay_t<T>, variant>::value>
+  > variant& operator = (T&& value) {
+    variant { ::core::forward<T>(value) }.swap(*this);
+    return *this;
+  }
+
+  variant& operator = (variant const& that) {
+    variant { that }.swap(*this);
+    return *this;
+  }
+
+  variant& operator = (variant&& that) noexcept {
+    this->visit(destroyer { });
+    this->tag = that.tag;
+    that.visit(mover { ::std::ref(this->data) });
+    return *this;
+  }
+
+  /* Placing these inside of the variant results in no implicit conversions
+   * occuring
+   */
+  bool operator == (variant const& that) const noexcept {
+    if (this->tag != that.tag) { return false; }
+    return that.visit(equality { ::std::cref(this->data) });
+  }
+
+  bool operator < (variant const& that) const noexcept {
+    if (this->tag != that.tag) { return this->tag < that.tag; }
+    return that.visit(less_than { ::std::cref(this->data) });
+  }
+
+  void swap (variant& that) noexcept(
+    all_traits<is_nothrow_swappable<Ts>...>::value
+  ) {
+    if (this->which() == that.which()) {
+      that.visit(swapper { ::std::ref(this->data) });
+      return;
+    }
+    variant temp { ::core::move(*this) };
+    *this = ::core::move(that);
+    that = ::core::move(temp);
+  }
+
+  template <class Visitor, class... Args>
+  auto visit (Visitor&& visitor, Args&&... args) -> common_type_t<
+    invoke_of_t<Visitor, Ts, Args...>...
+  > {
+    using return_type = common_type_t<invoke_of_t<Visitor, Ts, Args...>...>;
+    using function = return_type(*)(Visitor&&, storage_type&, Args&&...);
+    constexpr ::std::size_t size = ::std::tuple_size<tuple_type>::value;
+
+    static function const callers[size] {
+      impl::visitor_gen<Visitor, Ts, storage_type, function, Args...>()...
+    };
+
+    return callers[this->tag](
+      ::std::forward<Visitor>(visitor),
+      this->data,
+      ::std::forward<Args>(args)...
+    );
+  }
+
+  template <class Visitor, class... Args>
+  auto visit (Visitor&& visitor, Args&&... args) const -> common_type_t<
+    invoke_of_t<Visitor, Ts, Args...>...
+  > {
+    using return_type = common_type_t<invoke_of_t<Visitor, Ts, Args...>...>;
+    using function = return_type(*)(Visitor&&, storage_type const&, Args&&...);
+    constexpr ::std::size_t size = ::std::tuple_size<tuple_type>::value;
+
+    static function const callers[size] = {
+      impl::visitor_gen<
+        Visitor,
+        Ts const,
+        storage_type const,
+        function,
+        Args...
+      >()...
+    };
+
+    return callers[this->tag](
+      ::core::forward<Visitor>(visitor),
+      this->data,
+      ::core::forward<Args>(args)...
+    );
+  }
+
+  template <class... Visitors>
+  auto match (Visitors&&... visitors) -> decltype(
+    this->visit(impl::make_overload(::core::forward<Visitors>(visitors)...))
+  ) {
+    return this->visit(
+      impl::make_overload(::core::forward<Visitors>(visitors)...)
+    );
+  }
+
+  template <class... Visitors>
+  auto match (Visitors&&... visitors) const -> decltype(
+    this->visit(impl::make_overload(::core::forward<Visitors>(visitors)...))
+  ) {
+    return this->visit(
+      impl::make_overload(::core::forward<Visitors>(visitors)...)
+    );
+  }
+
+  template < ::std::size_t N>
+  auto get () const& noexcept(false) -> element<N> const& {
+    if (this->tag != N) { throw bad_variant_get { "incorrect type" }; }
+    return reinterpret_cast<element<N> const&>(this->data);
+  }
+
+  template < ::std::size_t N>
+  auto get () && noexcept(false) -> element<N>&& {
+    if (this->tag != N) { throw bad_variant_get { "incorrect type" }; }
+    return ::std::move(reinterpret_cast<element<N>&>(this->data));
+  }
+
+  template < ::std::size_t N>
+  auto get () & noexcept(false) -> element<N>& {
+    if (this->tag != N) { throw bad_variant_get { "incorrect type" }; }
+    return reinterpret_cast<element<N>&>(this->data);
+  }
+
+  ::std::type_info const& type () const noexcept {
+    return *this->visit(type_info { });
+  }
+
+  ::std::uint32_t which () const noexcept { return this->tag; }
+  bool empty () const noexcept { return false; }
+
+private:
+  storage_type data;
+  ::std::uint8_t tag;
+};
+
+template <class... Ts>
+void swap (variant<Ts...>& lhs, variant<Ts...>& rhs) noexcept(
+  noexcept(lhs.swap(rhs))
+) { lhs.swap(rhs); }
+
+}} /* namespace core::v1 */
+
+namespace std {
+
+template <class... Ts>
+struct hash<core::v1::variant<Ts...>> {
+  using argument_type = core::v1::variant<Ts...>;
+  using result_type = size_t;
+  result_type operator () (argument_type const& value) const {
+    return value.match(hash<Ts> { }...);
+  };
+};
+
+template <size_t I, class... Ts>
+auto get (core::v1::variant<Ts...> const& variant) noexcept(false) -> decltype(
+  variant.template get<I>()
+) { return variant.template get<I>(); }
+
+template <size_t I, class... Ts>
+auto get (core::v1::variant<Ts...>&& variant) noexcept(false) -> decltype(
+  variant.template get<I>()
+) { return variant.template get<I>(); }
+
+template <size_t I, class... Ts>
+auto get (core::v1::variant<Ts...>& variant) noexcept (false) -> decltype(
+  variant.template get<I>()
+) { return variant.template get<I>(); }
+
+} /* namespace std */
+
+#endif /* CORE_VARIANT_HPP */
diff --git a/src/bsoncxx/third_party/core/package/CMakeLists.txt b/src/bsoncxx/third_party/core/package/CMakeLists.txt
new file mode 100644
index 0000000..28f9666
--- /dev/null
+++ b/src/bsoncxx/third_party/core/package/CMakeLists.txt
@@ -0,0 +1,59 @@
+list(APPEND GENERATORS "TGZ" "ZIP")
+
+if (BUILD_PACKAGE_MSI)
+  list(APPEND GENERATORS "WIX")
+endif ()
+
+# disabled until CPack can generate PKGs on modern OS X
+#if (BUILD_PACKAGE_PKG)
+#  list(APPEND GENERATORS "PackageMaker")
+#endif ()
+
+if (BUILD_PACKAGE_RPM)
+  list(APPEND GENERATORS "RPM")
+endif ()
+
+#------------------------------------------------------------------------------
+# Generic Package
+#------------------------------------------------------------------------------
+set(CPACK_OUTPUT_FILE_PREFIX ${PACK_BINARY_DIR})
+
+set(CPACK_GENERATOR ${GENERATORS})
+set(CPACK_PACKAGE_NAME ${PROJECT_NAME})
+set(CPACK_PACKAGE_VENDOR "MNMLSTC")
+set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "C++14 features for C++11")
+set(CPACK_PACKAGE_DESCRIPTION_FILE "${PROJECT_SOURCE_DIR}/Readme.rst")
+set(CPACK_RESOURCE_FILE_LICENSE "${PROJECT_SOURCE_DIR}/License.rst")
+
+set(CPACK_PACKAGE_VERSION_MAJOR ${CORE_VERSION_MAJOR})
+set(CPACK_PACKAGE_VERSION_MINOR ${CORE_VERSION_MINOR})
+set(CPACK_PACKAGE_VERSION_PATCH ${CORE_VERSION_PATCH})
+
+set(CPACK_PACKAGE_FILE_NAME "${CPACK_PACKAGE_NAME}-${CORE_VERSION}")
+
+# Intended for installers such as NSIS or WIX
+set(CPACK_PACKAGE_INSTALL_DIRECTORY "mnmlstc/${PROJECT_NAME}")
+
+#------------------------------------------------------------------------------
+# Wix Configuration
+#------------------------------------------------------------------------------
+set(CPACK_WIX_UPGRADE_GUID "AE6C6986-200F-464C-83EF-C3A94C6C9995")
+set(CPACK_WIX_PRODUCT_GUID "*")
+set(CPACK_WIX_PRODUCT_ICON "${PROJECT_SOURCE_DIR}/package/mnmlstc.ico")
+set(CPACK_WIX_LICENSE_RTF "${PROJECT_SOURCE_DIR}/package/License.rtf")
+set(CPACK_WIX_UI_BANNER "${PROJECT_SOURCE_DIR}/package/banner.bmp")
+set(CPACK_WIX_UI_DIALOG "${PROJECT_SOURCE_DIR}/package/dialog.bmp")
+
+#------------------------------------------------------------------------------
+# RPM Configuration
+#------------------------------------------------------------------------------
+set(CPACK_RPM_PACKAGE_ARCHITECTURE noarch)
+set(CPACK_RPM_PACKAGE_RELEASE 1)
+set(CPACK_RPM_PACKAGE_LICENSE "ASL 2.0")
+set(CPACK_RPM_PACKAGE_GROUP "Development/Libraries")
+
+# Prevents CPack from generating file conflicts
+set(CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION "/usr/share/doc/mnmlstc")
+list(APPEND CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION "/usr/share/cmake")
+
+include(CPack)
diff --git a/src/bsoncxx/third_party/core/package/License.rtf b/src/bsoncxx/third_party/core/package/License.rtf
new file mode 100644
index 0000000..002a964
--- /dev/null
+++ b/src/bsoncxx/third_party/core/package/License.rtf
@@ -0,0 +1,8 @@
+{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Verdana;}}
+{\colortbl ;\red0\green0\blue255;}
+{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sa200\sl276\slmult1\lang9\f0\fs22 Copyright (c) 2013 MNMLSTC\par
+Licensed under the Apache License, Version 2.0 (the "License"); you may not use this software except in compliance with the License. You may obtain a copy of the License at:\par
+{\field{\*\fldinst{HYPERLINK "http://www.apache.org/licenses/LICENSE-2.0"}}{\fldrslt{\ul\cf1 http://www.apache.org/licenses/LICENSE-2.0}}}\f0\fs22\par
+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\par
+}
+ 
\ No newline at end of file
diff --git a/src/bsoncxx/third_party/core/package/banner.bmp b/src/bsoncxx/third_party/core/package/banner.bmp
new file mode 100644
index 0000000..d4121d8
--- /dev/null
+++ b/src/bsoncxx/third_party/core/package/banner.bmp
@@ -0,0 +1,3 @@
+BMt      6  (     :             t  t           ###444GGGWWWiiizzz                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                	           	          	            	              	                	                                                                           	                              	                                                                      	                              
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    	                      	                       	                                  
+                        	                        	                                                                                                                                                                                                                                                                                                                                                                                                                                                
\ No newline at end of file
diff --git a/src/bsoncxx/third_party/core/package/dialog.bmp b/src/bsoncxx/third_party/core/package/dialog.bmp
new file mode 100644
index 0000000..cb580eb
--- /dev/null
+++ b/src/bsoncxx/third_party/core/package/dialog.bmp
@@ -0,0 +1 @@
+BM     6   (     8                                                            GGG                                                               iiiGGG            ###WWW      GGGGGG###         444WWW                           ###         GGG                                                               GGG                                       GGGGGG                                 iii                                       GGG                                                                                                            444      GGG                                                                     ###            GGG                                    iiiGGG         zzz      GGG            ###GGG                                                GGG                                             GGG         GGG                              ###            GGG                           WWWGGG      zzz      GGGiii                                          GGG      GGG                                 GGG      GGG      WWW         WWW   iii                  ###            GGG         WWW   iii                  zzz      GGG      GGG                                                   GGG      GGG                                          iii      GGGiii      444         iii         iii                  ###            GGG         iii         iii                  ###               GGGGGG                                                      GGG      GGG                                          zzzGGG               GGG      GGG###               zzz                              ###            GGG         zzz                              zzz444                           WWW      GGG                     ###iii                           GGG      GGG            ###iii                     zzz                              WWW      GGG                                                ###            GGG                                       WWW                  GGGzzz      GGG###                  WWW                           GGG      GGG            WWW                                    GGGGGG                                             ###            GGG                                       GGG      ###      GGGzzz      444         ###   GGG   ###                        GGG      GGG         ###   GGG   ###                                 GGG                                                ###            GGG                                                      GGG      WWW         ###      ###   ###                        GGG      GGG         ###      ###   ###                              GGG                        iii                        ###            GGG               iii                        iii      iii      GGG###         444                                       iii      GGG      GGG                                          zzzWWW   GGG      GGG         ###444                        iii                                       GGG               iii                                                               GGG                                                                                                                                             GGG      GGG                                    444                                                                                          iii                                 GGG            WWWzzz                                 GGG            WWWzzz                     iii444            444WWW                                                         WWW###         ###WWW444                                    444444                                          444444                                                444444                                                      444444                                                            iiiGGG                                                                  iiiiii                                                                        iiiiii                                                                              iii                                                                                    iii                                                                                          iii                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           444                                                                                                                                 444                                                                                                                                    444                                                                                                                                          WWW                                                                                                                                                iii                                                                                                                                                      iii                                                                                                                                                            iii###                                                                                                                                                                  444                                                                                                                                                                        444                                                                                    iii                                                                                                                                                               444                                                                                    iii                                                                                                                                                               444                                                                                    iii                                                                                                                                                            444                                                                                    iii                                                                        iii                                                                                    iii                                                                                    iii                                                                        iii                                                                                    iii                                                                                    iii                                                                        GGG                                                                                    ###iii                                                                                    444                                                                        444                                                                                    444iii                                                                                    444                                                                        444                                                                                    444iii                                                                                    444                                                                                                                                                            444                                                                                    444                                                                                                                                                            iii                                                                                    444                                                                                                                                                            iii                                                                                    444                                                                                                                                                               iii                                                                                    444                                                                                                                                                                                                                                                444                                                                                                                                                                                                                                          444                                                                        iii                                                                                                                                                            444                                                                        iii                                                                                                                                                      444                                                                        444                                                                                                                                                444                                                                        444                                                                                                                                                                                                                     444                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              zzz                                                                        444                                                                                                                                             444                                                                                                                                                   iii                                                                                                                                                      zzz                                                                                                                                                                                                                                                                                                                              ###                                                                                                                                                                        444                                                                                                                                                                           444                                                                                                                                                                                 iii444                                                                                          iii                                                                                          iiiGGG                                                                                          iii                                                                                          iii                                                                                          iii                                                                                                                                                                                       iii                                                                                                                                                                                       iii                                                                                                                                                                                    iii                                                                                                                                                                                 iii                                                                                       444###                                                                                          iii                                                                                       444444                                                                                          GGG                                                                                       GGGWWW                                                                                          444                                                                                       iiiiii                                                                                          iii444                                                                                       iii                                                                                          iii444                                                                                                                                                                                                                                                                                                                                                                                                      iii444                                                                                                                                                                                                                                                                                                                                                                                                iii444                                                                                                                                                                                                                                                                                                                                                                                          iii444                                                                                                                                                                                                                                                                                                                                                                                    444444                                                                                                                                                                                                                                                                                                                                                                              444444                                                                                                                                                                                                                                                                                                                                                                        444                                                                                                                                                                                                                                                                                                                                                                  444                                                                                                                                                                                                                                                                                                                                                            444                                                                                                                                                                                                                                                                                                                                                      ###                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              zzz                                                                                                                                                                                                                                                                              iii                                                                                                                                                                                                                                                                        iii
\ No newline at end of file
diff --git a/src/bsoncxx/third_party/core/package/mnmlstc.ico b/src/bsoncxx/third_party/core/package/mnmlstc.ico
new file mode 100644
index 0000000..f7f2a93
--- /dev/null
+++ b/src/bsoncxx/third_party/core/package/mnmlstc.ico
@@ -0,0 +1,8 @@
+             v        (   @@     (B   00     %  ES          x      	        h   PNG
+
+   IHDR         \rf   sRGB    gAMA  a   	pHYs  t  tfx  IDATx^m$E` (:<`a5809=YS|t                                          *~<m=r9/8 p9D~zfkc\w=`\o&s~{d?cg.s~,(~Bxst!;XoU(Jrz"ogMq@LE>d:,C8Yb8y"P&~[iq'	~[y">]Ic`tm:M!~z4>l+/1i+\^VO7p})*?0EFkm"(v~tlt-iSe/,
+gqF.wpcV3vrf wpeg*S~w[uZ{oo+=#Cgiow?^dyZVvT NMB~:?#  s	] c:>#  _ g[`No
+@v=+~1k K q}0po
+@J j|<6zgM ' u5 >F/	@f8 L ' u	@nP3H M j& 	@ qP7 $N & 5	@f8 L ' u	@nP3H M j& 	@ qP7 $N & 5	@f8 L ' u	@nP3H M j& 	@ qP7 $N & 5	@f8 L ' u	@nP3H M j& 	@ qP7 $N & 5	@f8 L ' u	@nP3H M j& 	@ qP7 $N & 5	@f8 L ' u	@nP3H M j& 	@ qP7 $N & 5	@f8 L ' u	@nP3H M j& 	@ qP]=k8c{ q W'^G'y`;F@ rt:1(/v" 9Yx^xFkx^Sm#  >J>e|{tx=_@.t{KnO{U"  os6t
+:_?_tHuCIb+;<N ^f}:c:X\/nM3~O )?A"pp%oz #O_Yyw7]-t/sd]#  t@My: %oM(-0O 8'S L dOo.y: |E$#  <373+0 ~F   3#  sv +LqV`3{tF`/
+<g_\y S <Up7U" 9  _Dy2_LV` 8'+   Sy?{3	<)F7	<yy 7= 8<?>L_O 7 ~                                         .?lka    IENDB`(                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  l                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                V                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              S                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   l                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           l                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Z                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       S                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     S                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <                                                            l                                                                                                                                                                              <                                                                                                                                                                                                                       <                                                            l                                                                                                                                                                                      S                                                            l                                                                                                                                                   /                                                            l                                                                                                                                                                                              b                                                            e                                                                                                                                           &                                                            l                                                                                                                                                                                                      s                                                            S                                                                                                                                   &                                                                                                                                                                                                                                                                                                                                      C                                                                                                                                                                                                                                                                                                                                                                                                                                                                         <                                                                                                                                                                                                                                                                                                                                                                                                                                                                        &                                                                                                                                                                                                                                                                                                                                                                                                                                                                        &                                                                                                       {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              !                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *                                                                                                                                                                                                                                                                                                                                                                                                                                                                              <                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Z                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              e                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             S                                                                                                                                                                                                                                                               w                                                                                                                                                                                                                            <                                                                                                                                                                                                                                                       Z                                                                                                                                                                   {                                                               &                                                                                                                                                                                                                                               @                                                                                                                                                                                                                                                                                                                                                                                                                                                                               &                                                                  L                                                                                                                                                                                                                                                                                                                                                                                                                                                                              S                                                                                                                                                                                     	                                                                                                                                                                                                                                                                                         S                                                                                                                                                                                                                                                                                                                                                                                                                                                                              l                                                                                                                                                                                                                                                                                                                                                                                                                                                                                l                                                                                                                                                                                                          w                                                                                                                                                                                                       l                                                               s                                                                                                                                                                                                                  ]                                                                                                                                                                                               S                                                                                                                                                                                                                          &                                                                                                                                                                                                                                                                                                                                                                                                                                           &                                                                                                                                                                                                                                                                                                                                                                                                                                             &                                                                                                                                                                                                                                                                                                                                                                                                                                              &                                                                                                                                                                                                                                                                                                                                                                                                                                                <                                                                                                                                                                                                                                                                                                                                                                                                                                                  <                                                                                                                                                                                                                                                                                                                                                                                                                                                    <                                                                                                                                                                                                                                                                                                                                                                                                                                                      @                                                                                                                                                                                                                                                                                                                                                                                                                                                        S                                                                                                                                                                                                                                                                                                                                                                                                                                                          S                                                                                                                                                                                                                                                                                                                                                                                                                                                            S                                                                                                                                                                                                               &                                                                                                                                                                                                                                               V                                                                                                                                                                                                         &                                                                                                                                                                                                                                                       l                                                                                                                                                                                                   /                                                                                                                                                                                                                                                               l                                                                                                                                                                                             <                                                                                                                                                                                                                                                                       l                                                                                                                                                                                       <                                                                                                                                                                                                                                                                               V                                                                                                                                                                                 D                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ?                      ?                                  ?          ?                                                                                                                                                             ?  ?                                                ?                                                                    ?                                  (   @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \   \   \   \   \   \   \   \                                                                                                                                                                                                                                                                      S                              l                                                                                                                                                                                                                                       S                                                                                                                                                                                                                                       8                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \                                                                                                                                                                                                                                      \                                                                                                                                                                                                                                       \                                                                                                                                                                                                                                       \                                                                                                                                                                                                                                       \                                                                                                                                                                                                                                       \                                                                                                                                                                                                                                       \                                                                                                                                                                                                                                       \                                                                                                                                                                                                                                       \                                                                                                                                                                                                                                       \                                                                                                                                                                                                                                       \                                                                                                                                                                                                                                       \                                                                                                                                                                                                                                       \                                                                                                                                                                                                                                       \                                                                                                                                                                                                                                       \                                                                                                                                                                                                                                       \                                                                                                                                                                                                                                     \                                                                              V                                                                                                                                                              \                                                                                 3                                                                                                                                                         \                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  {                                                                                                         !                                                                                                                                                                                                                       &                                                                                                                                                                                                                        8                                                                                                                                                                                                                          <                                                                                                                                                                                                                            P                                                                                                                                                                                                                              S                                                                                                                                                                                                                                e                                                                                                   &                                                                                                                               l                                                                                             <                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ? ?           ?                     ?          (   0   `           H                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   +                                                                                                                                                                      ?                                                                                                                                                                       1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \   \   \   \   \   \                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              v                                                                                                                                                                                   &                                                                                                                                                           &                                                                                                                                                                                                                                                                                                                                       )                                                                                                                                                                      S                                                                                                                                                                        L                                                                                                                                                                          b                                                                     *                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ?                                  ?                                              (       @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    &                                                                                                              <                                                                                                                S                                                   &                                                               l                                             @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ????<<|>??????????  ?    (      0                                                                                                                                                                                                                                                                                                                                                                                                                                                           \                                                                                           \                                                                                         \                                                                                                            \                                                                                    \                                                                                     \                   2                                                                  \                   2                                                                  \                   2                                                                  \                   2                                                                  \                   2                                                                  \                   8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ?                  ?     (                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      &                                                         S                                                                                                                                                                                                                                                 s  s  s  s  s              
\ No newline at end of file
diff --git a/src/bsoncxx/third_party/core/tests/CMakeLists.txt b/src/bsoncxx/third_party/core/tests/CMakeLists.txt
new file mode 100644
index 0000000..58e4660
--- /dev/null
+++ b/src/bsoncxx/third_party/core/tests/CMakeLists.txt
@@ -0,0 +1,53 @@
+add_custom_target(check COMMAND ${CMAKE_TEST_COMMAND})
+find_package(unittest REQUIRED NO_CMAKE_BUILDS_PATH)
+
+include_directories(${UNITTEST_INCLUDE_DIR})
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g")
+
+#------------------------------------------------------------------------------
+# Executable Section
+#------------------------------------------------------------------------------
+add_executable(test-type-traits "${TEST_SOURCE_DIR}/type-traits.cpp")
+add_executable(test-functional "${TEST_SOURCE_DIR}/functional.cpp")
+add_executable(test-algorithm "${TEST_SOURCE_DIR}/algorithm.cpp")
+add_executable(test-iterator "${TEST_SOURCE_DIR}/iterator.cpp")
+add_executable(test-optional "${TEST_SOURCE_DIR}/optional.cpp")
+add_executable(test-variant "${TEST_SOURCE_DIR}/variant.cpp")
+add_executable(test-utility "${TEST_SOURCE_DIR}/utility.cpp")
+add_executable(test-numeric "${TEST_SOURCE_DIR}/numeric.cpp")
+add_executable(test-string "${TEST_SOURCE_DIR}/string.cpp")
+add_executable(test-memory "${TEST_SOURCE_DIR}/memory.cpp")
+add_executable(test-range "${TEST_SOURCE_DIR}/range.cpp")
+add_executable(test-any "${TEST_SOURCE_DIR}/any.cpp")
+
+#------------------------------------------------------------------------------
+# Test Section
+#------------------------------------------------------------------------------
+add_test(type-traits test-type-traits)
+add_test(functional test-functional)
+add_test(algorithm test-algorithm)
+add_test(iterator test-iterator)
+add_test(optional test-optional)
+add_test(variant test-variant)
+add_test(utility test-utility)
+add_test(numeric test-numeric)
+add_test(string test-string)
+add_test(memory test-memory)
+add_test(range test-range)
+add_test(any test-any)
+
+#------------------------------------------------------------------------------
+# Dependency Section
+#------------------------------------------------------------------------------
+add_dependencies(check test-type-traits)
+add_dependencies(check test-functional)
+add_dependencies(check test-algorithm)
+add_dependencies(check test-iterator)
+add_dependencies(check test-optional)
+add_dependencies(check test-variant)
+add_dependencies(check test-utility)
+add_dependencies(check test-numeric)
+add_dependencies(check test-string)
+add_dependencies(check test-memory)
+add_dependencies(check test-range)
+add_dependencies(check test-any)
diff --git a/src/bsoncxx/third_party/core/tests/algorithm.cpp b/src/bsoncxx/third_party/core/tests/algorithm.cpp
new file mode 100644
index 0000000..8fdc0f3
--- /dev/null
+++ b/src/bsoncxx/third_party/core/tests/algorithm.cpp
@@ -0,0 +1,691 @@
+#include <core/algorithm.hpp>
+#include <initializer_list>
+#include <random>
+#include <vector>
+#include <set>
+
+#include <unittest/unittest.hpp>
+
+int main () {
+  using namespace unittest;
+
+  test("algorithm") = {
+    task("all-of") = [] {
+      std::vector<int> values { 1, 2, 3, 4, 5 };
+      auto result = core::all_of(values, [](int v) { return v > 0; });
+      assert::is_true(result);
+    },
+
+    task("any-of") = [] {
+      std::vector<int> values { 1, 2, 3, 4, 5 };
+      auto result = core::any_of(values, [](int v) { return v % 2 == 0; });
+      assert::is_true(result);
+    },
+
+    task("none-of") = [] {
+      std::vector<int> values { 1, 2, 3, 4, 5 };
+      auto result = core::none_of(values, [](int v) { return v <= 0; });
+      assert::is_true(result);
+    },
+
+    task("for-each") = [] {
+      std::vector<int> values { 1, 2, 3, 4, 5 };
+      core::for_each(values, [](int v) { assert::greater(v, 0); });
+    },
+
+    task("count") = [] {
+      std::vector<int> values { 1, 2, 1, 1 };
+      assert::equal(core::count(values, 1), 3);
+    },
+
+    task("count-if") = [] {
+      std::vector<int> values { 1, 2, 1 };
+      auto result = core::count_if(values, [](int v) { return v % 2; });
+      assert::equal(result, 2);
+    },
+
+    task("mismatch") = [] {
+      auto value = std::string { "abcXYZcba" };
+      auto expected = std::string { "abc" };
+      auto result = core::mismatch(value, value.rbegin());
+      assert::equal(std::string { value.begin(), result.first }, expected);
+    },
+
+    task("equal") = [] {
+      auto value = std::string { "hello" };
+      auto result = core::equal(value, ::std::begin(value));
+      assert::is_true(result);
+    },
+
+    task("find") = [] {
+      auto value = std::string { "find" };
+      auto result = core::find(value, 'n');
+      assert::not_equal(result, ::std::end(value));
+    },
+
+    task("find-if") = [] {
+      auto value = std::string { "find-if" };
+      auto res = core::find_if(value, [](int ch) {
+        return not ::std::isalpha(ch);
+      });
+      assert::not_equal(res, ::std::end(value));
+    },
+
+    task("find-if-not") = [] {
+      auto value = std::string { "find-if-not" };
+      auto res = core::find_if_not(value,
+        [] (int ch) { return ::std::isalpha(ch);
+      });
+      assert::not_equal(res, ::std::end(value));
+    },
+
+    task("find-end") = [] {
+      auto value = std::vector<int> { 1, 2, 3, 4, 6, 7, 9, 8, 1, 2, 3 };
+      auto subset = std::vector<int> { 1, 2, 3 };
+
+      auto result = core::find_end(value, subset);
+      assert::not_equal(result, ::std::end(value));
+      assert::equal(::std::distance(::std::begin(value), result), 8);
+    },
+
+    task("find-first-of") = [] {
+      auto value = std::string { "find-first-of" };
+      auto subset = std::string { "o" };
+      auto result = core::find_first_of(value, subset);
+      assert::not_equal(result, ::std::end(value));
+      assert::equal(::std::distance(::std::begin(value), result), 11);
+    },
+
+    task("adjacent-find") = [] {
+      auto value = std::string { "adjacent-find" };
+      auto result = core::adjacent_find(value);
+      assert::equal(result, ::std::end(value));
+    },
+
+    task("search") = [] {
+      auto value = std::string { "searching with the search function" };
+      auto result = core::search(value, std::string { "the" });
+      assert::not_equal(result, ::std::end(value));
+    },
+
+    task("search-n") = [] {
+      auto value = std::string { "searching for consecutive letters" };
+      auto result = core::search_n(value, 2, 't');
+      assert::not_equal(result, ::std::end(value));
+    },
+
+    task("copy") = [] {
+      std::vector<int> from { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
+      std::vector<int> to { };
+      std::ignore = core::copy(from, std::back_inserter(to));
+
+      assert::equal(to[0], 0);
+      assert::equal(to[1], 1);
+      assert::equal(to[2], 2);
+      assert::equal(to[3], 3);
+      assert::equal(to[4], 4);
+      assert::equal(to[5], 5);
+      assert::equal(to[6], 6);
+      assert::equal(to[7], 7);
+      assert::equal(to[8], 8);
+      assert::equal(to[9], 9);
+    },
+
+    task("copy-if") = [] {
+      auto value = std::string { "copy-if" };
+      std::string output { };
+      std::ignore = core::copy_if(
+        value,
+        ::std::back_inserter(output),
+        [] (char ch) { return ::std::isalpha(ch); }
+      );
+      assert::equal(output, std::string { "copyif" });
+    },
+
+    task("copy-backward") = [] {
+      auto value = std::string { "copy-backward" };
+      std::string output(value.size(), '\0');
+      std::ignore = core::copy_backward(value, ::std::end(output));
+      assert::equal(output, value);
+    },
+
+    task("move") = [] {
+      auto value = std::vector<std::string> { "first", "second", "third" };
+      std::vector<std::string> output { 3 };
+      std::ignore = core::move(value, ::std::begin(output));
+
+      assert::is_true(value[0].empty());
+      assert::is_true(value[1].empty());
+      assert::is_true(value[2].empty());
+
+      assert::equal(output[0], std::string { "first" });
+      assert::equal(output[1], std::string { "second" });
+      assert::equal(output[2], std::string { "third" });
+    },
+
+    task("move-backward") = [] {
+      auto value = std::vector<std::string> { "first", "second", "third" };
+      std::vector<std::string> output { 3 };
+      std::ignore = core::move_backward(value, ::std::end(output));
+
+      assert::is_true(value[0].empty());
+      assert::is_true(value[1].empty());
+      assert::is_true(value[2].empty());
+
+      assert::equal(output[2], std::string { "third" });
+      assert::equal(output[1], std::string { "second" });
+      assert::equal(output[0], std::string { "first" });
+    },
+
+    task("fill") = [] {
+      std::vector<int> value { 1, 2, 3, 4, 5, 6, 7 };
+      auto predicate = [](int v) { return v == -1; };
+      assert::is_true(core::none_of(value, predicate));
+      core::fill(value, -1);
+      assert::is_true(core::all_of(value, predicate));
+    },
+
+    task("transform") = [] {
+      std::vector<int> value { 1, 2, 3 };
+      std::vector<std::string> output { 3 };
+      core::transform(value, ::std::begin(output), [] (int v) -> std::string {
+        return std::to_string(v);
+      });
+      assert::equal(output[0], std::string { "1" });
+      assert::equal(output[1], std::string { "2" });
+      assert::equal(output[2], std::string { "3" });
+    },
+
+    task("transform-if") = [] {
+      std::vector<int> value { 1, 2, 3 };
+      std::vector<std::string> output { };
+      std::vector<std::string> output2 { };
+
+      core::transform_if(
+        value,
+        ::std::back_inserter(output),
+        [] (int v) { return std::to_string(v); },
+        [] (int v) { return v % 2 != 0; }
+      );
+
+      assert::equal(output.size(), 2u);
+      assert::equal(output[0], "1");
+      assert::equal(output[1], "3");
+
+      value = { 2, 3 };
+
+      core::transform_if(
+        value,
+        output,
+        ::std::back_inserter(output2),
+        [] (int v, std::string const& str) { return std::to_string(v) + str; },
+        [] (int v, std::string const&) { return v % 2 != 0 and v > 1; }
+      );
+
+      assert::equal(output2.size(), 1u);
+      assert::equal(output2[0], "33");
+    },
+
+    task("remove") = [] {
+      std::string text { "words words words" };
+      text.erase(core::remove(text, ' '), ::std::end(text));
+      assert::equal(text, std::string { "wordswordswords" });
+    },
+
+    task("remove-if") = [] {
+      std::string text { "remove-if" };
+      text.erase(
+        core::remove_if(text, [](char ch) { return not ::std::isalpha(ch); }),
+        ::std::end(text)
+      );
+      assert::equal(text, std::string { "removeif" });
+    },
+
+    task("remove-copy") = [] {
+      std::string text { "remove-copy" };
+      std::string output { };
+      std::ignore = core::remove_copy(text, ::std::back_inserter(output), '-');
+      assert::equal(output, std::string { "removecopy" });
+    },
+
+    task("remove-copy-if") = [] {
+      std::string text { "remove-copy-if" };
+      std::string output { };
+      std::ignore = core::remove_copy_if(
+        text,
+        ::std::back_inserter(output),
+        [] (char ch) { return ::std::isalpha(ch); }
+      );
+      assert::equal(output, std::string { "--" });
+    },
+
+    task("remove-erase") = [] {
+      std::vector<int> values { 1, 2, 3, 4, 5 };
+      core::remove_erase(values, 3);
+      assert::equal(values.size(), 4u);
+      assert::equal(values[0], 1);
+      assert::equal(values[1], 2);
+      assert::equal(values[2], 4);
+      assert::equal(values[3], 5);
+    },
+
+    task("remove-erase-if") = [] {
+      std::vector<int> values { 1, 2, 3, 4, 5 };
+      core::remove_erase_if(values, [] (int v) { return v % 2; });
+      assert::equal(values.size(), 2u);
+      assert::equal(values[0], 2);
+      assert::equal(values[1], 4);
+    },
+
+    task("replace") = [] {
+      std::string text { "replace" };
+      core::replace(text, 'e', 'f');
+      assert::equal(text, std::string { "rfplacf" });
+    },
+
+    task("replace-if") = [] {
+      std::string text { "replace-if" };
+      core::replace_if(text, [] (char c) { return not std::isalpha(c); }, 'f');
+      assert::equal(text, std::string { "replacefif" });
+    },
+
+    task("replace-copy") = [] {
+      std::string text { "replace-copy" };
+      std::string output { };
+      core::replace_copy(text, ::std::back_inserter(output), '-', 'f');
+      assert::equal(output, std::string { "replacefcopy" });
+    },
+
+    task("replace-copy-if") = [] {
+      std::string text { "replace-copy-if" };
+      std::string output { };
+      core::replace_copy_if(
+        text,
+        ::std::back_inserter(output),
+        [] (char ch) { return not std::isalpha(ch); },
+        'f'
+      );
+      assert::equal(output, std::string { "replacefcopyfif" });
+    },
+
+    task("swap-ranges") = [] {
+      std::string hello { "hello" };
+      std::vector<char> world { 'w', 'o', 'r', 'l', 'd' };
+      core::swap_ranges(hello, ::std::begin(world));
+      assert::equal(hello, std::string { "world" });
+    },
+
+    task("reverse") = [] {
+      std::string text { "reverse" };
+      core::reverse(text);
+      assert::equal(text, std::string { "esrever" });
+    },
+
+    task("reverse-copy") = [] {
+      std::string text { "reverse-copy" };
+      std::string output { };
+      core::reverse_copy(text, ::std::back_inserter(output));
+      assert::equal(output, std::string { "ypoc-esrever" });
+    },
+
+    task("rotate") = [] {
+      std::vector<int> value { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
+      core::rotate(value, ::std::begin(value) + 5);
+      assert::equal(value[0], 6);
+      assert::equal(value[1], 7);
+      assert::equal(value[2], 8);
+      assert::equal(value[3], 9);
+      assert::equal(value[4], 10);
+      assert::equal(value[5], 1);
+      assert::equal(value[6], 2);
+      assert::equal(value[7], 3);
+      assert::equal(value[8], 4);
+      assert::equal(value[9], 5);
+    },
+
+    task("rotate-copy") = [] {
+      std::vector<int> value { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
+      std::vector<int> output { };
+      auto rotator = ::std::begin(value) + 5;
+      core::rotate_copy(value, rotator, ::std::back_inserter(output));
+      assert::equal(output[0], 5);
+      assert::equal(output[1], 6);
+      assert::equal(output[2], 7);
+      assert::equal(output[3], 8);
+      assert::equal(output[4], 9);
+      assert::equal(output[5], 0);
+      assert::equal(output[6], 1);
+      assert::equal(output[7], 2);
+      assert::equal(output[8], 3);
+      assert::equal(output[9], 4);
+    },
+
+    task("shuffle") = [] {
+      std::vector<int> values { 1, 2, 3, 4, 5 };
+      std::random_device rd { };
+      core::shuffle(values, std::mt19937 { rd() });
+    },
+
+    task("unique") = [] {
+      std::vector<int> values { 1, 1, 2, 3, 4, 5 };
+      auto result = core::unique(values);
+      assert::not_equal(result, ::std::end(values));
+    },
+
+    task("unique-copy") = [] {
+      std::vector<int> values { 1, 1, 2, 3, 4, 5 };
+      std::vector<int> output { };
+      std::ignore = core::unique_copy(values, ::std::back_inserter(output));
+      assert::equal(output[0], 1);
+      assert::equal(output[1], 2);
+      assert::equal(output[2], 3);
+      assert::equal(output[3], 4);
+      assert::equal(output[4], 5);
+    },
+
+    task("is-partitioned") = [] {
+      auto is_even = [] (int v) { return v % 2 == 0; };
+      std::vector<int> values { 2, 4, 1, 3, 5 };
+      assert::is_true(core::is_partitioned(values, is_even));
+    },
+
+    task("partition") = [] {
+      auto is_odd = [] (int v) { return v % 2; };
+      std::vector<int> values { 1, 2, 3, 4, 5, 6 };
+      auto second_group = core::partition(values, is_odd);
+      assert::equal(std::distance(second_group, ::std::end(values)), 3);
+    },
+
+    task("partition-copy") = [] {
+      auto is_odd = [] (int v) { return v % 2; };
+      std::vector<int> values { 1, 2, 3, 4, 5, 6 };
+      std::vector<int> even { };
+      std::vector<int> odds { };
+      std::ignore = core::partition_copy(
+        values,
+        ::std::back_inserter(odds),
+        ::std::back_inserter(even),
+        is_odd
+      );
+      assert::is_true(core::none_of(even, is_odd));
+      assert::is_true(core::all_of(odds, is_odd));
+    },
+
+    task("stable-partition") = [] {
+      auto is_odd = [] (int v) { return v % 2; };
+      std::vector<int> values { 1, 2, 3, 4, 5, 6 };
+      std::ignore = core::stable_partition(values, is_odd);
+      assert::equal(values[0], 1);
+      assert::equal(values[1], 3);
+      assert::equal(values[2], 5);
+      assert::equal(values[3], 2);
+      assert::equal(values[4], 4);
+      assert::equal(values[5], 6);
+    },
+
+    task("partition-point") = [] {
+      auto is_odd = [] (int v) { return v % 2; };
+      std::vector<int> values { 1, 2, 3, 4, 5, 6 };
+      auto result = core::stable_partition(values, is_odd);
+      auto point = core::partition_point(values, is_odd);
+      assert::equal(point, result);
+    },
+
+    task("is-sorted") = [] {
+      std::vector<int> values { 1, 2, 3, 4, 5 };
+      assert::is_true(core::is_sorted(values));
+    },
+
+    task("is-sorted-until") = [] {
+      std::vector<int> values { 1, 2, 3, 4, 5, 4, 3 };
+      assert::not_equal(::std::end(values), core::is_sorted_until(values));
+    },
+
+    task("sort") = [] {
+      std::vector<int> values { 5, 4, 3, 2, 1 };
+      core::sort(values);
+      assert::equal(values[0], 1);
+      assert::equal(values[1], 2);
+      assert::equal(values[2], 3);
+      assert::equal(values[3], 4);
+      assert::equal(values[4], 5);
+    },
+
+    task("partial-sort") = [] {
+      std::vector<int> values { 1, 4, 5, 6, 3, 2 };
+      core::partial_sort(values, std::begin(values) + 3);
+      assert::equal(values[0], 1);
+      assert::equal(values[1], 2);
+      assert::equal(values[2], 3);
+    },
+
+    task("partial-sort-copy") = [] {
+      std::vector<int> values { 1, 4, 5, 6, 2, 3 };
+      std::vector<int> output(3);
+      core::partial_sort_copy(values, output);
+      assert::equal(output[0], 1);
+      assert::equal(output[1], 2);
+      assert::equal(output[2], 3);
+    },
+
+    task("stable-sort") = [] {
+      struct employee {
+        bool operator == (employee const& that) const noexcept {
+          return this->age == that.age and this->name == that.name;
+        }
+
+        bool operator < (employee const& that) const noexcept {
+          return this->age < that.age;
+        }
+
+        std::string name;
+        std::int32_t age;
+      };
+
+      std::vector<employee> values = {
+        { "jane smith", 32 },
+        { "joe shmoe", 55 },
+        { "jocoocoo puhwenis", 39 },
+        { "ira glass", 55 },
+        { "bubbles", 43 }
+      };
+      core::stable_sort(values);
+      assert::equal(values.back(), employee { "ira glass", 55 });
+    },
+
+    task("nth-element") = [] {
+      std::vector<int> values { 5, 6, 4, 3, 2, 6, 7, 9, 3 };
+      core::nth_element(values, ::std::begin(values) + values.size() / 2);
+      assert::equal(values[values.size() / 2], 5);
+    },
+
+    task("lower-bound") = [] {
+      std::vector<int> values { 1, 2, 3, 4, 5, 6, 7 };
+      auto result = core::lower_bound(values, 4);
+      assert::not_equal(result, ::std::end(values));
+      assert::equal(*result, 4);
+    },
+
+    task("upper-bound") = [] {
+      std::vector<int> values { 1, 2, 3, 4, 5, 6, 7 };
+      auto result = core::upper_bound(values, 4);
+      assert::not_equal(result, ::std::end(values));
+      assert::equal(*result, 5);
+    },
+
+    task("binary-search") = [] {
+      std::vector<int> values { 1, 2, 3, 4, 5, 6, 7 };
+      assert::is_true(core::binary_search(values, 3));
+    },
+
+    task("equal_range") = [] {
+      std::vector<int> values { 1, 2, 3, 3, 4, 4, 5, 5 };
+      using iterator = std::vector<int>::iterator;
+      core::range<iterator> range { core::equal_range(values, 3) };
+      assert::equal(::std::begin(values) + 2, ::std::begin(range));
+      assert::equal(::std::begin(values) + 4, ::std::end(range));
+    },
+
+    task("merge") = [] {
+      std::vector<int> even { 2, 4, 6, 8, 2, 4 };
+      std::vector<int> odds { 1, 3, 5, 7, 1, 3 };
+      std::set<int> integers { };
+      core::merge(even, odds, ::std::inserter(integers, integers.begin()));
+      assert::equal(integers.size(), 8u);
+    },
+
+    task("inplace-merge") = [] {
+      std::vector<int> values { 1, 2, 3, 4, 5, 6, 7, 8 };
+      core::inplace_merge(values, values.begin() + 4);
+      assert::is_true(core::is_sorted(values));
+    },
+
+    task("includes") = [] {
+      std::vector<int> values { 1, 2, 3, 4, 5, 6, 7 };
+      std::vector<int> subgroup { 4, 5, 6 };
+      assert::is_true(core::includes(values, subgroup));
+    },
+
+    task("set-difference") = [] {
+      std::vector<int> values { 1, 2, 3, 5, 6, 7 };
+      std::vector<int> diff { 1, 2, 3, 4, 5, 6, 7 };
+      std::vector<int> output { };
+      core::set_difference(diff, values, ::std::back_inserter(output));
+      assert::equal(output.size(), 1u);
+      assert::equal(output.front(), 4);
+    },
+
+    task("set-intersection") = [] {
+      std::vector<int> first { 1, 2, 3, 4, 5 };
+      std::vector<int> second { 5, 6, 7, 8, 9 };
+      std::vector<int> output { };
+      core::set_intersection(first, second, ::std::back_inserter(output));
+      assert::equal(output.size(), 1u);
+      assert::equal(output.front(), 5);
+    },
+
+    task("set-symmetric-difference") = [] {
+      std::vector<int> first { 1, 2, 3, 4, 5, 6 };
+      std::vector<int> second { 1, 2, 3, 4, 5 };
+      std::vector<int> output { };
+      auto iter = ::std::back_inserter(output);
+      core::set_symmetric_difference(first, second, iter);
+      assert::equal(output.size(), 1u);
+      assert::equal(output.front(), 6);
+    },
+
+    task("set-union") = [] {
+      std::vector<int> first { 1, 2, 3, 4, 5 };
+      std::vector<int> second { 2, 3, 4, 5, 6 };
+      std::vector<int> output { };
+      auto iter = ::std::back_inserter(output);
+      core::set_union(first, second, iter);
+      assert::equal(output.size(), 6u);
+      assert::equal(output[0], 1);
+      assert::equal(output[1], 2);
+      assert::equal(output[2], 3);
+      assert::equal(output[3], 4);
+      assert::equal(output[4], 5);
+      assert::equal(output[5], 6);
+    },
+
+    task("is-heap") = [] {
+      std::vector<int> values { 9, 5, 4, 1, 1, 3 };
+      assert::is_true(core::is_heap(values));
+    },
+
+    task("is-heap-until") = [] {
+      std::vector<int> values { 9, 5, 4, 1, 1, 3, 2, 6 };
+      auto result = core::is_heap_until(values);
+      assert::not_equal(result, ::std::end(values));
+    },
+
+    task("make-heap") = [] {
+      std::vector<int> values { 3, 1, 4, 1, 5, 9 };
+      core::make_heap(values);
+      assert::is_true(core::is_heap(values));
+    },
+
+    task("push-heap") = [] {
+      std::vector<int> values { 9, 5, 4, 1, 1, 3 };
+      values.push_back(6);
+      core::push_heap(values);
+      assert::equal(values[0], 9);
+      assert::equal(values[1], 5);
+      assert::equal(values[2], 6);
+      assert::equal(values[3], 1);
+      assert::equal(values[4], 1);
+      assert::equal(values[5], 3);
+      assert::equal(values[6], 4);
+    },
+
+    task("pop-heap") = [] {
+      std::vector<int> values { 9, 5, 4, 1, 1, 3 };
+      core::pop_heap(values);
+      values.pop_back();
+      assert::equal(values[0], 5);
+      assert::equal(values[1], 3);
+      assert::equal(values[2], 4);
+      assert::equal(values[3], 1);
+      assert::equal(values[4], 1);
+    },
+
+    task("sort-heap") = [] {
+      std::vector<int> values { 9, 5, 4, 1, 1, 3 };
+      core::sort_heap(values);
+      assert::equal(values[0], 1);
+      assert::equal(values[1], 1);
+      assert::equal(values[2], 3);
+      assert::equal(values[3], 4);
+      assert::equal(values[4], 5);
+      assert::equal(values[5], 9);
+    },
+
+    task("max-element") = [] {
+      std::vector<int> values { 9, 5, 4, 1, 1, 3 };
+      auto result = core::max_element(values);
+      assert::equal(result, ::std::begin(values));
+      assert::equal(*result, 9);
+    },
+
+    task("min-element") = [] {
+      std::vector<int> values { 1, 1, 3, 4, 5, 6 };
+      auto result = core::min_element(values);
+      assert::equal(result, ::std::begin(values));
+      assert::equal(*result, 1);
+    },
+
+    task("minmax-element") = [] {
+      std::vector<int> values { 9, 4, 5, 6, 1 };
+      auto result = core::minmax_element(values);
+      assert::equal(::std::get<0>(result), values.end() - 1);
+      assert::equal(::std::get<1>(result), values.begin());
+      assert::equal(*::std::get<0>(result), 1);
+      assert::equal(*::std::get<1>(result), 9);
+    },
+
+    task("lexicographical-compare") = [] {
+      std::string lhs { "abcd" };
+      std::vector<char> rhs { 'b', 'c', 'd', 'e' };
+      assert::is_true(core::lexicographical_compare(lhs, rhs));
+    },
+
+    task("is-permutation") = [] {
+      std::vector<int> lhs { 1, 2, 3, 4, 5 };
+      std::vector<int> rhs { 5, 4, 3, 2, 1 };
+      assert::is_true(core::is_permutation(lhs, rhs));
+    },
+
+    task("next_permutation") = [] {
+      std::string text { "abc" };
+      assert::is_true(core::next_permutation(text));
+    },
+
+    task("prev-permutation") = [] {
+      std::string text { "cba" };
+      assert::is_true(core::prev_permutation(text));
+    }
+  };
+
+  monitor::run();
+}
diff --git a/src/bsoncxx/third_party/core/tests/any.cpp b/src/bsoncxx/third_party/core/tests/any.cpp
new file mode 100644
index 0000000..8451794
--- /dev/null
+++ b/src/bsoncxx/third_party/core/tests/any.cpp
@@ -0,0 +1,168 @@
+#include <core/any.hpp>
+#include <type_traits>
+#include <string>
+
+#include <cstdint>
+
+#include <unittest/unittest.hpp>
+
+int main () {
+  using namespace unittest;
+
+  test("any") = {
+    task("default-constructor") = [] {
+      core::any value;
+
+      assert::is_true(value.empty());
+      assert::equal(value.type(), typeid(void));
+    },
+    task("value-constructor") = [] {
+      std::string text { "value-constructor" };
+      core::any copy { text };
+
+      assert::is_false(copy.empty());
+      assert::is_false(text.empty());
+      assert::equal(copy.type(), typeid(text));
+
+      core::any move { std::move(text) };
+
+      assert::is_false(move.empty());
+      assert::is_true(text.empty());
+      assert::equal(move.type(), typeid(text));
+    },
+
+    task("copy-constructor") = [] {
+      core::any value { std::string { "copy-constructor" } };
+      core::any ctor { value };
+
+      assert::is_false(value.empty());
+      assert::is_false(ctor.empty());
+      assert::equal(ctor.type(), value.type());
+    },
+
+    task("move-constructor") = [] {
+      core::any value { std::string { "move-constructor" } };
+      core::any ctor { std::move(value) };
+
+      assert::is_false(ctor.empty());
+      assert::is_true(value.empty());
+      assert::equal(ctor.type(), typeid(std::string));
+    },
+
+    task("rvalue-assign") = [] {
+      std::string text { "rvalue-assign works!" };
+      core::any value;
+      value = std::move(text);
+
+      assert::is_false(value.empty());
+      assert::is_true(text.empty());
+      assert::equal(value.type(), typeid(text));
+    },
+
+    task("lvalue-assign") = [] {
+      std::uint64_t integer = 42;
+      core::any value;
+      value = integer;
+      assert::is_false(value.empty());
+      assert::equal(value.type(), typeid(integer));
+    },
+
+    task("copy-assign") = [] {
+      std::uint64_t integer = 42;
+      core::any value { integer };
+      core::any assigned;
+      assigned = value;
+      assert::is_false(value.empty());
+      assert::is_false(assigned.empty());
+      assert::equal(typeid(integer), assigned.type());
+    },
+
+    task("move-assign") = [] {
+      std::uint64_t integer = 42;
+      core::any value { integer };
+      core::any assigned;
+      assigned = std::move(value);
+      assert::is_true(value.empty());
+      assert::is_false(assigned.empty());
+      assert::equal(typeid(integer), assigned.type());
+    },
+
+    task("value-assign") = [] {
+      std::uint64_t integer { 42 };
+      core::any value { };
+      value = integer;
+      assert::is_false(value.empty());
+      assert::equal(typeid(integer), value.type());
+      assert::equal(core::any_cast<std::uint64_t>(value), 42u);
+    },
+
+    task("swap") = [] {
+      using std::swap;
+      std::uint64_t integer = 42;
+      core::any value { integer };
+      core::any to_swap { };
+      swap(value, to_swap);
+      assert::is_true(value.empty());
+      assert::is_false(to_swap.empty());
+    },
+
+    task("clear") = [] {
+      core::any value { std::string { "clear" } };
+      assert::is_false(value.empty());
+      value.clear();
+      assert::is_true(value.empty());
+    },
+
+    task("type") = [] {
+      std::uint64_t integer = 42;
+      core::any value { integer };
+      assert::equal(typeid(integer), value.type());
+    },
+
+    task("cast-const-ref") = [] {
+      std::uint64_t integer = 42;
+      core::any const value { integer };
+      auto integer_value = core::any_cast<std::uint64_t>(value);
+
+      assert::equal(integer_value, integer);
+      assert::throws<core::bad_any_cast>([&value] {
+        core::any_cast<double>(value);
+      });
+    },
+
+    task("cast-const-ptr") = [] {
+      std::uint64_t integer = 42;
+      core::any const value { integer };
+      auto integer_ptr = core::any_cast<std::uint64_t>(std::addressof(value));
+      auto double_ptr = core::any_cast<double>(std::addressof(value));
+
+      assert::is_not_null(integer_ptr);
+      assert::is_null(double_ptr);
+      assert::equal(*integer_ptr, integer);
+      assert::is_true(std::is_pointer<decltype(integer_ptr)>::value);
+    },
+
+    task("cast-ref") = []{
+      std::uint64_t integer = 42;
+      core::any value { integer };
+      auto integer_value = core::any_cast<std::uint64_t>(value);
+
+      assert::equal(integer_value, integer);
+      assert::throws<core::bad_any_cast>([&value]{
+        core::any_cast<double>(value);
+      });
+    },
+
+    task("cast-ptr") = []{
+      std::uint64_t integer = 42;
+      core::any value { integer };
+      auto integer_ptr = core::any_cast<std::uint64_t>(std::addressof(value));
+      auto double_ptr = core::any_cast<double>(std::addressof(value));
+
+      assert::is_not_null(integer_ptr);
+      assert::is_null(double_ptr);
+      assert::equal(*integer_ptr, integer);
+    },
+  };
+  monitor::run();
+}
diff --git a/src/bsoncxx/third_party/core/tests/functional.cpp b/src/bsoncxx/third_party/core/tests/functional.cpp
new file mode 100644
index 0000000..51e53db
--- /dev/null
+++ b/src/bsoncxx/third_party/core/tests/functional.cpp
@@ -0,0 +1,167 @@
+#include <core/functional.hpp>
+
+#include <unordered_map>
+#include <vector>
+#include <string>
+#include <array>
+#include <deque>
+#include <map>
+
+#include <sstream>
+
+#include <unittest/unittest.hpp>
+
+int main () {
+  using namespace unittest;
+
+  test("functional") = {
+    task("invoke-runtime-unpack-unordered-map") = [] {
+      std::unordered_map<int, std::string> values = {
+        { 0, "first" },
+        { 1, "second" },
+        { 2, "third" }
+      };
+
+      auto result = core::invoke(
+        core::runpack,
+        [](std::string& a, std::string& b, std::string& c) -> std::string {
+          return a + b + c;
+        },
+        values
+      );
+
+      assert::equal(result, std::string { "firstsecondthird" });
+    },
+
+    task("invoke-runtime-unpack-basic-string") = [] {
+      std::string string { "hi!" };
+      auto result = core::invoke(
+        core::runpack,
+        [] (char a, char b, char c) -> std::string {
+          std::ostringstream stream;
+          stream << a << b << c;
+          return stream.str();
+        },
+        string
+      );
+
+      assert::equal(string, result);
+      assert::throws<std::out_of_range>([string] {
+        std::ignore = core::invoke(
+          core::runpack,
+          [] (char, char, char, char) -> std::string {
+            return std::string { };
+          },
+          string
+        );
+      });
+
+    },
+
+    task("invoke-runtime-unpack-vector") = [] {
+      std::vector<int> values { 1, 2, 3 };
+      auto result = core::invoke(
+        core::runpack,
+        [](int x, int y, int z) -> int { return x + y + z; },
+        values
+      );
+
+      assert::equal(result, 6);
+    },
+
+    task("invoke-runtime-unpack-deque") = [] {
+      std::deque<int> values { 1, 2, 3 };
+      auto result = core::invoke(
+        core::runpack,
+        [](int x, int y, int z) -> int { return x + y + z; },
+        values
+      );
+
+      assert::equal(result, 6);
+    },
+
+    task("invoke-runtime-unpack-array") = [] {
+      std::array<int, 3> values { { 1, 2, 3 } };
+      auto result = core::invoke(
+        core::runpack,
+        [](int x, int y, int z) -> int { return x + y + z; },
+        values
+      );
+
+      assert::equal(result, 6);
+    },
+
+    task("invoke-runtime-unpack-map") = [] {
+      std::map<int, std::string> values = {
+        { 0, "first" },
+        { 1, "second" },
+        { 2, "third" }
+      };
+
+      auto lambda = [] (std::string x, std::string y) { return x + y; };
+
+      auto result = core::invoke(core::runpack, lambda, values);
+      assert::equal(result, std::string { "firstsecond" });
+    },
+
+    task("invoke-unpack-tuple") = [] {
+      auto result = core::invoke(
+        core::unpack,
+        [](int x, std::string y) { return std::to_string(x) + y; },
+        std::forward_as_tuple(4, "unpack")
+      );
+
+      assert::equal(result, std::string { "4unpack" });
+    },
+
+    task("invoke-unpack-array") = [] {
+      std::array<int, 3> values = {{ 1, 2, 3 }};
+      auto result = core::invoke(
+        core::unpack,
+        [](int x, int y, int z) { return x + y + z; },
+        values
+      );
+
+      assert::equal(result, 6);
+    },
+
+    task("invoke-unpack-pair") = [] {
+      auto result = core::invoke(
+        core::unpack,
+        [](int x, std::string y) { return std::to_string(x) + y; },
+        std::make_pair(7, "unpack")
+      );
+
+      assert::equal(result, std::string { "7unpack" });
+
+      struct type {
+        constexpr type () noexcept { }
+        constexpr int operator ()() const noexcept { return 5; }
+        constexpr int operator ()(int value) const noexcept { return value + 5; }
+      };
+      constexpr type value { };
+      static_assert(core::invoke(value) == 5, "");
+      static_assert(core::invoke(value, 6) == 11, "");
+    },
+
+    task("function-traits") = [] {
+      auto empty_lambda = []{};
+      auto empty_arity = core::function_traits<decltype(empty_lambda)>::arity;
+      auto mem_fn_arity = core::function_traits<
+        decltype(&std::string::size)
+      >::arity;
+
+      static_assert(
+        std::is_same<
+          std::string const&,
+          core::function_traits<decltype(&std::string::size)>::argument<0>
+        >::value,
+        "function-traits-arity incorrect size"
+      );
+      assert::equal(mem_fn_arity, 1u);
+      assert::equal(empty_arity, 0u);
+    },
+  };
+
+  monitor::run();
+}
diff --git a/src/bsoncxx/third_party/core/tests/iterator.cpp b/src/bsoncxx/third_party/core/tests/iterator.cpp
new file mode 100644
index 0000000..2238c58
--- /dev/null
+++ b/src/bsoncxx/third_party/core/tests/iterator.cpp
@@ -0,0 +1,70 @@
+#include <core/iterator.hpp>
+#include <algorithm>
+#include <ostream>
+#include <sstream>
+#include <vector>
+
+#include <cstdint>
+
+#include <unittest/unittest.hpp>
+
+template <class T>
+std::ostream& operator << (std::ostream& os, std::vector<T> const& vec) {
+  os << "[";
+  std::copy(
+    core::cbegin(vec),
+    core::cend(vec),
+    core::infix_ostream_iterator<T> { os, "," }
+  );
+  return os << "]";
+}
+
+int main () {
+  using namespace unittest;
+  std::vector<std::uint64_t> value = { 1, 2, 3, 4, 5 };
+
+  test("iterator") = {
+    task("size") = [value] {
+      int array[5];
+      assert::equal(core::size(value), value.size());
+      static_assert(core::size(array) == 5, "core::size");
+    },
+
+    task("empty") = [value] {
+      int array[5];
+      assert::is_false(core::empty(value));
+      static_assert(not core::empty(array), "core::empty");
+    },
+
+    task("front") = [value] {
+      constexpr int array[5] { 0, 1, 2, 3, 4 };
+      assert::equal(core::front(value), value.front());
+      static_assert(core::front(array) == 0, "core::front");
+    },
+
+    task("back") = [value] {
+      constexpr int array[5] { 0, 1, 2, 3, 4 };
+      assert::equal(core::back(value), value.back());
+      static_assert(core::back(array) == 4, "core::back");
+    },
+
+    task("data") = [value] {
+      int array[5] { 1, 2, 3, 4, 5 };
+      assert::equal(core::data(value), value.data());
+      assert::equal(core::data(array), std::addressof(array[0]));
+    },
+
+    task("cbegin") = [value] {
+      assert::equal(core::cbegin(value), value.begin());
+    },
+    task("cend") = [value] { assert::equal(core::cend(value), value.end()); },
+
+    task("infix-ostream-iterator") = [value] {
+      std::ostringstream stream;
+      stream << value;
+      assert::equal(stream.str(), std::string { "[1,2,3,4,5]" });
+    }
+  };
+
+  monitor::run();
+}
diff --git a/src/bsoncxx/third_party/core/tests/memory.cpp b/src/bsoncxx/third_party/core/tests/memory.cpp
new file mode 100644
index 0000000..e608667
--- /dev/null
+++ b/src/bsoncxx/third_party/core/tests/memory.cpp
@@ -0,0 +1,641 @@
+#include <core/memory.hpp>
+
+#include <unittest/unittest.hpp>
+
+namespace poly {
+
+struct base {
+  base (base const&) = default;
+  base (base&&) = default;
+  base () = default;
+  virtual ~base () { }
+
+  virtual int get () const noexcept { return 0; }
+};
+
+struct derived : base {
+  int value = 42;
+
+  explicit derived (int value) : value { value } { }
+
+  derived (derived const&) = default;
+  derived (derived&&) = default;
+  derived () = default;
+
+  virtual int get () const noexcept override { return this->value; }
+};
+
+} /* namespace poly */
+
+int main () {
+  using namespace unittest;
+
+  test("poly-ptr") = {
+    task("default-constructor") = []{
+      core::poly_ptr<poly::base> value;
+      assert::is_true(not value);
+    },
+
+    task("value-constructor") = [] {
+      core::poly_ptr<poly::base> value { new poly::derived { } };
+      assert::is_false(not value);
+      assert::equal(typeid(poly::derived), typeid(*value));
+    },
+
+    task("copy-constructor") = [] {
+      core::poly_ptr<poly::base> value { new poly::derived { } };
+      core::poly_ptr<poly::base> copy { value };
+
+      assert::is_false(not value);
+      assert::is_false(not copy);
+
+      assert::equal(typeid(poly::derived), typeid(*value));
+      assert::equal(typeid(poly::derived), typeid(*copy));
+
+      assert::equal(dynamic_cast<poly::derived&>(*copy).value, 42);
+      assert::equal(
+        dynamic_cast<poly::derived&>(*copy).value,
+        dynamic_cast<poly::derived&>(*value).value
+      );
+    },
+
+    task("move-constructor") = []{
+      core::poly_ptr<poly::base> value { new poly::derived { } };
+      core::poly_ptr<poly::base> move { std::move(value) };
+
+      assert::is_true(not value);
+      assert::is_true(bool(move));
+
+      assert::equal(dynamic_cast<poly::derived&>(*move).value, 42);
+    },
+
+    task("unique-ptr-assignment") = []{
+      core::poly_ptr<poly::base> poly { };
+      std::unique_ptr<poly::derived> ptr { new poly::derived { 56 } };
+      poly = std::move(ptr);
+
+      assert::is_true(bool(poly));
+      assert::is_true(not ptr);
+      assert::equal(typeid(poly::derived), typeid(*poly));
+      assert::equal(poly->get(), 56);
+    },
+
+    task("raw-ptr-assignment") = []{
+      core::poly_ptr<poly::base> poly { };
+      poly = new poly::derived { };
+
+      assert::is_true(bool(poly));
+      assert::equal(typeid(poly::derived), typeid(*poly));
+      assert::equal(poly->get(), 42);
+    },
+
+    task("copy-assignment") = []{
+      core::poly_ptr<poly::base> value { new poly::derived { } };
+      core::poly_ptr<poly::base> copy { };
+      copy = value;
+
+      assert::is_true(bool(value));
+      assert::is_true(bool(copy));
+
+      assert::equal(typeid(poly::derived), typeid(*value));
+      assert::equal(typeid(poly::derived), typeid(*copy));
+
+      assert::equal(dynamic_cast<poly::derived&>(*copy).value, 42);
+      assert::equal(
+        dynamic_cast<poly::derived&>(*copy).value,
+        dynamic_cast<poly::derived&>(*value).value
+      );
+    },
+
+    task("move-assignment") = []{
+      core::poly_ptr<poly::base> value { new poly::derived { } };
+      core::poly_ptr<poly::base> move { };
+      move = std::move(value);
+
+      assert::is_true(not value);
+      assert::is_true(bool(move));
+
+      assert::equal(dynamic_cast<poly::derived&>(*move).value, 42);
+    },
+
+    task("operator-bool") = [] {
+      core::poly_ptr<poly::base> value;
+      assert::is_true(not value);
+      value = new poly::derived { };
+      assert::is_true(bool(value));
+    },
+
+    task("dereference-operator") = [] {
+      core::poly_ptr<poly::base> poly { new poly::derived { } };
+      poly::base& parent = *poly;
+      assert::equal(typeid(parent), typeid(poly::derived));
+    },
+
+    task("arrow-operator") = [] {
+      core::poly_ptr<poly::base> poly { new poly::derived { } };
+      assert::equal(poly->get(), 42);
+    },
+
+    task("release") = [] {
+      core::poly_ptr<poly::base> poly { new poly::derived { } };
+      assert::is_true(bool(poly));
+      poly.release();
+      assert::is_true(not poly);
+    },
+
+    task("reset") = [] {
+      struct second_derived : poly::base { };
+      core::poly_ptr<poly::base> poly { new poly::derived { } };
+      auto improper = new second_derived { };
+      auto proper = new poly::derived { };
+
+      assert::is_true(bool(poly));
+      poly.reset(proper);
+      assert::is_true(bool(poly));
+      assert::throws<core::bad_polymorphic_reset>([poly, improper] () mutable {
+        poly.reset(improper);
+      });
+      poly.reset();
+      assert::is_true(not poly);
+    },
+
+    task("swap") = [] {
+      using std::swap;
+      core::poly_ptr<poly::base> lhs { new poly::derived { } };
+      core::poly_ptr<poly::base> rhs { };
+
+      assert::is_true(bool(lhs));
+      assert::is_true(not rhs);
+
+      swap(lhs, rhs);
+
+      assert::is_true(not lhs);
+      assert::is_true(bool(rhs));
+    },
+
+    task("get") = [] {
+      core::poly_ptr<poly::base> const poly { new poly::derived { } };
+      poly::derived* ptr = dynamic_cast<poly::derived*>(poly.get());
+      assert::is_not_null(ptr);
+    },
+
+    task("get-copier") = [] {
+      core::poly_ptr<poly::base> value { new poly::derived { } };
+      auto poly_copy = core::default_poly_copy<
+        poly::base,
+        std::default_delete<poly::base>,
+        poly::derived
+      >;
+
+      assert::equal(value.get_copier(), poly_copy);
+    },
+
+    task("operator-equal") = [] {
+      core::poly_ptr<poly::base> lhs { };
+      core::poly_ptr<poly::base> rhs { };
+      assert::equal(lhs, rhs);
+      assert::equal(lhs, nullptr);
+      assert::equal(nullptr, lhs);
+    },
+
+    task("operator-not-equal") = [] {
+      core::poly_ptr<poly::base> lhs { new poly::derived { } };
+      core::poly_ptr<poly::base> rhs { };
+      assert::not_equal(lhs, rhs);
+      assert::not_equal(lhs, nullptr);
+      assert::not_equal(nullptr, lhs);
+    },
+
+    task("operator-greater-than-or-equal") = [] {
+      core::poly_ptr<poly::base> lhs { new poly::derived { } };
+      core::poly_ptr<poly::base> rhs { };
+
+      assert::greater_equal(lhs, rhs);
+      assert::greater_equal(lhs, nullptr);
+      assert::greater_equal(nullptr, rhs);
+    },
+
+    task("operator-less-than-or-equal") = [] {
+      core::poly_ptr<poly::base> lhs { };
+      core::poly_ptr<poly::base> rhs { new poly::derived { } };
+
+      assert::less_equal(lhs, rhs);
+      assert::less_equal(lhs, nullptr);
+      assert::less_equal(nullptr, lhs);
+      assert::less_equal(nullptr, rhs);
+    },
+
+    task("operator-greater-than") = [] {
+      core::poly_ptr<poly::base> lhs { new poly::derived { } };
+      core::poly_ptr<poly::base> rhs { };
+
+      assert::greater(lhs, rhs);
+      assert::greater(lhs, nullptr);
+    },
+
+    task("operator-less-than") = [] {
+      core::poly_ptr<poly::base> lhs { };
+      core::poly_ptr<poly::base> rhs { new poly::derived { } };
+
+      assert::less(lhs, rhs);
+      assert::less(nullptr, rhs);
+    },
+
+    task("make-poly") = [] {
+      poly::derived derived { };
+      auto poly = core::make_poly<poly::base>(std::move(derived));
+      assert::is_true(bool(poly));
+      assert::equal(typeid(derived), typeid(*poly));
+      assert::equal(poly->get(), 42);
+    }
+  };
+
+  test("deep-ptr") = {
+    task("default-constructor") = [] {
+      core::deep_ptr<poly::derived> value { };
+      assert::is_true(not value);
+    },
+
+    task("value-constructor") = [] {
+      core::deep_ptr<poly::derived> value { new poly::derived { } };
+
+      assert::is_true(bool(value));
+      assert::equal((*value).value, 42);
+    },
+
+    task("move-constructor") = [] {
+      core::deep_ptr<poly::derived> value { new poly::derived { } };
+      core::deep_ptr<poly::derived> move { std::move(value) };
+
+      assert::is_true(not value);
+      assert::is_true(bool(move));
+      assert::equal((*move).value, 42);
+    },
+
+    task("copy-constructor") = [] {
+      core::deep_ptr<poly::derived> value { new poly::derived { } };
+      core::deep_ptr<poly::derived> copy { value };
+
+      assert::is_true(bool(value));
+      assert::is_true(bool(copy));
+
+      assert::equal(value->get(), copy->get());
+      assert::equal(value->get(), 42);
+      assert::equal(copy->get(), 42);
+    },
+
+    task("unique-ptr-assign-operator") = [] {
+      core::deep_ptr<poly::derived> value { };
+      std::unique_ptr<poly::derived> unique { new poly::derived { } };
+
+      value = std::move(unique);
+
+      assert::is_true(not unique);
+      assert::is_true(bool(value));
+      assert::equal(value->get(), 42);
+    },
+
+    task("copy-assignment") = []{
+      core::deep_ptr<poly::derived> value { new poly::derived { } };
+      core::deep_ptr<poly::derived> copy { };
+
+      assert::is_true(bool(value));
+      assert::is_true(not copy);
+
+      copy = value;
+
+      assert::is_true(bool(value));
+      assert::is_true(bool(copy));
+      assert::equal(value->get(), copy->get());
+      assert::equal(copy->get(), 42);
+    },
+
+    task("move-assignment") = []{
+      core::deep_ptr<poly::derived> value { new poly::derived { } };
+      core::deep_ptr<poly::derived> move { };
+
+      assert::is_true(bool(value));
+      assert::is_true(not move);
+
+      move = std::move(value);
+
+      assert::is_true(not value);
+      assert::is_true(bool(move));
+      assert::equal(move->get(), 42);
+    },
+
+    task("operator-bool") = []{
+      core::deep_ptr<poly::derived> true_value { new poly::derived { } };
+      core::deep_ptr<poly::derived> false_value { };
+
+      assert::is_true(bool(true_value));
+      assert::is_true(not false_value);
+    },
+
+    task("dereference-operator") = [] {
+      core::deep_ptr<poly::derived> value { new poly::derived { } };
+      assert::is_true(bool(value));
+      assert::equal((*value).value, 42);
+    },
+
+    task("arrow-operator") = [] {
+      core::deep_ptr<poly::derived> value { new poly::derived { } };
+      assert::is_true(bool(value));
+      assert::equal(value->get(), 42);
+    },
+
+    task("release") = []{
+      core::deep_ptr<poly::derived> value { new poly::derived { } };
+
+      assert::is_true(bool(value));
+
+      auto ptr = value.release();
+
+      assert::is_null(value.get());
+      assert::is_true(not value);
+      assert::is_not_null(ptr);
+      assert::equal(ptr->get(), 42);
+      delete ptr;
+    },
+
+    task("reset") = [] {
+      core::deep_ptr<poly::derived> value { new poly::derived { } };
+      assert::is_true(bool(value));
+      value.reset();
+      assert::is_true(not value);
+    },
+
+    task("get") = [] {
+      core::deep_ptr<poly::derived> value { };
+      assert::is_null(value.get());
+    },
+
+    task("get-copier") = [] {
+      core::deep_ptr<poly::derived> value { new poly::derived { } };
+      auto ptr = value.get_copier()(value.get());
+      assert::is_not_null(ptr);
+      delete ptr;
+    },
+
+    task("operator-equal") = [] {
+      core::deep_ptr<poly::derived> lhs { };
+      core::deep_ptr<poly::derived> rhs { };
+      assert::equal(lhs, rhs);
+      assert::equal(lhs, nullptr);
+      assert::equal(nullptr, rhs);
+    },
+
+    task("operator-not-equal") = [] {
+      core::deep_ptr<poly::derived> lhs { new poly::derived { } };
+      core::deep_ptr<poly::derived> rhs { };
+      assert::not_equal(lhs, rhs);
+      assert::not_equal(lhs, nullptr);
+      assert::not_equal(nullptr, lhs);
+    },
+
+    task("operator-greater-than-or-equal") = [] {
+      core::deep_ptr<poly::derived> lhs { new poly::derived { } };
+      core::deep_ptr<poly::derived> rhs { };
+
+      assert::greater_equal(lhs, rhs);
+      assert::greater_equal(lhs, nullptr);
+      assert::greater_equal(nullptr, rhs);
+
+    },
+
+    task("operator-less-than-or-equal") = [] {
+      core::deep_ptr<poly::derived> lhs { };
+      core::deep_ptr<poly::derived> rhs { new poly::derived { } };
+
+      assert::less_equal(lhs, rhs);
+      assert::less_equal(lhs, nullptr);
+      assert::less_equal(nullptr, lhs);
+      assert::less_equal(nullptr, rhs);
+    },
+
+    task("operator-greater-than") = [] {
+      core::poly_ptr<poly::derived> lhs { new poly::derived { } };
+      core::poly_ptr<poly::derived> rhs { };
+
+      assert::greater(lhs, rhs);
+      assert::greater(lhs, nullptr);
+    },
+
+    task("operator-less-than") = [] {
+      core::deep_ptr<poly::derived> lhs { };
+      core::deep_ptr<poly::derived> rhs { new poly::derived { } };
+
+      assert::less(lhs, rhs);
+      assert::less(nullptr, rhs);
+    },
+
+    task("make-deep") = [] {
+      auto deep = core::make_deep<std::tuple<std::string, std::string>>(
+        "hello",
+        "world!"
+      );
+      assert::is_true(bool(deep));
+    }
+  };
+
+  test("observer-ptr") = {
+    task("default-constructor") = [] {
+      core::observer_ptr<int> value { };
+      assert::is_true(not value);
+    },
+
+    task("value-constructor") = [] {
+      int value { 42 };
+      core::observer_ptr<int> observer { std::addressof(value) };
+      assert::equal(std::addressof(value), observer.get());
+    },
+
+    task("copy-constructor") = [] {
+      int value { 42 };
+      core::observer_ptr<int> observer { std::addressof(value) };
+      core::observer_ptr<int> copy { observer };
+      assert::equal(copy.get(), std::addressof(value));
+      assert::equal(copy.get(), observer.get());
+    },
+
+    task("copy-assign") = [] {
+      int value { 42 };
+      core::observer_ptr<int> observer { std::addressof(value) };
+      core::observer_ptr<int> copy { };
+
+      assert::is_null(copy.get());
+      copy = observer;
+      assert::equal(observer.get(), copy.get());
+    },
+
+    task("null-assign") = [] {
+      int value { 42 };
+      core::observer_ptr<int> observer { std::addressof(value) };
+      assert::is_not_null(observer.get());
+      observer = nullptr;
+      assert::is_null(observer.get());
+    },
+
+    task("swap") = [] {
+      using std::swap;
+      int value_one { 42 };
+      int value_two { 43 };
+
+      core::observer_ptr<int> lhs { std::addressof(value_one) };
+      core::observer_ptr<int> rhs { std::addressof(value_two) };
+
+      assert::equal(std::addressof(value_one), lhs.get());
+      assert::equal(std::addressof(value_two), rhs.get());
+
+      swap(lhs, rhs);
+
+      assert::equal(std::addressof(value_one), rhs.get());
+      assert::equal(std::addressof(value_two), lhs.get());
+    },
+
+    task("const-pointer-conversion") = [] {
+      int value { 42 };
+      core::observer_ptr<int> observer { std::addressof(value) };
+      auto const ptr = static_cast<int const*>(observer);
+      assert::equal(observer.get(), ptr);
+    },
+
+    task("pointer-conversion") = [] {
+      int value { 42 };
+      core::observer_ptr<int> observer { std::addressof(value) };
+      auto ptr = static_cast<int*>(observer);
+      assert::equal(observer.get(), ptr);
+    },
+
+    task("deref-operator") = [] {
+      int value { 42 };
+      core::observer_ptr<int> observer { std::addressof(value) };
+      assert::equal(42, *observer);
+    },
+
+    task("arrow-operator") = [] {
+      std::string value { "arrow" };
+      core::observer_ptr<std::string const> observer { std::addressof(value) };
+      assert::equal(observer->size(), 5);
+    },
+
+    task("release") = [] {
+      int value { 42 };
+      core::observer_ptr<int> observer { std::addressof(value) };
+
+      assert::is_not_null(observer.get());
+
+      auto ptr = observer.release();
+
+      assert::is_null(observer.get());
+      assert::equal(ptr, std::addressof(value));
+    },
+
+    task("reset") = [] {
+      int value { 42 };
+      int reset { 47 };
+      core::observer_ptr<int> observer { std::addressof(value) };
+      assert::is_not_null(observer.get());
+      assert::equal(std::addressof(value), observer.get());
+
+      observer.reset(std::addressof(reset));
+      assert::is_not_null(observer.get());
+      assert::equal(std::addressof(reset), observer.get());
+
+      observer.reset();
+      assert::is_null(observer.get());
+    },
+
+    task("operator-equal") = [] {
+      int value { 42 };
+      core::observer_ptr<int> lhs { std::addressof(value) };
+      core::observer_ptr<int> rhs { std::addressof(value) };
+      assert::equal(core::observer_ptr<int> { }, nullptr);
+      assert::equal(nullptr, core::observer_ptr<int> { });
+      assert::equal(lhs, rhs);
+    },
+
+    task("operator-not-equal") = [] {
+      int value { 42 };
+      int other { };
+      core::observer_ptr<int> lhs { std::addressof(value) };
+      core::observer_ptr<int> rhs { std::addressof(other) };
+      assert::not_equal(lhs, nullptr);
+      assert::not_equal(nullptr, rhs);
+      assert::not_equal(lhs, rhs);
+    },
+
+    task("operator-greater-equal") = [] {
+      int value { };
+      core::observer_ptr<int> lhs { std::addressof(value) };
+      core::observer_ptr<int> rhs1 { lhs };
+      core::observer_ptr<int> rhs2 { };
+      assert::greater_equal(lhs, rhs1);
+      assert::greater_equal(lhs, rhs2);
+    },
+
+    task("operator-less-equal") = [] {
+      int value { };
+      core::observer_ptr<int> lhs { };
+      core::observer_ptr<int> rhs1 { };
+      core::observer_ptr<int> rhs2 { std::addressof(value) };
+      assert::less_equal(lhs, rhs1);
+      assert::less_equal(lhs, rhs2);
+    },
+
+    task("operator-greater") = [] {
+      int value { };
+      core::observer_ptr<int> lhs { std::addressof(value) };
+      core::observer_ptr<int> rhs { };
+      assert::greater(lhs, rhs);
+    },
+
+    task("operator-less") = [] {
+      int value { };
+      core::observer_ptr<int> lhs { };
+      core::observer_ptr<int> rhs { std::addressof(value) };
+      assert::less(lhs, rhs);
+    },
+
+    task("make-observer") = [] {
+      std::unique_ptr<int> unique { new int { } };
+      std::shared_ptr<int> shared { new int { } };
+      core::deep_ptr<int> deep { new int { } };
+      std::weak_ptr<int> weak { shared };
+      int value { };
+
+      auto unique_observer = core::make_observer(unique);
+      auto shared_observer = core::make_observer(shared);
+      auto deep_observer = core::make_observer(deep);
+      auto weak_observer = core::make_observer(weak);
+      auto ptr_observer = core::make_observer(std::addressof(value));
+
+      assert::equal(unique_observer.get(), unique.get());
+      assert::equal(shared_observer.get(), shared.get());
+      assert::equal(deep_observer.get(), deep.get());
+      assert::equal(weak_observer.get(), shared.get());
+      assert::equal(ptr_observer.get(), std::addressof(value));
+    }
+  };
+
+  test("make-unique") = {
+    task("make-unique-single") = []{
+      auto unique = core::make_unique<std::vector<int>>(
+        std::vector<int> { 1, 2, 3, 4, 5}
+      );
+      assert::is_not_null(unique.get());
+      assert::equal((*unique)[0], 1);
+      assert::equal((*unique)[1], 2);
+      assert::equal((*unique)[2], 3);
+      assert::equal((*unique)[3], 4);
+      assert::equal((*unique)[4], 5);
+    },
+
+    task("make-unique-array") = []{
+      auto unique = core::make_unique<int[]>(7);
+      assert::is_not_null(unique.get());
+    }
+  };
+
+  monitor::run();
+}
diff --git a/src/bsoncxx/third_party/core/tests/numeric.cpp b/src/bsoncxx/third_party/core/tests/numeric.cpp
new file mode 100644
index 0000000..509853f
--- /dev/null
+++ b/src/bsoncxx/third_party/core/tests/numeric.cpp
@@ -0,0 +1,95 @@
+#include <core/numeric.hpp>
+
+#include <functional>
+#include <vector>
+
+#include <unittest/unittest.hpp>
+
+int main () {
+  using namespace unittest;
+  test("numeric") = {
+    task("iota") = [] {
+      std::vector<int> values = { 0, 0, 0, 0, 0 };
+      core::iota(values, 0);
+      assert::equal(values[0], 0);
+      assert::equal(values[1], 1);
+      assert::equal(values[2], 2);
+      assert::equal(values[3], 3);
+      assert::equal(values[4], 4);
+    },
+
+    task("accumulate") = [] {
+      std::vector<int> values = { 1, 2, 3, 4 };
+      auto result = core::accumulate(values, 0);
+      assert::equal(result, 10);
+      result = core::accumulate(values, 1, std::multiplies<int> { });
+      assert::equal(result, 24);
+    },
+
+    task("inner-product") = [] {
+      std::vector<int> value_one { 0, 1, 2, 3, 4 };
+      std::vector<int> value_two { 5, 4, 3, 2, 1 };
+      auto result = core::inner_product(value_one, ::std::begin(value_two), 0);
+      assert::equal(result, 20);
+      result = core::inner_product(
+        value_one,
+        std::begin(value_two),
+        1,
+        std::multiplies<int> { },
+        std::plus<int> { }
+      );
+      assert::equal(result, 3125);
+    },
+
+    task("adjacent-difference") = [] {
+      std::vector<int> values { 2, 4, 6, 8, 10 };
+      auto result = std::vector<int>(values.size());
+      core::adjacent_difference(values, std::begin(result));
+      assert::equal(result[0], 2);
+      assert::equal(result[1], 2);
+      assert::equal(result[2], 2);
+      assert::equal(result[3], 2);
+      assert::equal(result[4], 2);
+
+      core::adjacent_difference(values, std::begin(result), std::plus<int> { });
+      assert::equal(result[0], 2);
+      assert::equal(result[1], 6);
+      assert::equal(result[2], 10);
+      assert::equal(result[3], 14);
+      assert::equal(result[4], 18);
+    },
+
+    task("partial-sum") = [] {
+      std::vector<int> values { 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 };
+      auto result = std::vector<int>(values.size());
+
+      core::partial_sum(values, std::begin(result));
+      assert::equal(result[0], 2);
+      assert::equal(result[1], 4);
+      assert::equal(result[2], 6);
+      assert::equal(result[3], 8);
+      assert::equal(result[4], 10);
+      assert::equal(result[5], 12);
+      assert::equal(result[6], 14);
+      assert::equal(result[7], 16);
+      assert::equal(result[8], 18);
+      assert::equal(result[9], 20);
+
+      core::partial_sum(values, std::begin(result), std::multiplies<int> { });
+      assert::equal(result[0], 2);
+      assert::equal(result[1], 4);
+      assert::equal(result[2], 8);
+      assert::equal(result[3], 16);
+      assert::equal(result[4], 32);
+      assert::equal(result[5], 64);
+      assert::equal(result[6], 128);
+      assert::equal(result[7], 256);
+      assert::equal(result[8], 512);
+      assert::equal(result[9], 1024);
+
+
+    }
+  };
+
+  monitor::run();
+}
diff --git a/src/bsoncxx/third_party/core/tests/optional.cpp b/src/bsoncxx/third_party/core/tests/optional.cpp
new file mode 100644
index 0000000..33c0475
--- /dev/null
+++ b/src/bsoncxx/third_party/core/tests/optional.cpp
@@ -0,0 +1,1175 @@
+#include <core/optional.hpp>
+
+#include <unordered_map>
+#include <utility>
+#include <string>
+#include <array>
+
+#include <cstdint>
+
+#include <unittest/unittest.hpp>
+
+struct variadic {
+  template <class... Args> constexpr variadic (Args&&...) { }
+  template <class T, class... Args>
+  constexpr variadic (std::initializer_list<T>, Args&&...) { }
+};
+
+std::ostream& operator << (
+  std::ostream& os,
+  ::core::v1::expected<void> const&
+) { return os << "core::expected<void>"; }
+
+int main () {
+  using namespace unittest;
+
+  test("optional") = {
+    task("default-constructor") = [] {
+      core::optional<int> opt;
+      assert::is_true(not opt);
+      assert::equal(opt, core::nullopt);
+    },
+
+    task("copy-constructor") = [] {
+      core::optional<int> opt { 4 };
+      core::optional<int> copy { opt };
+      assert::is_false(not opt);
+      assert::is_false(not copy);
+      assert::equal(opt, copy);
+      assert::equal(copy.value(), 4);
+    },
+
+    task("move-constructor") = [] {
+      core::optional<int> opt { 4 };
+      core::optional<int> move { std::move(opt) };
+      assert::is_false(not opt); // should be in a valid, but null state
+      assert::is_false(not move);
+      assert::equal(move.value(), 4);
+    },
+
+    task("null-constructor") = [] {
+      core::optional<int> opt { core::nullopt };
+      assert::is_true(not opt);
+    },
+
+    task("copy-value-constructor") = [] {
+      std::string text { "copy-value" };
+      core::optional<std::string> opt { text };
+
+      assert::is_false(text.empty());
+      assert::is_true(bool(opt));
+      assert::equal(opt.value(), text);
+      assert::equal(opt.value(), std::string { "copy-value" });
+    },
+
+    task("move-value-constructor") = [] {
+      std::string text { "move-value" };
+      core::optional<std::string> opt { std::move(text) };
+      assert::is_true(bool(opt));
+      assert::is_true(text.empty());
+      assert::equal(opt.value(), std::string { "move-value" });
+    },
+
+    task("in-place-constructor") = [] {
+      core::optional<std::string> opt1 { core::in_place, "in-place" };
+      core::optional<std::string> opt2 { core::in_place,
+        { 'i', 'n', '-', 'p', 'l', 'a', 'c', 'e' }
+      };
+      assert::is_true(bool(opt1));
+      assert::is_true(bool(opt2));
+      assert::equal(opt1, std::string { "in-place" });
+      assert::equal(opt2, std::string { "in-place" });
+      assert::equal(opt1, opt2);
+    },
+
+    task("null-assign-operator") = [] {
+      core::optional<int> opt { 4 };
+      assert::is_false(not opt);
+      opt = core::nullopt;
+      assert::is_true(not opt);
+    },
+
+    task("copy-assign-operator") = [] {
+      core::optional<int> opt { 4 };
+      core::optional<int> copy { };
+      copy = opt;
+
+      assert::is_false(not opt);
+      assert::is_false(not copy);
+      assert::equal(opt, copy);
+      assert::equal(*copy, 4);
+    },
+
+    task("move-assign-operator") = [] {
+      core::optional<int> opt { 4 };
+      core::optional<int> move { };
+      move = std::move(opt);
+
+      assert::is_false(not opt); // in a valid, but null state
+      assert::is_false(not move);
+      assert::equal(*move, 4);
+    },
+
+    task("copy-value-assign-operator") = [] {
+      core::optional<int> opt { };
+      int value = 4;
+      opt = value;
+      assert::is_true(bool(opt));
+      assert::equal(*opt, 4);
+    },
+
+    task("move-value-assign-operator") = [] {
+      core::optional<std::string> opt { };
+      std::string value { "move-value" };
+      opt = std::move(value);
+      assert::is_true(value.empty());
+      assert::is_true(bool(opt));
+      assert::equal(*opt, std::string { "move-value" });
+    },
+
+    task("arrow-operator") = [] {
+      core::optional<std::string> opt { "arrow" };
+      assert::is_false(not opt);
+      assert::is_false(opt->empty());
+    },
+
+    task("dereference-operator") = [] {
+      core::optional<int> opt { 56 };
+      assert::is_false(not opt);
+      assert::equal(*opt, 56);
+    },
+
+    task("value") = [] {
+      assert::throws<core::bad_optional_access>([] {
+        core::optional<int> opt { };
+        int x = opt.value();
+        std::ignore = x;
+      });
+    },
+
+    task("value-or") = [] {
+      core::optional<std::string> opt { };
+      core::optional<std::string> val { "value-or" };
+
+      auto first = opt.value_or("value-or");
+      auto second = val.value_or("not-value");
+
+      assert::equal(first, std::string { "value-or" });
+      assert::equal(second, std::string { "value-or" });
+    },
+
+    task("emplace") = [] {
+      core::optional<int> opt { };
+      opt.emplace(4);
+      assert::is_false(not opt);
+      assert::equal(*opt, 4);
+    },
+
+    task("equality-comparable") = [] {
+      core::optional<int> lhs_int { };
+      core::optional<int> rhs_int { };
+
+      rhs_int.emplace(7);
+
+      assert::is_false(core::nullopt == rhs_int);
+      assert::equal(lhs_int, decltype(rhs_int) { });
+      assert::equal(lhs_int, core::nullopt);
+      assert::equal(rhs_int, 7);
+      assert::equal(7, rhs_int);
+    },
+
+    task("less-than-comparable") = [] {
+      core::optional<int> empty_lhs { };
+      core::optional<int> empty_rhs { };
+      core::optional<int> lhs { 4 };
+      core::optional<int> rhs { 8 };
+
+      assert::is_false(empty_lhs < empty_rhs);
+      assert::less(empty_lhs, rhs);
+      assert::less(lhs, rhs);
+
+      assert::less(empty_lhs, core::nullopt);
+      assert::less(core::nullopt, rhs);
+      assert::less(lhs, 5);
+    },
+
+    task("make-optional") = [] {
+      auto opt = core::make_optional<std::string>("make-optional");
+      assert::is_true(bool(opt));
+      assert::equal(*opt, std::string { "make-optional" });
+    },
+
+    task("swap") = [] {
+      using std::swap;
+      core::optional<int> lhs { 4 };
+      core::optional<int> rhs { };
+      core::optional<int> rhs2 { 4 };
+
+      swap(lhs, rhs);
+
+      assert::is_true(not lhs);
+      assert::is_true(bool(rhs));
+      assert::equal(rhs, 4);
+      assert::equal(rhs, rhs2);
+
+      swap(lhs, rhs);
+
+      assert::is_true(not rhs);
+      assert::is_true(bool(lhs));
+      assert::equal(lhs, 4);
+      assert::equal(lhs, rhs2);
+
+    },
+
+    task("hash") = [] {
+      std::unordered_map<core::optional<std::string>, int> values = {
+        std::make_pair(core::make_optional<std::string>("text1"), 0),
+        std::make_pair(core::make_optional<std::string>("text2"), 1),
+        std::make_pair(core::make_optional<std::string>("text3"), 2),
+      };
+
+      assert::equal(values[core::make_optional<std::string>("text1")], 0);
+      assert::equal(values[core::make_optional<std::string>("text2")], 1);
+      assert::equal(values[core::make_optional<std::string>("text3")], 2);
+    },
+
+    task("force-disengage") = [] {
+      core::optional<int> value { 5 };
+      assert::is_true(static_cast<bool>(value));
+      value = {};
+      assert::is_false(static_cast<bool>(value));
+    }
+  };
+
+  test("constexpr-optional") = {
+    task("default-constructor") = [] {
+      constexpr core::optional<int> opt { };
+      constexpr bool value = static_cast<bool>(opt);
+      static_assert(not value, "");
+    },
+
+    task("nullopt-constructor") = [] {
+      constexpr core::optional<int> opt { core::nullopt };
+      constexpr bool value = static_cast<bool>(opt);
+      static_assert(not value, "");
+    },
+
+    task("value-constructor") = [] {
+      constexpr int value = 7;
+      constexpr core::optional<int> copy { value };
+      constexpr core::optional<int> move { 5 };
+      static_assert(copy, "could not initialize core::optional<int>");
+      static_assert(move, "could not initialize core::optional<int>");
+      constexpr bool copy_result = *copy == value;
+      constexpr bool move_result = *move == 5;
+      static_assert(copy_result, "");
+      static_assert(move_result, "");
+    },
+
+    task("variadic-value-constructor") = [] {
+      constexpr core::optional<variadic> list { core::in_place, { 1, 2, 3, 4 } };
+      constexpr core::optional<variadic> nolist { core::in_place, 1, "words" };
+      constexpr bool list_initd = static_cast<bool>(list);
+      constexpr bool nolist_initd = static_cast<bool>(nolist);
+      static_assert(list_initd, "");
+      static_assert(nolist_initd, "");
+    },
+
+    task("value") = [] {
+      constexpr core::optional<int> opt { 5 };
+      constexpr int value { opt.value() };
+      static_assert(value == 5, "");
+    },
+
+    task("value-or") = [] {
+      constexpr core::optional<int> engaged { 5 };
+      constexpr core::optional<int> disengaged { };
+      constexpr int value_or_e = engaged.value_or(7);
+      constexpr int value_or_d = disengaged.value_or(7);
+      static_assert(value_or_e == 5, "");
+      static_assert(value_or_d == 7, "");
+    },
+
+    task("operator-star") = [] {
+      constexpr core::optional<int> lhs { 5 };
+      constexpr int value { *lhs };
+      static_assert(value == 5, "");
+    },
+
+    task("operator-equal") = [] {
+      constexpr core::optional<int> lhs { 4 };
+      constexpr core::optional<int> rhs { 4 };
+      constexpr int value { 4 };
+
+      constexpr bool first_result = lhs == rhs;
+      constexpr bool second_result = lhs == value;
+      constexpr bool third_result = value == rhs;
+      constexpr bool fourth_result = core::optional<int> { } == core::nullopt;
+      constexpr bool fifth_result = core::nullopt == core::optional<int> { };
+
+      static_assert(first_result, "");
+      static_assert(second_result, "");
+      static_assert(third_result, "");
+      static_assert(fourth_result, "");
+      static_assert(fifth_result, "");
+    },
+
+    task("operator-not-equal") = [] {
+      constexpr core::optional<int> lhs { 4 };
+      constexpr core::optional<int> rhs { 3 };
+      constexpr int value { 2 };
+
+      constexpr bool first_result = lhs != rhs;
+      constexpr bool second_result = lhs != value;
+      constexpr bool third_result = value != rhs;
+      constexpr bool fourth_result = lhs != core::nullopt;
+      constexpr bool fifth_result = core::nullopt != rhs;
+
+      static_assert(first_result, "");
+      static_assert(second_result, "");
+      static_assert(third_result, "");
+      static_assert(fourth_result, "");
+      static_assert(fifth_result, "");
+    },
+
+    task("operator-greater-equal") = [] {
+      constexpr core::optional<int> lhs { 4 };
+      constexpr core::optional<int> rhs { 3 };
+      constexpr int value { 3 };
+
+      constexpr bool first_result = lhs >= rhs;
+      constexpr bool second_result = lhs >= value;
+      constexpr bool third_result = value >= rhs;
+      constexpr bool fourth_result = lhs >= core::nullopt;
+      constexpr bool fifth_result = core::nullopt >= core::optional<int> { };
+
+      static_assert(first_result, "");
+      static_assert(second_result, "");
+      static_assert(third_result, "");
+      static_assert(fourth_result, "");
+      static_assert(fifth_result, "");
+    },
+
+    task("operator-less-equal") = [] {
+      constexpr core::optional<int> lhs { 3 };
+      constexpr core::optional<int> rhs { 3 };
+      constexpr int rhs_value { 4 };
+      constexpr int lhs_value { 2 };
+
+      constexpr bool first_result = lhs <= rhs;
+      constexpr bool second_result = lhs <= rhs_value;
+      constexpr bool third_result = lhs_value <= rhs;
+      constexpr bool fourth_result = core::optional<int> { } <= core::nullopt;
+      constexpr bool fifth_result = core::nullopt <= rhs;
+
+      static_assert(first_result, "");
+      static_assert(second_result, "");
+      static_assert(third_result, "");
+      static_assert(fourth_result, "");
+      static_assert(fifth_result, "");
+    },
+
+    task("operator-greater") = [] {
+      constexpr core::optional<int> lhs { 3 };
+      constexpr core::optional<int> rhs { 2 };
+      constexpr int rhs_value { 2 };
+      constexpr int lhs_value { 3 };
+
+      constexpr bool first_result = lhs > rhs;
+      constexpr bool second_result = lhs > rhs_value;
+      constexpr bool third_result = lhs_value > rhs;
+      constexpr bool fourth_result = lhs > core::nullopt;
+      constexpr bool fifth_result = core::nullopt > core::optional<int> { };
+
+      static_assert(first_result, "");
+      static_assert(second_result, "");
+      static_assert(third_result, "");
+      static_assert(fourth_result, "");
+      static_assert(not fifth_result, "");
+    },
+
+    task("operator-less") = [] {
+      constexpr core::optional<int> lhs { 3 };
+      constexpr core::optional<int> rhs { 4 };
+      constexpr int rhs_value { 4 };
+      constexpr int lhs_value { 3 };
+
+      constexpr bool first_result = lhs < rhs;
+      constexpr bool second_result = lhs < rhs_value;
+      constexpr bool third_result = lhs_value < rhs;
+      constexpr bool fourth_result = core::optional<int> { } < core::nullopt;
+      constexpr bool fifth_result = core::nullopt < rhs;
+
+      static_assert(first_result, "");
+      static_assert(second_result, "");
+      static_assert(third_result, "");
+      static_assert(fourth_result, "");
+      static_assert(fifth_result, "");
+    }
+  };
+
+  test("expected") = {
+    task("copy-value-constructor") = [] {
+      auto value = 53;
+      core::expected<int> copy { value };
+
+      assert::is_true(bool(copy));
+      assert::equal(copy.value(), value);
+    },
+
+    task("move-value-constructor") = [] {
+      std::string value { "move-value" };
+      core::expected<std::string> move { std::move(value) };
+
+      assert::is_true(bool(move));
+      assert::is_true(value.empty());
+
+      assert::equal(move.value(), std::string { "move-value" });
+    },
+
+    task("copy-constructor") = [] {
+      core::expected<int> value { 5 };
+      core::expected<int> copy { value };
+
+      assert::is_true(bool(value));
+      assert::is_true(bool(copy));
+
+      assert::equal(value.value(), copy.value());
+      assert::equal(copy.value(), 5);
+    },
+
+    task("move-constructor") = [] {
+      core::expected<std::string> value { "move" };
+      core::expected<std::string> move { std::move(value) };
+
+      assert::is_true(bool(value));
+      assert::is_true(bool(move));
+
+      assert::is_true(value.value().empty());
+      assert::is_false(move.value().empty());
+      assert::equal(move.value(), std::string { "move" });
+    },
+
+    task("ptr-constructor") = [] {
+      auto ptr = std::make_exception_ptr(std::logic_error { "test" });
+      core::expected<int> value { ptr };
+
+      assert::is_true(not value);
+      auto exception = value.expect<std::logic_error>();
+      assert::equal(std::string { exception.what() }, std::string { "test" });
+    },
+
+    task("copy-value-assign-operator") = [] {
+      core::expected<int> value { };
+      value = 5;
+      assert::is_true(bool(value));
+      assert::equal(value.value(), 5);
+    },
+
+    task("move-value-assign-operator") = [] {
+      core::expected<std::string> value { };
+      std::string str { "move" };
+      value = std::move(str);
+      assert::is_true(bool(value));
+      assert::is_true(str.empty());
+      assert::equal(value.value(), std::string { "move" });
+    },
+
+    task("move-assign-operator") = [] {
+      core::expected<std::string> value { "move" };
+      core::expected<std::string> move { };
+      move = std::move(value);
+
+      assert::is_true(bool(value));
+      assert::is_true(bool(move));
+      assert::is_true(value.value().empty());
+
+      assert::equal(move.value(), std::string { "move" });
+    },
+
+    task("copy-assign-operator") = [] {
+      core::expected<std::string> value { "copy" };
+      core::expected<std::string> copy { };
+      copy = value;
+
+      assert::is_true(bool(value));
+      assert::is_true(bool(copy));
+      assert::equal(copy.value(), value.value());
+
+      assert::equal(copy.value(), std::string { "copy" });
+    },
+
+    task("ptr-assign-operator") = [] {
+      std::logic_error exception { "error" };
+      auto ptr = std::make_exception_ptr(exception);
+      core::expected<std::string> value { };
+      value = ptr;
+
+      assert::is_true(not value);
+      assert::equal(value, ptr);
+      assert::throws<std::logic_error>([&value] { value.raise(); });
+    },
+
+    task("dereference-operator") = [] {
+      core::expected<int> nothrow { 51 };
+
+      assert::is_true(bool(nothrow));
+
+      assert::equal(*nothrow, 51);
+    },
+
+    task("arrow-operator") = [] {
+      core::expected<std::string> nothrow { "words" };
+      assert::is_true(bool(nothrow));
+      assert::equal(nothrow->at(0), 'w');
+    },
+
+    task("operator-equal") = [] {
+      core::expected<int> lhs { 5 };
+      core::expected<int> rhs { 6 };
+
+      assert::is_true(bool(lhs));
+      assert::is_true(bool(rhs));
+      assert::equal(lhs, 5);
+      assert::equal(6, rhs);
+      assert::equal(lhs, core::expected<int> { 5 });
+      assert::equal(core::expected<int> { 6 }, rhs);
+    },
+
+    task("operator-not-equal") = [] {
+      core::expected<int> lhs { 5 };
+      core::expected<int> rhs { 6 };
+
+      core::expected<int> invalid { ::std::exception_ptr { } };
+
+      assert::is_true(bool(lhs));
+      assert::is_true(bool(rhs));
+      assert::not_equal(lhs, rhs);
+      assert::not_equal(lhs, invalid);
+      assert::not_equal(invalid, rhs);
+    },
+
+    task("operator-greater-equal") = [] {
+      core::expected<int> lhs { 5 };
+      core::expected<int> rhs { 4 };
+      core::expected<int> invalid { ::std::exception_ptr { } };
+
+      assert::greater_equal(lhs, rhs);
+      assert::greater_equal(lhs, invalid);
+      assert::greater_equal(invalid, ::std::exception_ptr { });
+      assert::greater_equal(lhs, 3);
+      assert::greater_equal(lhs, 5);
+      assert::greater_equal(6, rhs);
+      assert::greater_equal(4, rhs);
+    },
+
+    task("operator-less-equal") = [] {
+      core::expected<int> lhs { 5 };
+      core::expected<int> rhs { 6 };
+      core::expected<int> invalid { ::std::exception_ptr { } };
+
+      assert::less_equal(lhs, rhs);
+      assert::less_equal(invalid, rhs);
+      assert::less_equal(::std::exception_ptr { }, invalid);
+      assert::less_equal(lhs, 5);
+      assert::less_equal(lhs, 6);
+      assert::less_equal(5, rhs);
+      assert::less_equal(6, rhs);
+    },
+
+    task("operator-greater") = [] {
+      core::expected<int> lhs { 6 };
+      core::expected<int> rhs { 5 };
+
+      assert::greater(lhs, rhs);
+      assert::greater(lhs, 5);
+      assert::greater(6, rhs);
+    },
+
+    task("operator-less") = [] {
+      core::expected<int> lhs { 5 };
+      core::expected<int> rhs { 6 };
+
+      assert::is_true(bool(lhs));
+      assert::is_true(bool(rhs));
+      assert::less(lhs, rhs);
+      assert::less(lhs, 6);
+    },
+
+    task("value-or") = [] {
+      std::logic_error error { "error" };
+      core::expected<std::string> value1 { std::make_exception_ptr(error) };
+      core::expected<std::string> value2 { "value-or" };
+      auto first = value1.value_or("value-or");
+      auto second = value2.value_or("not-value");
+      auto third = core::expected<std::string> { "value-or" }.value_or("empty");
+
+      assert::equal(first, std::string { "value-or" });
+      assert::equal(second, std::string { "value-or" });
+      assert::equal(third, std::string { "value-or" });
+    },
+
+    task("value") = [] {
+      assert::throws<std::logic_error>([]{
+        auto ptr = std::make_exception_ptr(std::logic_error { "" });
+        core::expected<std::string> value { ptr };
+        std::ignore = value.value();
+      });
+    },
+
+    task("expect") = [] {
+      core::expected<int> value { };
+      core::expected<int> error {
+        std::make_exception_ptr(std::logic_error { "error" })
+      };
+      assert::is_true(bool(value));
+      assert::throws<core::bad_expected_type>([&value] {
+        std::ignore = value.expect<std::nested_exception>();
+      });
+      auto err = error.expect<std::logic_error>();
+      assert::equal(std::string { err.what() }, std::string { "error" });
+    },
+
+    task("raise") = [] {
+      core::expected<int> value { };
+      core::expected<int> error {
+        std::make_exception_ptr(std::logic_error { "raise" })
+      };
+      assert::is_true(bool(value));
+      assert::throws<core::bad_expected_type>([&value] { value.raise(); });
+      assert::throws<std::logic_error>([&error] { error.raise(); });
+    },
+
+    task("swap") = [] {
+      using std::swap;
+      auto ptr = std::make_exception_ptr(std::logic_error { "swap" });
+      core::expected<int> error { ptr };
+      core::expected<int> value { 5 };
+
+      assert::is_true(bool(value));
+      assert::is_true(not error);
+
+      swap(value, error);
+
+      assert::is_true(bool(error));
+      assert::is_true(not value);
+    },
+
+    task("make_expected") = [] {
+      auto value = core::make_expected(std::string { "make-expected" });
+      auto error = core::make_expected<std::string>(
+        std::make_exception_ptr(std::logic_error { "error" })
+      );
+      auto logic_error = core::make_expected<std::string>(
+        std::logic_error { "logic-error" }
+      );
+
+      assert::is_true(bool(value));
+      assert::is_true(not logic_error);
+      assert::is_true(not error);
+
+      assert::equal(*value, std::string { "make-expected" });
+    }
+  };
+
+  test("result") = {
+    task("copy-value-constructor") = [] {
+      std::string value { "copy" };
+      core::result<std::string> result { value };
+
+      assert::is_true(bool(result));
+      assert::equal(*result, "copy");
+    },
+
+    task("move-value-constructor") = [] {
+      std::string value { "move" };
+      core::result<std::string> result { std::move(value) };
+
+      assert::is_true(bool(result));
+      assert::equal(value.size(), 0u);
+      assert::equal(*result, "move");
+    },
+
+    task("copy-constructor") = [] {
+      core::result<int> value { 7 };
+      core::result<int> copy { value };
+
+      assert::is_true(bool(value));
+      assert::is_true(bool(copy));
+      assert::equal(*value, 7);
+      assert::equal(*copy, 7);
+    },
+
+    task("move-constructor") = [] {
+      core::result<std::string> value { "move" };
+      core::result<std::string> move { core::move(value) };
+
+      assert::is_true(bool(value));
+      assert::is_true(bool(move));
+
+      assert::is_true(value->empty());
+      assert::equal(move, std::string { "move" });
+    },
+
+    task("error-condition-constructor") = [] {
+      ::std::error_condition error { std::errc::permission_denied };
+      core::result<std::string> value { error };
+      assert::is_true(not value);
+      assert::equal(value.condition(), error);
+    },
+
+    task("error-condition-enum-constructor") = [] {
+      core::result<std::string> value { std::errc::permission_denied };
+      assert::is_true(not value);
+      constexpr auto compare = static_cast<
+        core::underlying_type_t<std::errc>
+      >(std::errc::permission_denied);
+      assert::equal(value.condition().value(), compare);
+    },
+
+    task("copy-value-assign-operator") = [] {
+      core::result<int> copy { };
+      copy = 4;
+
+      assert::is_true(bool(copy));
+      assert::equal(copy, 4);
+    },
+
+    task("move-value-assign-operator") = [] {
+      core::result<std::string> move { };
+
+      assert::is_true(move->empty());
+      move = "move";
+      assert::equal(move, std::string { "move" });
+    },
+
+    task("copy-assign-operator") = [] {
+      core::result<std::string> value { "copy" };
+      core::result<std::string> copy { };
+      copy = value;
+
+      assert::is_true(bool(value));
+      assert::is_true(bool(copy));
+      assert::equal(value, copy);
+      assert::equal(copy, std::string { "copy" });
+    },
+
+    task("move-assign-operator") = [] {
+      core::result<std::string> value { "move" };
+      core::result<std::string> move { };
+
+      move = core::move(value);
+
+      assert::is_true(bool(value));
+      assert::is_true(bool(move));
+      assert::is_true(value->empty());
+      assert::equal(move, std::string { "move" });
+    },
+
+    task("error-condition-assign-operator") = [] {
+      auto error = make_error_condition(std::errc::permission_denied);
+      core::result<std::string> value { };
+      value = error;
+      assert::is_true(not value);
+      assert::equal(value.condition(), error);
+    },
+
+    task("error-condition-enum-assign-operator") = [] {
+      core::result<std::string> value { };
+      value = std::errc::permission_denied;
+      assert::is_false(bool(value));
+    },
+
+    task("operator-star") = [] {
+      core::result<int> value { 6 };
+      assert::equal(*value, 6);
+    },
+
+    task("operator-arrow") = [] {
+      core::result<std::string> value { };
+      assert::is_true(value->empty());
+    },
+
+    task("operator-equal") = [] {
+      core::result<std::string> lhs_valid { };
+      core::result<std::string> rhs_valid { };
+      core::result<std::string> invalid { std::errc::permission_denied };
+      std::string value { };
+      auto const condition = make_error_condition(std::errc::permission_denied);
+      auto const code = make_error_code(std::errc::permission_denied);
+
+      assert::equal(lhs_valid, rhs_valid);
+      assert::equal(invalid, condition);
+      assert::equal(condition, invalid);
+      assert::equal(invalid, code);
+      assert::equal(code, invalid);
+      assert::equal(lhs_valid, value);
+      assert::equal(value, rhs_valid);
+    },
+
+    task("operator-not-equal") = [] {
+      core::result<std::string> lhs_valid { "lhs" };
+      core::result<std::string> rhs_valid { "rhs" };
+      std::string value { "value" };
+      auto const condition = make_error_condition(std::errc::permission_denied);
+      auto const code = make_error_code(std::errc::permission_denied);
+
+      assert::not_equal(lhs_valid, rhs_valid);
+      assert::not_equal(lhs_valid, condition);
+      assert::not_equal(condition, rhs_valid);
+      assert::not_equal(lhs_valid, code);
+      assert::not_equal(code, rhs_valid);
+      assert::not_equal(lhs_valid, value);
+      assert::not_equal(value, rhs_valid);
+    },
+
+    task("operator-greater-equal") = [] {
+      core::result<int> lhs { 5 };
+      core::result<int> rhs { 4 };
+      auto const condition = make_error_condition(std::errc::permission_denied);
+      core::result<int> invalid { condition };
+
+      assert::greater_equal(lhs, rhs);
+      assert::greater_equal(lhs, invalid);
+      assert::greater_equal(invalid, condition);
+      assert::greater_equal(lhs, 3);
+      assert::greater_equal(lhs, 5);
+      assert::greater_equal(6, rhs);
+      assert::greater_equal(4, rhs);
+    },
+
+    task("operator-less-equal") = [] {
+      core::result<int> lhs { 3 };
+      core::result<int> rhs { 6 };
+      auto const condition = make_error_condition(std::errc::permission_denied);
+      core::result<int> invalid { condition };
+
+      assert::less_equal(lhs, rhs);
+      assert::less_equal(invalid, rhs);
+      assert::less_equal(condition, invalid);
+      assert::less_equal(lhs, 3);
+      assert::less_equal(lhs, 5);
+      assert::less_equal(6, rhs);
+      assert::less_equal(4, rhs);
+    },
+
+    task("operator-greater") = [] {
+      core::result<std::string> valid { "valid" };
+      auto const error = make_error_condition(std::errc::permission_denied);
+      auto const less_error = std::error_condition {
+        1,
+        std::generic_category()
+      };
+      core::result<std::string> invalid { error };
+
+      core::result<std::string> less_invalid { less_error };
+
+      assert::greater(valid, invalid);
+      assert::greater(invalid, less_invalid);
+      assert::greater(valid, error);
+      assert::greater(error, less_invalid);
+      assert::greater(std::string { "zalid" }, valid);
+      assert::greater(valid, std::string { "alid" });
+    },
+
+    task("operator-less") = [] {
+      core::result<std::string> valid { "valid" };
+      auto const error = make_error_condition(std::errc::permission_denied);
+      auto const less_error = std::error_condition {
+        1,
+        std::generic_category()
+      };
+      core::result<std::string> invalid { error };
+
+      core::result<std::string> less_invalid { less_error };
+
+      assert::less(invalid, valid);
+      assert::less(less_invalid, invalid);
+      assert::less(error, valid);
+      assert::less(less_invalid, error);
+      assert::less(valid, std::string { "zalid" });
+      assert::less(std::string { "alid" }, valid);
+    },
+
+    task("value-or") = [] {
+      core::result<std::string> value { "value" };
+      core::result<std::string> error { std::errc::permission_denied };
+      assert::equal(value.value_or(""), "value");
+      assert::equal(error.value_or("error"), "error");
+    },
+
+    task("value") = [] {
+      core::result<std::string> value { "value" };
+      core::result<std::string> thrower { std::errc::permission_denied };
+
+      assert::equal(value.value(), "value");
+      assert::throws<std::system_error>([&] {
+        std::ignore = thrower.value();
+      });
+    },
+
+    task("condition") = [] {
+      auto const error = make_error_condition(std::errc::permission_denied);
+      core::result<std::string> value { error };
+      assert::equal(value.condition(), error);
+    },
+
+    task("swap") = [] {
+      using ::std::swap;
+      core::result<std::string> lhs_valid { "lhs" };
+      core::result<std::string> rhs_valid { "rhs" };
+      auto const error = make_error_condition(std::errc::permission_denied);
+      core::result<std::string> invalid { error };
+
+      swap(lhs_valid, rhs_valid);
+      assert::equal(lhs_valid, std::string { "rhs" });
+      assert::equal(rhs_valid, std::string { "lhs" });
+
+      swap(lhs_valid, invalid);
+
+      assert::is_false(bool(lhs_valid));
+      assert::is_true(bool(invalid));
+      assert::equal(lhs_valid, error);
+      assert::equal(invalid, std::string { "rhs" });
+    },
+
+    task("make-result") = [] {
+      auto result = core::make_result(std::string { "value" });
+      auto condition = core::make_result<std::string>(
+        make_error_condition(std::errc::permission_denied)
+      );
+      auto error = core::make_result<std::string>(std::errc::permission_denied);
+      constexpr auto value = std::is_same<
+        decltype(result),
+        core::result<std::string>
+      >::value;
+
+      assert::is_true(bool(value));
+      assert::is_false(bool(condition));
+      assert::is_false(bool(error));
+    }
+  };
+
+  test("expected<void>") = {
+    task("default-constructor") = [] {
+      core::expected<void> value { };
+      assert::is_true(bool(value));
+    },
+
+    task("copy-constructor") = [] {
+      auto ptr = std::make_exception_ptr(std::logic_error { "" });
+      core::expected<void> value { ptr };
+      core::expected<void> copy { value };
+
+      assert::is_true(not value);
+      assert::is_true(not copy);
+
+      assert::equal(value.pointer(), copy.pointer());
+      assert::equal(value.pointer(), ptr);
+      assert::equal(copy.pointer(), ptr);
+    },
+
+    task("move-constructor") = [] {
+      auto ptr = std::make_exception_ptr(std::logic_error { "" });
+      core::expected<void> value { ptr };
+      core::expected<void> move { std::move(value) };
+
+      assert::is_true(not move);
+
+      assert::equal(move.pointer(), ptr);
+    },
+
+    task("ptr-constructor") = [] {
+      auto ptr = std::make_exception_ptr(std::logic_error { "" });
+      core::expected<void> value { ptr };
+
+      assert::is_true(not value);
+      assert::equal(ptr, value.pointer());
+    },
+
+    task("copy-assign-operator") = [] {
+      auto ptr = std::make_exception_ptr(std::logic_error { "" });
+      core::expected<void> value { ptr };
+      core::expected<void> copy { };
+
+      assert::is_true(bool(copy));
+
+      copy = value;
+
+      assert::is_true(not value);
+      assert::is_true(not copy);
+
+      assert::equal(value.pointer(), copy.pointer());
+      assert::equal(value.pointer(), ptr);
+      assert::equal(copy.pointer(), ptr);
+    },
+
+    task("move-assign-operator") = [] {
+      auto ptr = std::make_exception_ptr(std::logic_error { "" });
+      core::expected<void> value { ptr };
+      core::expected<void> move { };
+
+      assert::is_true(bool(move));
+
+      move = std::move(value);
+
+      assert::is_true(not move);
+
+      assert::equal(move.pointer(), ptr);
+    },
+
+    task("equality-comparable") = [] {
+      auto ptr = std::make_exception_ptr(std::logic_error { "" });
+      core::expected<void> empty_lhs { };
+      core::expected<void> empty_rhs { };
+
+      core::expected<void> lhs { ptr };
+      core::expected<void> rhs { ptr };
+
+      assert::is_true(bool(empty_lhs));
+      assert::is_true(bool(empty_rhs));
+
+      assert::equal(empty_lhs, empty_rhs);
+      assert::equal(lhs.pointer(), rhs.pointer());
+      assert::equal(lhs.pointer(), ptr);
+      assert::equal(rhs.pointer(), ptr);
+      assert::equal(lhs, ptr);
+      assert::equal(ptr, rhs);
+    },
+
+    task("expect") = [] {
+      core::expected<void> value { };
+      core::expected<void> error {
+        std::make_exception_ptr(std::logic_error { "error" })
+      };
+      assert::is_true(bool(value));
+      assert::throws<core::bad_expected_type>([&value] {
+        std::ignore = value.expect<std::nested_exception>();
+      });
+      auto err = error.expect<std::logic_error>();
+      assert::equal(std::string { err.what() }, std::string { "error" });
+    },
+
+    task("raise") = [] {
+      core::expected<void> value { };
+      core::expected<void> error {
+        std::make_exception_ptr(std::logic_error { "raise" })
+      };
+      assert::is_true(bool(value));
+      assert::throws<core::bad_expected_type>([&value] { value.raise(); });
+      assert::throws<std::logic_error>([&error] { error.raise(); });
+    },
+
+    task("swap") = [] {
+      using std::swap;
+      auto lhs_ptr = std::make_exception_ptr(std::logic_error { "" });
+      auto rhs_ptr = std::make_exception_ptr(core::bad_expected_type { "" });
+
+      core::expected<void> lhs { lhs_ptr };
+      core::expected<void> rhs { rhs_ptr };
+
+      assert::is_true(not lhs);
+      assert::is_true(not rhs);
+      assert::equal(lhs.pointer(), lhs_ptr);
+      assert::equal(rhs.pointer(), rhs_ptr);
+
+      swap(lhs, rhs);
+
+      assert::is_true(not lhs);
+      assert::is_true(not rhs);
+      assert::equal(lhs.pointer(), rhs_ptr);
+      assert::equal(rhs.pointer(), lhs_ptr);
+    }
+  };
+
+
+  test("result<void>") = {
+    task("default-constructor") = [] {
+      core::result<void> value;
+      assert::is_true(bool(value));
+    },
+
+    task("copy-constructor") = [] {
+      core::result<void> value { };
+      core::result<void> copy { value };
+      assert::equal(copy, value);
+    },
+
+    task("move-constructor") = [] {
+      core::result<void> value { };
+      core::result<void> move { core::move(value) };
+      assert::equal(value, move);
+    },
+
+    task("error-condition-constructor") = [] {
+      auto const error = make_error_condition(std::errc::permission_denied);
+      core::result<void> value { error };
+      assert::is_false(bool(value));
+      assert::equal(value, error);
+    },
+
+    task("error-condition-enum-constructor") = [] {
+      core::result<void> value { std::errc::permission_denied };
+      assert::is_false(bool(value));
+      assert::equal(value, make_error_condition(std::errc::permission_denied));
+    },
+
+    task("copy-assign-operator") = [] {
+      core::result<void> value { std::errc::permission_denied };
+      core::result<void> copy { };
+
+      assert::is_false(bool(value));
+      value = copy;
+      assert::is_true(bool(value));
+    },
+
+    task("move-assign-operator") = [] {
+      core::result<void> value { std::errc::permission_denied };
+      core::result<void> move { };
+      assert::is_false(bool(value));
+      value = core::move(move);
+      assert::is_true(bool(value));
+    },
+
+    task("error-condition-assign-operator") = [] {
+      core::result<void> value { };
+      auto const error = make_error_condition(std::errc::permission_denied);
+      assert::is_true(bool(value));
+      value = error;
+      assert::is_false(bool(value));
+    },
+
+    task("error-condition-enum-assign-operator") = [] {
+      core::result<void> value { };
+      assert::is_true(bool(value));
+      value = std::errc::permission_denied;
+      assert::is_false(bool(value));
+    },
+
+    task("operator-equal") = [] {
+      core::result<void> lhs_valid { };
+      core::result<void> rhs_valid { };
+      core::result<void> lhs_invalid { std::errc::permission_denied };
+      core::result<void> rhs_invalid { std::errc::permission_denied };
+
+      assert::equal(lhs_valid, rhs_valid);
+      assert::equal(lhs_invalid, rhs_invalid);
+    },
+
+    task("condition") = [] {
+      auto const condition = make_error_condition(std::errc::permission_denied);
+      core::result<void> valid { };
+      core::result<void> invalid { condition };
+
+      assert::is_true(bool(valid));
+      assert::is_false(bool(invalid));
+
+      assert::equal(invalid, condition);
+      assert::throws<core::bad_result_condition>([&] {
+        std::ignore = valid.condition();
+      });
+    },
+  };
+
+  monitor::run();
+}
diff --git a/src/bsoncxx/third_party/core/tests/range.cpp b/src/bsoncxx/third_party/core/tests/range.cpp
new file mode 100644
index 0000000..640e11c
--- /dev/null
+++ b/src/bsoncxx/third_party/core/tests/range.cpp
@@ -0,0 +1,453 @@
+#include <core/range.hpp>
+
+#include <forward_list>
+#include <vector>
+#include <string>
+#include <list>
+
+#include <sstream>
+
+#include <unittest/unittest.hpp>
+
+int main () {
+  using namespace unittest;
+
+  test("range") = {
+
+    task("iterator-constructor") = [] {
+      std::string value { "iterator" };
+      core::range<std::string::iterator> range { value.begin(), value.end() };
+      assert::equal(value.begin(), range.begin());
+      assert::equal(value.end(), range.end());
+    },
+
+    task("default-constructor") = [] {
+      core::range<std::string::iterator> range { };
+      assert::is_true(range.empty());
+    },
+
+    task("range-constructor") = [] {
+      std::string value { "range" };
+      core::range<std::string::iterator> range { value };
+      assert::equal(value.begin(), range.begin());
+      assert::equal(value.end(), range.end());
+    },
+
+    task("pair-constructor") = [] {
+      std::string value { "pair" };
+      core::range<std::string::iterator> range {
+        std::make_pair(value.begin(), value.end())
+      };
+      assert::equal(value.begin(), range.begin());
+      assert::equal(value.end(), range.end());
+    },
+
+    task("copy-constructor") = [] {
+      std::string value { "copy" };
+      core::range<std::string::iterator> range { value };
+      core::range<std::string::iterator> copy { range };
+      assert::equal(value.begin(), range.begin());
+      assert::equal(value.begin(), copy.begin());
+      assert::equal(value.end(), range.end());
+      assert::equal(value.end(), copy.end());
+    },
+
+    task("move-constructor") = [] {
+      std::string value { "move" };
+      core::range<std::string::iterator> range { value };
+      core::range<std::string::iterator> move { std::move(range) };
+
+      assert::equal(value.begin(), move.begin());
+      assert::equal(value.end(), move.end());
+      assert::is_true(range.empty());
+    },
+
+    task("copy-assign-operator") = [] {
+      std::string value { "copy" };
+      core::range<std::string::iterator> range { value };
+      core::range<std::string::iterator> copy { };
+
+      assert::is_true(copy.empty());
+
+      copy = range;
+
+      assert::is_true(not copy.empty());
+      assert::equal(copy.begin(), range.begin());
+      assert::equal(copy.end(), range.end());
+    },
+
+    task("move-assign-operator") = [] {
+      std::string value { "move" };
+      core::range<std::string::iterator> range { value };
+      core::range<std::string::iterator> move { };
+
+      assert::is_true(move.empty());
+
+      move = std::move(range);
+
+      assert::is_true(not move.empty());
+      assert::is_true(range.empty());
+
+      assert::equal(value.begin(), move.begin());
+      assert::equal(value.end(), move.end());
+    },
+
+    task("subscript-operator") = [] {
+      std::string value { "subscript" };
+      core::range<std::string::iterator> range { value };
+
+      assert::is_true(not range.empty());
+      assert::equal(
+        static_cast<std::string::size_type>(range.size()),
+        value.size()
+      );
+
+      assert::equal(range[0], 's');
+      assert::equal(range[1], 'u');
+      assert::equal(range[2], 'b');
+      assert::equal(range[3], 's');
+      assert::equal(range[4], 'c');
+      assert::equal(range[5], 'r');
+      assert::equal(range[6], 'i');
+      assert::equal(range[7], 'p');
+      assert::equal(range[8], 't');
+    },
+
+    task("begin") = [] {
+      std::string value { "begin" };
+      core::range<std::string::iterator> range { value };
+      auto begin = std::begin(range);
+      assert::equal(value.begin(), begin);
+    },
+
+    task("end") = [] {
+      std::string value { "end" };
+      core::range<std::string::iterator> range { value };
+      auto end = std::end(range);
+      assert::equal(value.end(), end);
+    },
+
+    task("front") = [] {
+      std::string value { "front" };
+      core::range<std::string::iterator> range { value };
+      assert::equal(range.front(), 'f');
+    },
+
+    task("back") = [] {
+      std::string value { "back" };
+      core::range<std::string::iterator> range { value };
+      assert::equal(range.back(), 'k');
+    },
+
+    task("empty") = [] {
+      std::string value { };
+      core::range<std::string::iterator> range { value };
+      assert::is_true(range.empty());
+    },
+
+    task("size") = [] {
+      std::string value { "size" };
+      core::range<std::string::iterator> range { value };
+      assert::equal(
+        value.size(),
+        static_cast<std::string::size_type>(range.size())
+      );
+    },
+
+    task("slice") = [] {
+      std::string value { "slice-a-long-string" };
+      core::range<std::string::iterator> range { value };
+
+      auto slice = range.slice(6);
+
+      assert::equal(
+        std::string { "a-long-string" },
+        std::string { slice.begin(), slice.end() }
+      );
+
+      assert::equal(slice.begin(), range.begin() + 6);
+      assert::equal(slice.end(), range.end());
+      assert::equal(slice.size(), 13);
+
+      slice = range.slice(-7);
+
+      assert::equal(
+        std::string { "-string" },
+        std::string { slice.begin(), slice.end() }
+      );
+
+      assert::equal(slice.begin(), range.end() - 7);
+      assert::equal(slice.end(), range.end());
+
+      slice = range.slice(6, -7);
+
+      assert::equal(
+        std::string { "a-long" },
+        std::string { slice.begin(), slice.end() }
+      );
+
+      /* bidirectional-range specific */
+      std::string bidir_value { "bidirectional-range" };
+      std::list<char> bidirectional { bidir_value.begin(), bidir_value.end() };
+      core::range<std::list<char>::iterator> bidir { bidirectional };
+      auto bislice = bidir.slice(2, -6);
+
+      assert::equal(
+        std::string { "directional" },
+        std::string { bislice.begin(), bislice.end() }
+      );
+
+      /* forward-range specific */
+      std::string forward_value { "a-forward-range" };
+      std::forward_list<char> forward_list {
+        forward_value.begin(),
+        forward_value.end()
+      };
+      core::range<std::forward_list<char>::iterator> forward_range {
+        forward_list
+      };
+
+      auto forward_slice = forward_range.slice(2, -6);
+      assert::equal(
+        std::string { "forward" },
+        std::string { forward_slice.begin(), forward_slice.end() }
+      );
+    },
+
+    task("split") = [] {
+      std::string value { "splitstring" };
+      core::range<std::string::iterator> range { value };
+      auto pair = range.split(5);
+
+      assert::equal(
+        std::string { "split" },
+        std::string { std::get<0>(pair).begin(), std::get<0>(pair).end() }
+      );
+
+      assert::equal(
+        std::string { "string" },
+        std::string { std::get<1>(pair).begin(), std::get<1>(pair).end() }
+      );
+    },
+
+    task("pop-front") = [] {
+      std::string value { "pop-front" };
+      core::range<std::string::iterator> range { value };
+      assert::is_false(range.empty());
+
+      range.pop_front();
+
+      assert::equal(range[0], 'o');
+      assert::equal(range[1], 'p');
+      assert::equal(range[2], '-');
+      assert::equal(range[3], 'f');
+      assert::equal(range[4], 'r');
+      assert::equal(range[5], 'o');
+      assert::equal(range[6], 'n');
+      assert::equal(range[7], 't');
+
+      range.pop_front(3);
+
+      assert::equal(range[0], 'f');
+      assert::equal(range[1], 'r');
+      assert::equal(range[2], 'o');
+      assert::equal(range[3], 'n');
+      assert::equal(range[4], 't');
+
+      range.pop_front(-4);
+
+      assert::equal(range[0], 'p');
+      assert::equal(range[1], 'o');
+      assert::equal(range[2], 'p');
+      assert::equal(range[3], '-');
+      assert::equal(range[4], 'f');
+      assert::equal(range[5], 'r');
+      assert::equal(range[6], 'o');
+      assert::equal(range[7], 'n');
+      assert::equal(range[8], 't');
+    },
+
+    task("pop-back") = [] {
+      std::string value { "pop-back" };
+      core::range<std::string::iterator> range { value };
+
+      assert::equal(range[0], 'p');
+      assert::equal(range[1], 'o');
+      assert::equal(range[2], 'p');
+      assert::equal(range[3], '-');
+      assert::equal(range[4], 'b');
+      assert::equal(range[5], 'a');
+      assert::equal(range[6], 'c');
+      assert::equal(range[7], 'k');
+
+      range.pop_back();
+
+      assert::equal(range.size(), 7);
+
+      assert::equal(range[0], 'p');
+      assert::equal(range[1], 'o');
+      assert::equal(range[2], 'p');
+      assert::equal(range[3], '-');
+      assert::equal(range[4], 'b');
+      assert::equal(range[5], 'a');
+      assert::equal(range[6], 'c');
+
+      range.pop_back(4);
+
+      assert::equal(range.size(), 3);
+
+      assert::equal(range[0], 'p');
+      assert::equal(range[1], 'o');
+      assert::equal(range[2], 'p');
+
+      range.pop_back(-5);
+
+      assert::equal(range.size(), value.size());
+
+      assert::equal(range[0], 'p');
+      assert::equal(range[1], 'o');
+      assert::equal(range[2], 'p');
+      assert::equal(range[3], '-');
+      assert::equal(range[4], 'b');
+      assert::equal(range[5], 'a');
+      assert::equal(range[6], 'c');
+      assert::equal(range[7], 'k');
+    },
+
+    task("pop-front-upto") = [] {
+      std::string value { "pop-front-upto" };
+      core::range<std::string::iterator> range { value };
+
+      assert::equal(value.begin(), range.begin());
+      assert::equal(value.end(), range.end());
+
+      range.pop_front_upto(4);
+
+      assert::not_equal(value.begin(), range.begin());
+      assert::equal(value.end(), range.end());
+
+      assert::equal(range[0], 'f');
+      assert::equal(range[1], 'r');
+      assert::equal(range[2], 'o');
+      assert::equal(range[3], 'n');
+      assert::equal(range[4], 't');
+      assert::equal(range[5], '-');
+      assert::equal(range[6], 'u');
+      assert::equal(range[7], 'p');
+      assert::equal(range[8], 't');
+      assert::equal(range[9], 'o');
+
+      /* Attempt to pop backwards and WAAAY past the beginning */
+      range.pop_front_upto(-15);
+
+      assert::equal(range.size(), 10);
+    },
+
+    task("pop-back-upto") = [] {
+      std::string value { "pop-back-upto" };
+      core::range<std::string::iterator> range { value };
+
+      assert::equal(value.begin(), range.begin());
+      assert::equal(value.end(), range.end());
+      range.pop_back_upto(5);
+
+      assert::not_equal(value.end(), range.end());
+      assert::equal(value.begin(), range.begin());
+      assert::equal(range.size(), 8);
+
+      assert::equal(range[0], 'p');
+      assert::equal(range[1], 'o');
+      assert::equal(range[2], 'p');
+      assert::equal(range[3], '-');
+      assert::equal(range[4], 'b');
+      assert::equal(range[5], 'a');
+      assert::equal(range[6], 'c');
+      assert::equal(range[7], 'k');
+
+      /* Attempt to pop backwards and waaaay past the end */
+      range.pop_back_upto(-15);
+
+      assert::equal(range.size(), 8);
+    },
+
+    task("swap") = [] {
+      using std::swap;
+      std::string second { "second" };
+      std::string first { "first" };
+
+      core::range<std::string::iterator> lhs { first };
+      core::range<std::string::iterator> rhs { second };
+
+      assert::is_false(lhs.empty());
+      assert::is_false(rhs.empty());
+
+      assert::equal(lhs.size(), first.size());
+      assert::equal(rhs.size(), second.size());
+
+      assert::equal(lhs[0], 'f');
+      assert::equal(lhs[1], 'i');
+      assert::equal(lhs[2], 'r');
+      assert::equal(lhs[3], 's');
+      assert::equal(lhs[4], 't');
+
+      assert::equal(rhs[0], 's');
+      assert::equal(rhs[1], 'e');
+      assert::equal(rhs[2], 'c');
+      assert::equal(rhs[3], 'o');
+      assert::equal(rhs[4], 'n');
+      assert::equal(rhs[5], 'd');
+
+      swap(lhs, rhs);
+
+      assert::is_false(lhs.empty());
+      assert::is_false(rhs.empty());
+
+      assert::equal(lhs.size(), second.size());
+      assert::equal(rhs.size(), first.size());
+
+      assert::equal(rhs[0], 'f');
+      assert::equal(rhs[1], 'i');
+      assert::equal(rhs[2], 'r');
+      assert::equal(rhs[3], 's');
+      assert::equal(rhs[4], 't');
+
+      assert::equal(lhs[0], 's');
+      assert::equal(lhs[1], 'e');
+      assert::equal(lhs[2], 'c');
+      assert::equal(lhs[3], 'o');
+      assert::equal(lhs[4], 'n');
+      assert::equal(lhs[5], 'd');
+    },
+
+    task("make-range") = [] {
+      std::string value { "make-range" };
+      auto string_range = core::make_range(value);
+
+      assert::equal(
+        value,
+        std::string { string_range.begin(), string_range.end() }
+      );
+
+      std::istringstream stream { value };
+      auto stream_range = core::make_range<char>(stream);
+
+      std::ostringstream ostream { };
+      for (auto ch : stream_range) { ostream << ch; }
+
+      assert::equal(
+        value,
+        ostream.str()
+      );
+
+      std::istringstream stream2 { value };
+      auto buf_range = core::make_range(stream2.rdbuf());
+
+      assert::equal(
+        value,
+        std::string { buf_range.begin(), buf_range.end() }
+      );
+    }
+  };
+
+  monitor::run();
+}
diff --git a/src/bsoncxx/third_party/core/tests/string.cpp b/src/bsoncxx/third_party/core/tests/string.cpp
new file mode 100644
index 0000000..fbd5c7f
--- /dev/null
+++ b/src/bsoncxx/third_party/core/tests/string.cpp
@@ -0,0 +1,389 @@
+#include <core/string.hpp>
+
+#include <unordered_map>
+#include <sstream>
+#include <cstring>
+
+#include <unittest/unittest.hpp>
+
+int main () {
+  using namespace unittest;
+
+  test("basic-string-view") = {
+    task("default-constructor") = [] {
+      constexpr core::string_view ref { };
+      assert::equal(ref.length(), 0u);
+      assert::equal(ref.size(), 0u);
+      assert::is_true(ref.empty());
+      assert::is_null(ref.data());
+    },
+
+    task("copy-constructor") = [] {
+      constexpr core::string_view ref { "hello!", 6 };
+
+      assert::equal(ref.length(), 6u);
+      assert::equal(ref.size(), 6u);
+      assert::is_false(ref.empty());
+      assert::is_not_null(ref.data());
+
+      constexpr core::string_view copy { ref };
+
+      assert::equal(copy.length(), ref.length());
+      assert::equal(copy.size(), ref.size());
+      assert::equal(copy.empty(), ref.empty());
+      assert::equal(copy.data(), ref.data());
+
+      assert::equal(copy, ref);
+    },
+
+    task("string-constructor") = [] {
+      std::string str { "string-ctor" };
+      core::string_view ref { str };
+
+      assert::is_not_null(ref.data());
+      assert::is_false(ref.empty());
+      assert::equal(ref.size(), 11u);
+      assert::is(ref.data(), str.data());
+    },
+
+    task("pointer-constructor") = [] {
+      auto str = "pointer-constructor";
+      core::string_view ref { str };
+
+      assert::is_not_null(ref.data());
+      assert::is_false(ref.empty());
+
+      assert::equal(ref.size(), std::strlen(str));
+      assert::is(ref.data(), str);
+    },
+
+    task("pointer-len-constructor") = [] {
+      constexpr core::string_view ref { "pointer-len", 11 };
+
+      assert::is_not_null(ref.data());
+      assert::is_false(ref.empty());
+      assert::equal(ref.size(), 11u);
+    },
+
+    task("copy-assignment-operator") = [] {
+      core::string_view ref { "copy-assign" };
+      core::string_view copy { };
+      copy = ref;
+
+      assert::is_false(copy.empty());
+      assert::is_false(ref.empty());
+      assert::equal(copy.size(), ref.size());
+      assert::is(copy.data(), ref.data());
+
+      assert::equal(copy, ref);
+    },
+
+    task("explicit-string-cast") = [] {
+      core::string_view ref { "explicit-string-cast" };
+      auto str = static_cast<std::string>(ref);
+
+      assert::is_true(std::is_same<decltype(str), std::string>::value);
+      assert::equal(str, std::string { "explicit-string-cast" });
+    },
+
+    task("to-string") = [] {
+      core::string_view ref { "to-string" };
+      auto str = ref.to_string();
+
+      assert::equal(str, "to-string");
+    },
+
+    task("max-size") = [] {
+      constexpr core::string_view ref { };
+
+      assert::equal(ref.max_size(), 0u);
+    },
+
+    task("size") = [] {
+      constexpr core::string_view ref { "size", 4 };
+
+      assert::equal(ref.size(), 4u);
+    },
+
+    task("empty") = [] {
+      constexpr core::string_view empty_ref { };
+      constexpr core::string_view valid_ref { "valid", 5 };
+
+      assert::is_false(valid_ref.empty());
+      assert::is_true(empty_ref.empty());
+    },
+
+    task("subscript-operator") = [] {
+      core::string_view ref { "subscript" };
+
+      assert::equal(ref[0], 's');
+      assert::equal(ref[1], 'u');
+      assert::equal(ref[2], 'b');
+      assert::equal(ref[3], 's');
+      assert::equal(ref[4], 'c');
+      assert::equal(ref[5], 'r');
+      assert::equal(ref[6], 'i');
+      assert::equal(ref[7], 'p');
+      assert::equal(ref[8], 't');
+    },
+
+    task("front") = [] {
+      core::string_view ref { "front" };
+      assert::equal('f', ref.front());
+    },
+
+    task("back") = [] {
+      core::string_view ref { "back" };
+      assert::equal('k', ref.back());
+    },
+
+    task("data") = [] {
+      auto literal = "data-test";
+      core::string_view ref { literal };
+      assert::is(ref.data(), literal);
+    },
+
+    task("remove-prefix") = [] {
+      core::string_view ref { "remove-prefix" };
+      ref.remove_prefix(7);
+      assert::equal(ref, core::string_view { "prefix" });
+      assert::equal(ref.size(), 6u);
+    },
+
+    task("remove-suffix") = [] {
+      core::string_view ref { "remove-suffix" };
+      ref.remove_suffix(7);
+      assert::equal(ref, core::string_view { "remove" });
+      assert::equal(ref.size(), 6u);
+    },
+
+    task("clear") = [] {
+      core::string_view ref { "hello", 5 };
+
+      assert::is_false(ref.empty());
+      assert::equal(ref.size(), 5u);
+
+      ref.clear();
+
+      assert::is_true(ref.empty());
+      assert::is_null(ref.data());
+    },
+
+    task("substr") = [] {
+      using core::string_view;
+      std::string str { "0123456789abcdefghij" };
+      string_view ref { str };
+
+      assert::equal(ref.substr(10), string_view { "abcdefghij" });
+      assert::equal(ref.substr(5, 3), string_view { "567" });
+      assert::equal(ref.substr(12, 100), string_view { "cdefghij" });
+      assert::equal(ref.substr(ref.size() - 3, 50), string_view { "hij" });
+    },
+
+    task("starts-with") = [] {
+      core::string_view ref { "starts-with" };
+      assert::is_true(ref.starts_with("starts"));
+    },
+
+    task("ends-with") = [] {
+      core::string_view ref { "ends-with" };
+      assert::is_true(ref.ends_with("with"));
+    },
+
+    task("compare") = [] {
+      core::string_view ref { "compare" };
+
+      assert::greater(ref.compare("comparable"), 0);
+      assert::greater(ref.compare("bompare"), 0);
+      assert::greater(ref.compare("comp"), 0);
+      assert::equal(ref.compare("compare"), 0);
+      assert::less(ref.compare("comparu"), 0);
+      assert::less(ref.compare("dompare"), 0);
+    },
+
+    task("at") = [] {
+      core::string_view ref { "string-view-at" };
+
+      assert::equal(ref.at(0), 's');
+      assert::equal(ref.at(1), 't');
+      assert::equal(ref.at(2), 'r');
+      assert::equal(ref.at(3), 'i');
+      assert::equal(ref.at(4), 'n');
+      assert::equal(ref.at(5), 'g');
+      assert::equal(ref.at(6), '-');
+      assert::equal(ref.at(7), 'v');
+      assert::equal(ref.at(8), 'i');
+      assert::equal(ref.at(9), 'e');
+      assert::equal(ref.at(10), 'w');
+      assert::equal(ref.at(11), '-');
+      assert::equal(ref.at(12), 'a');
+      assert::equal(ref.at(13), 't');
+
+      assert::throws<std::out_of_range>([ref] { std::ignore = ref.at(14); });
+    },
+
+    task("find-first-not-of") = [] {
+      core::string_view ref { "find-first-not-of" };
+      core::string_view search_pass { "findrsto" };
+      core::string_view search_fail { "findrsto-" };
+      auto npos = core::string_view::npos;
+
+      /* char comparisons */
+      assert::equal(ref.find_first_not_of('x'), 0u);
+      assert::equal(ref.find_first_not_of('f'), 1u);
+
+      /* string-view comparisons */
+      assert::equal(ref.find_first_not_of(search_pass), 4u);
+      assert::equal(ref.find_first_not_of(search_fail), npos);
+    },
+
+    task("find-last-not-of") = [] {
+      core::string_view ref { "find-last-not-of" };
+      core::string_view search_pass { "findlasto" };
+      core::string_view search_fail { "findlasto-" };
+      auto npos = core::string_view::npos;
+
+      /* char comparisons */
+      assert::equal(ref.find_last_not_of('x'), ref.size() - 1);
+      assert::equal(ref.find_last_not_of('f'), ref.size() - 2);
+
+      /* string-view comparisons */
+      assert::equal(ref.find_last_not_of(search_pass), 13u);
+      assert::equal(ref.find_last_not_of(search_fail), npos);
+    },
+
+    task("find-first-of") = [] {
+      core::string_view ref { "find-first-of" };
+      core::string_view search_pass { "pass" };
+      core::string_view search_fail { "que?" };
+
+      auto npos = core::string_view::npos; /* used to solve linker issue */
+
+      /* char comparisons */
+      assert::equal(ref.find_first_of('x'), npos);
+      assert::equal(ref.find_first_of('f'), 0u);
+
+      /* string-view comparisons */
+      assert::equal(ref.find_first_of(search_fail), npos);
+      assert::equal(ref.find_first_of(search_pass), 8u);
+    },
+
+    task("find-last-of") = [] {
+      core::string_view ref { "find-last-of" };
+      core::string_view pass { "pass" };
+      core::string_view fail { "exqu" };
+
+      auto npos = core::string_view::npos;
+
+      assert::equal(ref.find_last_of('f'), ref.size() - 1);
+      assert::equal(ref.find_last_of('x'), npos);
+
+      assert::equal(ref.find_last_of(fail), npos);
+      assert::equal(ref.find_last_of(pass), 7u);
+    },
+
+    task("rfind") = [] {
+      core::string_view ref { "rfind" };
+      auto npos = core::string_view::npos;
+
+      assert::equal(ref.find("in"), 2u);
+      assert::equal(ref.find('d'), ref.size() - 1);
+
+      assert::equal(ref.find("string"), npos);
+      assert::equal(ref.find('x'), npos);
+    },
+
+    task("find") = [] {
+      core::string_view ref { "find" };
+      auto npos = core::string_view::npos;
+
+      assert::equal(ref.find("in"), 1u);
+      assert::equal(ref.find('d'), 3u);
+
+      assert::equal(ref.find("string"), npos);
+      assert::equal(ref.find('x'), npos);
+    },
+
+    task("swap") = [] {
+      using std::swap;
+      core::string_view lhs { "lhs" };
+      core::string_view rhs { "rhs" };
+
+      assert::equal(lhs, core::string_view { "lhs" });
+      assert::equal(rhs, core::string_view { "rhs" });
+
+      swap(lhs, rhs);
+
+      assert::equal(lhs, core::string_view { "rhs" });
+      assert::equal(rhs, core::string_view { "lhs" });
+    },
+
+    task("operator-equal") = [] {
+      core::string_view lhs { "operator-equal" };
+      core::string_view rhs { "operator-equal" };
+
+      assert::equal(lhs, rhs);
+    },
+
+    task("operator-not-equal") = [] {
+      core::string_view lhs { "operator-not-equal" };
+      core::string_view rhs { "rhs" };
+
+      assert::not_equal(lhs, rhs);
+    },
+
+    task("operator-greater-equal") = [] {
+      core::string_view lhs { "fghij" };
+      core::string_view rhs { "abcde" };
+
+      assert::greater_equal(lhs, rhs);
+      assert::greater_equal(lhs, lhs);
+    },
+
+    task("operator-less-equal") = [] {
+      core::string_view lhs { "abcde" };
+      core::string_view rhs { "bcdef" };
+
+      assert::less_equal(lhs, rhs);
+      assert::less_equal(lhs, lhs);
+    },
+
+    task("operator-greater") = [] {
+      core::string_view lhs { "bcdef" };
+      core::string_view rhs { "abcde" };
+
+      assert::greater(lhs, rhs);
+    },
+
+    task("operator-less") = [] {
+      core::string_view lhs { "abcde" };
+      core::string_view rhs { "fghij" };
+
+      assert::less(lhs, rhs);
+    },
+
+    task("operator-stream-insert") = [] {
+      std::string str { "operator-stream-insert" };
+      core::string_view ref { str };
+
+      std::ostringstream stream;
+      stream << ref;
+
+      assert::equal(stream.str(), str);
+    },
+
+    task("hash") = [] {
+      std::unordered_map<core::string_view, int> values = {
+        { "one", 1 },
+        { "two", 2 },
+        { "thr", 3 }
+      };
+
+      assert::equal(values["one"], 1);
+      assert::equal(values["two"], 2);
+      assert::equal(values["thr"], 3);
+    }
+  };
+
+  monitor::run();
+}
diff --git a/src/bsoncxx/third_party/core/tests/type-traits.cpp b/src/bsoncxx/third_party/core/tests/type-traits.cpp
new file mode 100644
index 0000000..98e9e13
--- /dev/null
+++ b/src/bsoncxx/third_party/core/tests/type-traits.cpp
@@ -0,0 +1,57 @@
+#include <core/type_traits.hpp>
+
+#include <unittest/unittest.hpp>
+
+namespace {
+
+struct A { A (A const&); };
+struct B { };
+struct C { };
+struct D {
+  D (D const&) noexcept;
+  D& operator = (D const&) noexcept;
+};
+
+struct E {
+  E (E const&) = delete;
+  E (E&&) = delete;
+  E& operator = (E const&) = delete;
+  E& operator = (E&&) = delete;
+};
+
+void swap (B&, B&);
+void swap (C&, C&) noexcept;
+
+} /* nameless namespace */
+
+int main () {
+  using namespace unittest;
+
+  test("type-traits") = {
+    task("is-null-pointer") = [] {
+      using null = std::nullptr_t;
+
+      assert::is_true(core::is_null_pointer<null>::value);
+      assert::is_true(core::is_null_pointer<null const>::value);
+      assert::is_true(core::is_null_pointer<null volatile>::value);
+      assert::is_true(core::is_null_pointer<null volatile const>::value);
+    },
+
+    task("is-nothrow-swappable") = [] {
+      assert::is_true(core::is_nothrow_swappable<int>::value);
+      assert::is_false(core::is_nothrow_swappable<A>::value);
+      assert::is_false(core::is_nothrow_swappable<B>::value);
+      assert::is_true(core::is_nothrow_swappable<C>::value);
+      assert::is_true(core::is_nothrow_swappable<D>::value);
+    },
+
+    task("is-swappable") = [] {
+      assert::is_true(core::is_swappable<A>::value);
+      assert::is_true(core::is_swappable<B>::value);
+      assert::is_true(core::is_swappable<C>::value);
+      assert::is_true(core::is_swappable<D>::value);
+    }
+  };
+
+  monitor::run();
+}
diff --git a/src/bsoncxx/third_party/core/tests/utility.cpp b/src/bsoncxx/third_party/core/tests/utility.cpp
new file mode 100644
index 0000000..1de559f
--- /dev/null
+++ b/src/bsoncxx/third_party/core/tests/utility.cpp
@@ -0,0 +1,40 @@
+#include <core/utility.hpp>
+
+#include <unittest/unittest.hpp>
+
+int main () {
+  using namespace unittest;
+
+  test("scope-guard") = {
+    task("value-constructor") = [] {
+      bool value { false };
+      { auto scope = core::make_scope_guard([&]{ value = true; }); }
+      assert::is_true(value);
+    },
+
+    task("dismiss") = [] {
+      bool value { false };
+      {
+        auto scope = core::make_scope_guard([&] { value = true; });
+        scope.dismiss();
+      }
+      assert::is_false(value);
+    }
+  };
+
+  test("value-at") = {
+    task("runtime") = [] {
+      auto value = core::value_at<3>(1, 2, 3, 4);
+      assert::equal(value, 4);
+    },
+
+    task("compile-time") = [] {
+      constexpr auto value = core::value_at<3>(1, 2, 3, 4);
+      constexpr auto second = core::value_at<2>(1, 2, 4.0f, "");
+      static_assert(value == 4, "");
+      static_assert(second > 3.9f, "");
+    }
+  };
+
+  monitor::run();
+}
diff --git a/src/bsoncxx/third_party/core/tests/variant.cpp b/src/bsoncxx/third_party/core/tests/variant.cpp
new file mode 100644
index 0000000..7fd1bb4
--- /dev/null
+++ b/src/bsoncxx/third_party/core/tests/variant.cpp
@@ -0,0 +1,274 @@
+#include <core/variant.hpp>
+
+#include <unordered_map>
+#include <string>
+#include <vector>
+
+#include <cstdint>
+
+#include <unittest/unittest.hpp>
+
+int main () {
+  using namespace unittest;
+
+  test("variant") = {
+    task("default-constructor") = [] {
+      core::variant<std::string, int> variant { };
+      assert::equal(typeid(std::string), variant.type());
+    },
+
+    task("value-constructor") = [] {
+      using variant_type = core::variant<std::string, std::uint64_t>;
+
+      variant_type string { "value-constructor" };
+      variant_type integer { 64 };
+
+      assert::equal(string.type(), typeid(std::string));
+      assert::equal(integer.type(), typeid(std::uint64_t));
+
+      assert::equal(std::get<0>(string), std::string { "value-constructor" });
+      assert::equal(std::get<1>(integer), 64u);
+    },
+
+    task("move-constructor") = [] {
+      using variant_type = core::variant<std::string, double>;
+      variant_type variant { std::string { "move" } };
+      variant_type move { std::move(variant) };
+
+      assert::equal(move.type(), typeid(std::string));
+      assert::equal(std::get<0>(move), std::string { "move" });
+      assert::is_true(std::get<0>(variant).empty());
+    },
+
+    task("copy-constructor") = [] {
+      using variant_type = core::variant<std::string, double>;
+      variant_type variant { 0.8 };
+      variant_type copy { variant };
+
+      assert::equal(copy.type(), typeid(double));
+      assert::equal(variant, copy);
+    },
+
+    task("value-assignment-operator") = [] {
+      using variant_type = core::variant<std::string, double>;
+      std::string string { "value" };
+      double real { 0.6 };
+
+      variant_type first { };
+      variant_type second { };
+
+      first = string;
+
+      assert::equal(first.type(), typeid(std::string));
+      assert::equal(std::get<0>(first), string);
+
+      second = real;
+
+      assert::equal(second.type(), typeid(double));
+      assert::equal(std::get<1>(second), real);
+    },
+
+    task("move-assignment-operator") = [] {
+      using variant_type = core::variant<std::string, double>;
+      variant_type variant { "move" };
+      variant_type move { 9.8 };
+
+      move = std::move(variant);
+
+      assert::equal(move.type(), typeid(std::string));
+      assert::equal(std::get<0>(move), std::string { "move" });
+      assert::is_true(std::get<0>(variant).empty());
+    },
+
+    task("copy-assignment-operator") = [] {
+      using variant_type = core::variant<std::string, double>;
+      variant_type variant { 9.8 };
+      variant_type copy { };
+
+      copy = variant;
+
+      assert::equal(copy.type(), typeid(double));
+      assert::equal(std::get<1>(copy), 9.8);
+      assert::equal(copy, variant);
+    },
+
+    task("visit") = [] {
+      using variant_type = core::variant<
+        std::uint64_t,
+        std::string,
+        std::vector<int>
+      >;
+
+      variant_type vector { std::vector<int> { 1, 2, 3 } };
+
+      struct visitor final {
+        std::string operator ()(std::string const& str) const { return str; }
+        std::string operator ()(std::uint64_t const& val) const {
+          return std::to_string(val);
+        }
+        std::string operator ()(std::vector<int> const& vec) const {
+          auto value = vec.at(0) + vec.at(1) + vec.at(2);
+          return std::to_string(value);
+        }
+      };
+
+      auto str = vector.visit(visitor { });
+      assert::equal(str, std::string { "6" });
+    },
+
+    task("match") = [] {
+      using variant_type = core::variant<
+        std::uint64_t,
+        std::string,
+        std::vector<std::string>
+      >;
+
+      variant_type vector { std::vector<std::string> { "1", "2", "3" } };
+      variant_type string { std::string { "match" } };
+      variant_type integer { };
+
+      assert::is_true(
+        vector.match(
+          [](std::vector<std::string> const&) { return true; },
+          [](std::uint64_t const&) { return false; },
+          [](std::string const&) { return false; }
+        )
+      );
+
+      assert::is_true(
+        integer.match(
+          [](std::vector<std::string> const&) { return false; },
+          [](std::uint64_t const&) { return true; },
+          [](std::string const&) { return false; }
+        )
+      );
+
+      assert::is_true(
+        string.match(
+          [](std::vector<std::string> const&) { return false; },
+          [](std::uint64_t const&) { return false; },
+          [](std::string const&) { return true; }
+        )
+      );
+    },
+
+    task("which") = [] {
+      using variant_type = core::variant<
+        std::uint64_t,
+        std::string,
+        std::vector<std::string>
+      >;
+
+      variant_type vector { std::vector<std::string> { "1", "2", "3" } };
+      variant_type string { std::string { "which" } };
+      variant_type integer { };
+
+      assert::equal(integer.which(), 0u);
+      assert::equal(string.which(), 1u);
+      assert::equal(vector.which(), 2u);
+    },
+
+    task("empty") = [] {
+      core::variant<std::uint64_t, float> variant { };
+      assert::is_false(variant.empty());
+    },
+
+    task("type") = [] {
+      using variant_type = core::variant<
+        std::uint64_t,
+        std::string,
+        std::vector<std::string>
+      >;
+
+      variant_type vector { std::vector<std::string> { "1", "2", "3" } };
+      variant_type string { std::string { "type" } };
+      variant_type integer { };
+
+      assert::equal(typeid(std::vector<std::string>), vector.type());
+      assert::equal(typeid(std::uint64_t), integer.type());
+      assert::equal(typeid(std::string), string.type());
+    },
+
+    task("get") = [] {
+      using variant_type = core::variant<
+        std::uint64_t,
+        std::string,
+        std::vector<std::string>
+      >;
+
+      variant_type vector { std::vector<std::string> { "1", "2", "3" } };
+      variant_type string { std::string { "get" } };
+      variant_type integer { static_cast<std::uint64_t>(64) };
+
+      assert::throws<core::bad_variant_get>([&vector] {
+        std::ignore = std::get<0>(vector);
+      });
+
+      assert::equal(std::get<0>(integer), 64u);
+      assert::equal(std::get<1>(string), std::string { "get" });
+      assert::equal(std::get<2>(vector)[0], std::string { "1" });
+      assert::equal(std::get<2>(vector)[1], std::string { "2" });
+      assert::equal(std::get<2>(vector)[2], std::string { "3" });
+    },
+
+    task("equality-comparable") = [] {
+      using variant_type = core::variant<
+        std::string,
+        double
+      >;
+
+      variant_type lhs { std::string { "equality-comparable" } };
+      variant_type rhs { std::string { "equality-comparable" } };
+      variant_type frhs { 0.7 };
+
+      assert::equal(lhs, rhs);
+      assert::is_false(lhs == frhs);
+    },
+
+    task("less-than-comparable") = [] {
+      using variant_type = core::variant<
+        std::string,
+        double
+      >;
+
+      variant_type lhs { 0.2 };
+      variant_type rhs { 0.4 };
+      variant_type frhs { std::string { "less-than-comaprable" } };
+
+      assert::less(lhs, rhs);
+      assert::is_false(lhs < frhs);
+    },
+
+    task("swap") = [] {
+      using std::swap;
+      using variant_type = core::variant<std::string, double>;
+      variant_type lhs_str { std::string { "lhs" } };
+      variant_type rhs_str { std::string { "rhs" } };
+      variant_type lhs { 0.8 };
+
+      swap(lhs_str, rhs_str);
+      assert::equal(std::get<0>(lhs_str), std::string { "rhs" });
+      assert::equal(std::get<0>(rhs_str), std::string { "lhs" });
+
+      swap(lhs, rhs_str);
+      assert::equal(lhs.type(), typeid(std::string));
+      assert::equal(rhs_str.type(), typeid(double));
+      assert::equal(std::get<0>(lhs), std::string { "lhs" });
+      assert::equal(std::get<1>(rhs_str), 0.8);
+    },
+
+    task("hash") = [] {
+      using variant_type = core::variant<std::string, double>;
+      using unordered_map = std::unordered_map<variant_type, int>;
+
+      unordered_map map;
+      map[variant_type { "hash" }] = 9;
+      map[variant_type { 9.8 }] = 12;
+
+      assert::equal(map[variant_type { "hash" }], 9);
+      assert::equal(map[variant_type { 9.8 }], 12);
+    }
+  };
+
+  monitor::run();
+}
